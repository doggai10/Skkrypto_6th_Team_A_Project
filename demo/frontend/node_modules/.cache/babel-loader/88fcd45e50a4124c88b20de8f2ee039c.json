{"ast":null,"code":"var _classCallCheck = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/demo/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/demo/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nvar _ = require('lodash');\n\nvar RLP = require('eth-lib/lib/rlp');\n\nvar AccountKeyWeightedMultiSig = require('./accountKeyWeightedMultiSig');\n\nvar AccountKeyLegacy = require('./accountKeyLegacy');\n\nvar AccountKeyPublic = require('./accountKeyPublic');\n\nvar AccountKeyFail = require('./accountKeyFail');\n\nvar utils = require('../../../caver-utils');\n\nvar _require = require('./accountKeyHelper'),\n    ACCOUNT_KEY_TAG = _require.ACCOUNT_KEY_TAG;\n\nvar _require2 = require('../../../caver-wallet/src/keyring/keyringHelper'),\n    KEY_ROLE = _require2.KEY_ROLE;\n\nvar WeightedMultiSigOptions = require('./weightedMultiSigOptions');\n\nfunction isValidRoleBasedKeyFormat(roleBasedAccountKeys) {\n  if (!_.isArray(roleBasedAccountKeys)) return false;\n  if (roleBasedAccountKeys.length > KEY_ROLE.roleLast) return false;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = roleBasedAccountKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var accountKey = _step.value;\n\n      if (accountKey !== undefined && !(accountKey instanceof AccountKeyLegacy) && !(accountKey instanceof AccountKeyPublic) && !(accountKey instanceof AccountKeyFail) && !(accountKey instanceof AccountKeyWeightedMultiSig)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Representing an AccountKeyRoleBased.\n * @class\n */\n\n\nvar AccountKeyRoleBased =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  _createClass(AccountKeyRoleBased, null, [{\n    key: \"decode\",\n\n    /**\n     * Decodes an RLP-encoded AccountKeyRoleBased string.\n     * @param {string} rlpEncodedKey - An RLP-encoded AccountKeyRoleBased string.\n     * @return {AccountKeyRoleBased}\n     */\n    value: function decode(rlpEncodedKey) {\n      rlpEncodedKey = utils.addHexPrefix(rlpEncodedKey);\n      if (!rlpEncodedKey.startsWith(ACCOUNT_KEY_TAG.ACCOUNT_KEY_ROLE_BASED_TAG)) throw new Error(\"Cannot decode to AccountKeyRoleBased. The prefix must be \".concat(ACCOUNT_KEY_TAG.ACCOUNT_KEY_ROLE_BASED_TAG, \": \").concat(rlpEncodedKey));\n      var keys = RLP.decode(\"0x\".concat(rlpEncodedKey.slice(ACCOUNT_KEY_TAG.ACCOUNT_KEY_ROLE_BASED_TAG.length)));\n      var accountKeys = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var key = _step2.value;\n          if (key.startsWith(ACCOUNT_KEY_TAG.ACCOUNT_KEY_ROLE_BASED_TAG)) throw new Error('Nested role based key.');\n\n          if (key.startsWith(ACCOUNT_KEY_TAG.ACCOUNT_KEY_NIL_TAG)) {\n            accountKeys.push(undefined);\n          } else if (key.startsWith(ACCOUNT_KEY_TAG.ACCOUNT_KEY_LEGACY_TAG)) {\n            accountKeys.push(AccountKeyLegacy.decode(key));\n          } else if (key.startsWith(ACCOUNT_KEY_TAG.ACCOUNT_KEY_PUBLIC_TAG)) {\n            accountKeys.push(AccountKeyPublic.decode(key));\n          } else if (key.startsWith(ACCOUNT_KEY_TAG.ACCOUNT_KEY_FAIL_TAG)) {\n            accountKeys.push(AccountKeyFail.decode(key));\n          } else if (key.startsWith(ACCOUNT_KEY_TAG.ACCOUNT_KEY_WEIGHTED_MULTISIG_TAG)) {\n            accountKeys.push(AccountKeyWeightedMultiSig.decode(key));\n          } else {\n            throw new Error(\"Failed to decode RLP-encoded account key. Invalid RLP-encoded account key \".concat(key));\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return new AccountKeyRoleBased(accountKeys);\n    }\n    /**\n     * Creates an instance of AccountKeyRoleBased.\n     * @param {Array.<AccountKeyLegacy|AccountKeyFail|Array.<string>>} roleBasedPubArray - An array of public key strings.\n     * @param {Array.<WeightedMultiSigOptions|object>} options - An array of options which defines threshold and weight.\n     * @return {AccountKeyRoleBased}\n     */\n\n  }, {\n    key: \"fromRoleBasedPublicKeysAndOptions\",\n    value: function fromRoleBasedPublicKeysAndOptions(roleBasedPubArray, options) {\n      if (!options) options = Array(KEY_ROLE.roleLast).fill(new WeightedMultiSigOptions());\n      var accountKeys = []; // Format will be like below\n      // keyArray = [[pub, pub], [pub], [pub, pub, pub]]\n      // keyArray = [[accountKeyLegacy], [accountKeyFail], [pub, pub, pub]]\n      // options = [{threshold: 1, weights: [1,1]}, {}, {threshold: 1, weights: [1,1,1]}]\n\n      for (var i = 0; i < roleBasedPubArray.length; i++) {\n        if (!(options[i] instanceof WeightedMultiSigOptions)) options[i] = WeightedMultiSigOptions.fromObject(options[i]); // To handle instance of AccountKeyLegacy or AccountKeyFail\n\n        if (!_.isArray(roleBasedPubArray[i])) {\n          throw new Error(\"Invalid format of keys: Each role should define the key to use in an array form.\");\n        } // Empty key array means AccountKeyNil\n\n\n        if (roleBasedPubArray[i].length === 0) {\n          if (!options[i].isEmpty()) throw new Error(\"Invalid options: AccountKeyNil cannot have options.\");\n          accountKeys.push(undefined);\n          continue;\n        }\n\n        if (roleBasedPubArray[i].length === 1) {\n          if (roleBasedPubArray[i][0] instanceof AccountKeyLegacy || roleBasedPubArray[i][0] instanceof AccountKeyFail) {\n            if (!options[i].isEmpty()) throw new Error(\"Invalid options: AccountKeyLegacy or AccountKeyFail cannot have options.\");\n            accountKeys.push(roleBasedPubArray[i][0]);\n            continue;\n          }\n\n          if (options[i].isEmpty()) {\n            accountKeys.push(AccountKeyPublic.fromPublicKey(roleBasedPubArray[i][0]));\n            continue;\n          }\n        }\n\n        accountKeys.push(AccountKeyWeightedMultiSig.fromPublicKeysAndOptions(roleBasedPubArray[i], options[i]));\n      }\n\n      return new AccountKeyRoleBased(accountKeys);\n    }\n    /**\n     * Create an instance of AccountKeyRoleBased.\n     * @param {Array.<AccountKeyLegacy|AccountKeyPublic|AccountKeyFail|AccountKeyWeightedMultiSig>} accountKeyArray - An array containing arrays of instances of AccountKeyPublic or AccountKeyWeightedMultiSig for each role.\n     */\n\n  }]);\n\n  function AccountKeyRoleBased(accountKeyArray) {\n    _classCallCheck(this, AccountKeyRoleBased);\n\n    this.accountKeys = accountKeyArray;\n  }\n  /**\n   * @type {Array.<AccountKeyLegacy|AccountKeyPublic|AccountKeyFail|AccountKeyWeightedMultiSig>}\n   */\n\n\n  _createClass(AccountKeyRoleBased, [{\n    key: \"getRLPEncoding\",\n\n    /**\n     * Returns an RLP-encoded AccountKeyRoleBased string.\n     * @return {string}\n     */\n    value: function getRLPEncoding() {\n      var encodedAccountKeys = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.accountKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var accountKey = _step3.value;\n\n          if (accountKey === undefined) {\n            encodedAccountKeys.push(ACCOUNT_KEY_TAG.ACCOUNT_KEY_NIL_TAG);\n            continue;\n          }\n\n          encodedAccountKeys.push(accountKey.getRLPEncoding());\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return ACCOUNT_KEY_TAG.ACCOUNT_KEY_ROLE_BASED_TAG + RLP.encode(encodedAccountKeys).slice(2);\n    }\n  }, {\n    key: \"accountKeys\",\n    get: function get() {\n      return this._accountKeys;\n    },\n    set: function set(keys) {\n      if (!isValidRoleBasedKeyFormat(keys)) throw new Error(\"Invalid role-based account key format.\");\n      this._accountKeys = keys;\n    }\n  }]);\n\n  return AccountKeyRoleBased;\n}();\n\nmodule.exports = AccountKeyRoleBased;","map":null,"metadata":{},"sourceType":"script"}