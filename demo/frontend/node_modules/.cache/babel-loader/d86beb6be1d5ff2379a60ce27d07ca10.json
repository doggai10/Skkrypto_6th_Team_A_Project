{"ast":null,"code":"/*\n    Copyright 2019 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst isValidRole = require('../../../../caver-utils').isValidRole;\n\nconst isValidPublicKey = require('../../../../caver-utils').isValidPublicKey;\n\nclass AccountForUpdate {\n  constructor(address, keyForUpdate, options) {\n    this.address = address;\n    this.keyForUpdate = keyFormatter(keyForUpdate, options);\n  }\n\n  fillUpdateObject(updateObject) {\n    delete updateObject.key;\n    Object.assign(updateObject, this.keyForUpdate);\n  }\n\n}\n\nfunction keyFormatter(keyForUpdate, options) {\n  const keyObject = {};\n\n  if (typeof keyForUpdate === 'string') {\n    if (options) throw new Error('Failed to keyFormatter for AccountForUpdate: AccountKeyPublic/legacyKey/failKey cannot have options');\n\n    switch (keyForUpdate) {\n      case 'legacyKey':\n        keyObject.legacyKey = true;\n        break;\n\n      case 'failKey':\n        keyObject.failKey = true;\n        break;\n\n      default:\n        if (!isValidPublicKey(keyForUpdate)) throw new Error('Invalid public key');\n        keyObject.publicKey = keyForUpdate;\n        break;\n    }\n  } else if (Array.isArray(keyForUpdate)) {\n    if (!options || !options.threshold || !options.weight) throw new Error('For AccountKeyMultiSig, threshold and weight should be defined in options object.');\n    if (!Array.isArray(options.weight)) throw new Error('The weight should be defined as a array.');\n    if (options.weight.length !== keyForUpdate.length) throw new Error('The length of keys in AccountKeyMultiSig and the length of weight array do not match.');\n    keyObject.multisig = {\n      threshold: options.threshold,\n      keys: []\n    };\n    let weightSum = 0;\n\n    for (let i = 0; i < keyForUpdate.length; i++) {\n      const key = keyForUpdate[i];\n      if (!isValidPublicKey(key)) throw new Error('Invalid public key');\n      keyObject.multisig.keys.push({\n        weight: options.weight[i],\n        publicKey: key\n      });\n      weightSum += options.weight[i];\n    }\n\n    if (weightSum < options.threshold) throw new Error('Invalid options for AccountKeyMultiSig: The sum of weights is less than the threshold.');\n  } else {\n    for (const key in keyForUpdate) {\n      if (!isValidRole(key)) throw new Error(`Invalid role is defined: ${key}`);\n      options = options || {};\n\n      if (key === 'transactionKey') {\n        keyObject.roleTransactionKey = keyFormatter(keyForUpdate[key], options.transactionKey);\n      }\n\n      if (key === 'updateKey') {\n        keyObject.roleAccountUpdateKey = keyFormatter(keyForUpdate[key], options.updateKey);\n      }\n\n      if (key === 'feePayerKey') {\n        keyObject.roleFeePayerKey = keyFormatter(keyForUpdate[key], options.feePayerKey);\n      }\n    }\n  }\n\n  return keyObject;\n}\n\nmodule.exports = AccountForUpdate;","map":null,"metadata":{},"sourceType":"script"}