{"ast":null,"code":"var _toConsumableArray = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/demo/frontend/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\n/*\n    Copyright 2018 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nvar _require = require('lodash'),\n    last = _require.last;\n\nvar builtinsMiddleware = require('./builtins');\n\nfunction Middleware() {\n  this.list = [];\n}\n/**\n * getMiddlewares return `this.list` from Middleware instance.\n * @return {Array} `this.list`\n */\n\n\nMiddleware.prototype.getMiddlewares = function () {\n  return this.list;\n};\n/**\n * registerMiddleware - add middleware function to `this.list`\n * @param  {function} middleware function to be registered.\n */\n\n\nMiddleware.prototype.registerMiddleware = function (middleware) {\n  if (typeof middleware !== 'function') throw Error('Middleware should be a function');\n  this.list.push(middleware);\n};\n\nMiddleware.prototype.applyMiddleware = function (data, type, sendRequest) {\n  // Tags `type` property to check whether middleware is consumed from outbound or not.\n  // If consumed as outbound, It tags `data` as 'request'\n  // Otherwise, It tags `data` as 'response'\n  data.type = type === 'outbound' ? 'request' : 'response'; // inbound\n  // For outbound middleware, it must have RPC send function as last middleware.\n\n  handleMiddleware(sendRequest ? // `RPC send` is concatenated as a last middleware.\n  this.list.concat(sendRequest) : // last middleware is not a `RPC send`.\n  _toConsumableArray(this.list), // `bypass` function is only available for outbound middleware\n  data.type === 'request' && sendRequest)(data);\n};\n\nfunction handleMiddleware(list, bypass) {\n  return function recur(data, next) {\n    // When there are no more item in `this.list`,\n    // it means all middleware function has been consumed.\n    if (list.length === 0) return; // When the argument is put into `next()` function,\n    // The `data` argument get changed in next middleware, taking it as first argument `data`.\n\n    if (arguments.length === 2 && typeof next !== 'function') data = next; // Shift first item from `this.list`, consuming it as a middleware function.\n\n    var fn = list.shift(); // Consuming middleware function,\n    // It would be used outerspace as `caver.use(data, next, bypass)`.\n\n    fn(data, recur.bind(null, data), function _bypass() {\n      // `_bypass` function only works when `bypass` value is true.\n      if (!bypass) return; // When the argument is put into `bypass()` function,\n      // The `data` arugment get changed in next middleware which is last one, request manager,\n      // taking it as first argument `data`.\n\n      if (arguments.length !== 0) data = arguments[0]; // `_bypass` function skips all middleware list except last one.\n\n      list = [last(list)];\n      recur(data);\n    });\n  };\n} // Generate `Middleware` instance, it would be exported as a *singleton*.\n\n\nvar middleware = new Middleware();\nmodule.exports = middleware;\nmodule.exports.builtin = builtinsMiddleware;","map":null,"metadata":{},"sourceType":"script"}