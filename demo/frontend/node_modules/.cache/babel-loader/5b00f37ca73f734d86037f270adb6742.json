{"ast":null,"code":"var _slicedToArray = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/demo/frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/demo/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/demo/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nvar AccountLib = require('eth-lib/lib/account');\n\nvar Nat = require('eth-lib/lib/nat');\n\nvar elliptic = require('elliptic');\n\nvar secp256k1 = new elliptic.ec('secp256k1');\n\nvar utils = require('../../../caver-utils');\n\nvar SignatureData = require('./signatureData');\n/**\n * Representing a PrivateKey class that includes private key string.\n * @class\n */\n\n\nvar PrivateKey =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  /**\n   * creates a privateKey.\n   * @param {string} key - The private key string.\n   */\n  function PrivateKey(key) {\n    _classCallCheck(this, PrivateKey);\n\n    this.privateKey = key;\n  }\n  /**\n   * @type {string}\n   */\n\n\n  _createClass(PrivateKey, [{\n    key: \"sign\",\n\n    /**\n     * signs with transactionHash with key and returns signature.\n     *\n     * @param {string} transactionHash The hash of transaction.\n     * @param {string|number} chainId The chainId or the network.\n     * @return {SignatureData}\n     */\n    value: function sign(transactionHash, chainId) {\n      chainId = utils.toHex(chainId);\n      var signature = AccountLib.makeSigner(Nat.toNumber(chainId) * 2 + 35)(transactionHash, this.privateKey);\n\n      var _AccountLib$decodeSig = AccountLib.decodeSignature(signature).map(function (sig) {\n        return utils.makeEven(utils.trimLeadingZero(sig));\n      }),\n          _AccountLib$decodeSig2 = _slicedToArray(_AccountLib$decodeSig, 3),\n          v = _AccountLib$decodeSig2[0],\n          r = _AccountLib$decodeSig2[1],\n          s = _AccountLib$decodeSig2[2];\n\n      return new SignatureData([v, r, s]);\n    }\n    /**\n     * signs with hashed data and returns `signature`\n     *\n     * @param {string} messageHash The hash of data to sign.\n     * @return {SignatureData}\n     */\n\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(messageHash) {\n      var signature = AccountLib.sign(messageHash, this.privateKey);\n\n      var _AccountLib$decodeSig3 = AccountLib.decodeSignature(signature),\n          _AccountLib$decodeSig4 = _slicedToArray(_AccountLib$decodeSig3, 3),\n          v = _AccountLib$decodeSig4[0],\n          r = _AccountLib$decodeSig4[1],\n          s = _AccountLib$decodeSig4[2];\n\n      return new SignatureData([v, r, s]);\n    }\n    /**\n     * returns public key string\n     *\n     * @return {string}\n     */\n\n  }, {\n    key: \"getPublicKey\",\n    value: function getPublicKey() {\n      var compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var strippedPrivateKey = utils.stripHexPrefix(this.privateKey);\n      var ecKey = secp256k1.keyFromPrivate(Buffer.from(strippedPrivateKey, 'hex'));\n      if (!compressed) return \"0x\".concat(ecKey.getPublic(false, 'hex').slice(2));\n      return \"0x\".concat(ecKey.getPublic(true, 'hex'));\n    }\n    /**\n     * returns derived address from private key string\n     *\n     * @return {string}\n     */\n\n  }, {\n    key: \"getDerivedAddress\",\n    value: function getDerivedAddress() {\n      return AccountLib.fromPrivate(this.privateKey).address.toLowerCase();\n    }\n  }, {\n    key: \"privateKey\",\n    get: function get() {\n      return this._privateKey;\n    },\n    set: function set(p) {\n      if (!utils.isValidPrivateKey(p)) throw new Error(\"Invalid private key: \".concat(p));\n      this._privateKey = utils.addHexPrefix(p);\n    }\n  }]);\n\n  return PrivateKey;\n}();\n\nmodule.exports = PrivateKey;","map":null,"metadata":{},"sourceType":"script"}