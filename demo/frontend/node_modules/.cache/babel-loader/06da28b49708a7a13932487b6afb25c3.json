{"ast":null,"code":"var _toConsumableArray = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/demo/frontend/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\n/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-eth/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nvar _ = require('lodash');\n\nvar core = require('../../caver-core');\n\nvar _require = require('../../caver-core-helpers'),\n    formatters = _require.formatters;\n\nvar Subscriptions = require('../../caver-core-subscriptions').subscriptions;\n\nvar Method = require('../../caver-core-method');\n\nvar utils = require('../../caver-utils');\n\nvar Net = require('../../caver-net');\n\nvar Personal = require('../caver-klay-personal');\n\nvar BaseContract = require('../../caver-contract');\n\nvar KIP7 = require('../../caver-kct/src/kip7');\n\nvar KIP17 = require('../../caver-kct/src/kip17');\n\nvar Accounts = require('../caver-klay-accounts');\n\nvar abi = require('../../caver-abi');\n\nvar getNetworkType = require('./getNetworkType.js');\n\nvar rpcCalls = require('../../caver-rtm');\n\nvar _require2 = require('../caver-klay-accounts/src/makeRawTransaction'),\n    decodeFromRawTransaction = _require2.decodeFromRawTransaction;\n\nvar Klay = function Klay() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var _this = this; // sets _requestmanager\n\n\n  core.packageInit(this, args); // overwrite package setRequestManager\n\n  var setRequestManager = this.setRequestManager;\n\n  this.setRequestManager = function (manager) {\n    setRequestManager(manager);\n\n    _this.net.setRequestManager(manager);\n\n    _this.personal.setRequestManager(manager);\n\n    _this.accounts.setRequestManager(manager);\n\n    _this.Contract._requestManager = _this._requestManager;\n    _this.Contract.currentProvider = _this._provider;\n    return true;\n  }; // overwrite setProvider\n\n\n  var setProvider = this.setProvider;\n\n  this.setProvider = function () {\n    for (var _len2 = arguments.length, arg = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      arg[_key2] = arguments[_key2];\n    }\n\n    setProvider.apply(_this, arg);\n\n    _this.setRequestManager(_this._requestManager);\n  };\n\n  var defaultAccount = null;\n  var defaultBlock = 'latest';\n  Object.defineProperty(this, 'defaultAccount', {\n    get: function get() {\n      return defaultAccount;\n    },\n    set: function set(val) {\n      if (val) {\n        defaultAccount = utils.toChecksumAddress(formatters.inputAddressFormatter(val));\n      } // also set on the Contract object\n\n\n      _this.Contract.defaultAccount = defaultAccount;\n      _this.personal.defaultAccount = defaultAccount; // update defaultBlock\n\n      methods.forEach(function (method) {\n        method.defaultAccount = defaultAccount;\n      });\n      return val;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, 'defaultBlock', {\n    get: function get() {\n      return defaultBlock;\n    },\n    set: function set(val) {\n      if (!utils.isValidBlockNumberCandidate(val)) {\n        throw new Error('Invalid default block number.');\n      }\n\n      defaultBlock = val; // also set on the Contract object\n\n      _this.Contract.defaultBlock = defaultBlock;\n      _this.personal.defaultBlock = defaultBlock; // update defaultBlock\n\n      methods.forEach(function (method) {\n        method.defaultBlock = defaultBlock;\n      });\n      return val;\n    },\n    enumerable: true\n  });\n  this.clearSubscriptions = _this._requestManager.clearSubscriptions;\n  this.decodeTransaction = decodeFromRawTransaction; // add net\n\n  this.net = new Net(this); // add chain detection\n\n  this.net.getNetworkType = getNetworkType.bind(this); // add accounts\n\n  this.accounts = new Accounts(this); // add personal\n\n  this.personal = new Personal(this);\n  this.personal.defaultAccount = this.defaultAccount; // create a proxy Contract type for this instance, as a Contract's provider\n  // is stored as a class member rather than an instance variable. If we do\n  // not create this proxy type, changing the provider in one instance of\n  // caver-klay would subsequently change the provider for _all_ contract\n  // instances!\n\n  var self = this;\n\n  var Contract = function Contract() {\n    BaseContract.apply(this, arguments); // when Klay.setProvider is called, call packageInit\n    // on all contract instances instantiated via this Klay\n    // instances. This will update the currentProvider for\n    // the contract instances\n\n    var _this = this; // eslint-disable-line no-shadow\n\n\n    var setProvider = self.setProvider; // eslint-disable-line no-shadow\n\n    self.setProvider = function () {\n      setProvider.apply(self, arguments);\n      core.packageInit(_this, [self]);\n    };\n  };\n\n  Contract.setProvider = function () {\n    BaseContract.setProvider.apply(this, arguments);\n  }; // make our proxy Contract inherit from caver-contract so that it has all\n  // the right functionality and so that instanceof and friends work properly\n\n\n  Contract.prototype = Object.create(BaseContract.prototype);\n  Contract.prototype.constructor = Contract; // add contract\n\n  this.Contract = Contract;\n  this.Contract.defaultAccount = this.defaultAccount;\n  this.Contract.defaultBlock = this.defaultBlock;\n  this.Contract._requestManager = this._requestManager;\n  this.Contract._klayAccounts = this.accounts;\n  this.Contract.currentProvider = this._requestManager.provider;\n  this.KIP7 = KIP7;\n  this.KIP7.defaultAccount = this.defaultAccount;\n  this.KIP7.defaultBlock = this.defaultBlock;\n  this.KIP7._requestManager = this._requestManager;\n  this.KIP7._klayAccounts = this.accounts;\n  this.KIP7.currentProvider = this._requestManager.provider;\n  this.KIP17 = KIP17;\n  this.KIP17.defaultAccount = this.defaultAccount;\n  this.KIP17.defaultBlock = this.defaultBlock;\n  this.KIP17._requestManager = this._requestManager;\n  this.KIP17._klayAccounts = this.accounts;\n  this.KIP17.currentProvider = this._requestManager.provider; // add IBAN\n\n  this.Iban = utils.Iban; // add ABI\n\n  this.abi = abi;\n  var methods = [].concat(_toConsumableArray(rpcCalls.map(function (item) {\n    return new Method(item);\n  })), [// subscriptions\n  new Subscriptions({\n    name: 'subscribe',\n    type: 'klay',\n    subscriptions: {\n      newBlockHeaders: {\n        // TODO rename on RPC side?\n        subscriptionName: 'newHeads',\n        // replace subscription with this name\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      },\n      pendingTransactions: {\n        subscriptionName: 'newPendingTransactions',\n        // replace subscription with this name\n        params: 0\n      },\n      logs: {\n        params: 1,\n        inputFormatter: [formatters.inputLogFormatter],\n        outputFormatter: formatters.outputLogFormatter,\n        // DUBLICATE, also in caver-contract\n        subscriptionHandler: function subscriptionHandler(output) {\n          this.emit('data', output);\n\n          if (_.isFunction(this.callback)) {\n            this.callback(null, output, this);\n          }\n        }\n      },\n      syncing: {\n        params: 0,\n        outputFormatter: formatters.outputSyncingFormatter,\n        subscriptionHandler: function subscriptionHandler(output) {\n          var _this = this;\n          /* eslint-disable-line no-shadow */\n          // fire TRUE at start\n\n\n          if (this._isSyncing !== true) {\n            this._isSyncing = true;\n            this.emit('changed', _this._isSyncing);\n\n            if (_.isFunction(this.callback)) {\n              this.callback(null, _this._isSyncing, this);\n            }\n\n            setTimeout(function () {\n              _this.emit('data', output);\n\n              if (_.isFunction(_this.callback)) {\n                _this.callback(null, output, _this);\n              }\n            }, 0); // fire sync status\n          } else {\n            this.emit('data', output);\n\n            if (_.isFunction(_this.callback)) {\n              this.callback(null, output, this);\n            } // wait for some time before fireing the FALSE\n\n\n            clearTimeout(this._isSyncingTimeout);\n            this._isSyncingTimeout = setTimeout(function () {\n              if (output.currentBlock > output.highestBlock - 200) {\n                _this._isSyncing = false;\n\n                _this.emit('changed', _this._isSyncing);\n\n                if (_.isFunction(_this.callback)) {\n                  _this.callback(null, _this._isSyncing, _this);\n                }\n              }\n            }, 500);\n          }\n        }\n      }\n    }\n  })]);\n  methods.forEach(function (method) {\n    method.attachToObject(_this); // second param is the klay.accounts module (necessary for signing transactions locally)\n\n    method.setRequestManager(_this._requestManager, _this.accounts);\n    method.defaultBlock = _this.defaultBlock;\n    method.defaultAccount = _this.defaultAccount;\n  });\n};\n\nmodule.exports = Klay;","map":null,"metadata":{},"sourceType":"script"}