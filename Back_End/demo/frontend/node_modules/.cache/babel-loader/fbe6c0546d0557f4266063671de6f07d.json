{"ast":null,"code":"var _createForOfIteratorHelper = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nvar _ = require('lodash');\n\nvar AbstractKeyring = require('./abstractKeyring');\n\nvar utils = require('../../../caver-utils');\n\nvar PrivateKey = require('./privateKey');\n\nvar _require = require('./keyringHelper'),\n    KEY_ROLE = _require.KEY_ROLE,\n    MAXIMUM_KEY_NUM = _require.MAXIMUM_KEY_NUM,\n    isMultipleKeysFormat = _require.isMultipleKeysFormat,\n    isRoleBasedKeysFormat = _require.isRoleBasedKeysFormat;\n\nvar Account = require('../../../caver-account');\n\nvar _require2 = require('../../../caver-account/src/accountKey/accountKeyHelper'),\n    fillWeightedMultiSigOptionsForRoleBased = _require2.fillWeightedMultiSigOptionsForRoleBased;\n\nvar _require3 = require('./keyringHelper'),\n    validateForSigning = _require3.validateForSigning,\n    validateIndexWithKeys = _require3.validateIndexWithKeys,\n    encryptKey = _require3.encryptKey,\n    formatEncrypted = _require3.formatEncrypted;\n/**\n * representing a Keyring which includes `address` and `private keys` by roles.\n * @class\n */\n\n\nvar RoleBasedKeyring = /*#__PURE__*/function (_AbstractKeyring) {\n  \"use strict\";\n\n  _inherits(RoleBasedKeyring, _AbstractKeyring);\n\n  var _super = _createSuper(RoleBasedKeyring);\n\n  /**\n   * creates a RoleBasedKeyring.\n   * @param {string} address - The address of keyring.\n   * @param {Array.<Array<string>>|Array.<Array<PrivateKey>>} keys - The keys to use in RoleBasedKeyring.\n   */\n  function RoleBasedKeyring(address, keys) {\n    var _this;\n\n    _classCallCheck(this, RoleBasedKeyring);\n\n    _this = _super.call(this, address);\n    _this.keys = keys;\n    return _this;\n  }\n  /**\n   * @type {Array.<Array.<PrivateKey>>}\n   */\n\n\n  _createClass(RoleBasedKeyring, [{\n    key: \"getPublicKey\",\n\n    /**\n     * returns public key strings in format of role-based.\n     *\n     * @return {Array.<Array<string>>}\n     */\n    value: function getPublicKey() {\n      var publicKeys = generateKeysFormat();\n\n      for (var i = 0; i < KEY_ROLE.roleLast; i++) {\n        var _iterator = _createForOfIteratorHelper(this._keys[i]),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var k = _step.value;\n            publicKeys[i].push(k.getPublicKey());\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return publicKeys;\n    }\n    /**\n     * returns a copied roleBasedKeyring instance\n     *\n     * @return {RoleBasedKeyring}\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new RoleBasedKeyring(this.address, this.keys);\n    }\n    /**\n     * signs with transactionHash with key and returns signature.\n     *\n     * @param {string} transactionHash The hash of transaction.\n     * @param {string|number} chainId The chainId specific to the network.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n     * @return {Array.<string>|Array.<Array.<string>>}\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(transactionHash, chainId, role, index) {\n      validateForSigning(transactionHash, chainId);\n      var keys = this.getKeyByRole(role);\n\n      if (index !== undefined) {\n        validateIndexWithKeys(index, keys.length);\n        return keys[index].sign(transactionHash, chainId);\n      }\n\n      var signatures = [];\n\n      var _iterator2 = _createForOfIteratorHelper(keys),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var k = _step2.value;\n          signatures.push(k.sign(transactionHash, chainId));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return signatures;\n    }\n    /**\n     * signs with hashed message and returns result object that includes `signatures`, `message` and `messageHash`\n     *\n     * @param {string} message The message string to sign.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used.\n     * @return {object}\n     */\n\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(message, role, index) {\n      if (role === undefined) throw new Error(\"role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.\");\n      var messageHash = utils.hashMessage(message);\n      var keys = this.getKeyByRole(role);\n      var signatures = [];\n\n      if (index !== undefined) {\n        validateIndexWithKeys(index, keys.length);\n        signatures.push(keys[index].signMessage(messageHash));\n      } else {\n        var _iterator3 = _createForOfIteratorHelper(keys),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var k = _step3.value;\n            signatures.push(k.signMessage(messageHash));\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return {\n        messageHash: messageHash,\n        signatures: signatures,\n        message: message\n      };\n    }\n    /**\n     * returns keys by role.If the key of the role passed as parameter is empty, the default key is returned.\n     *\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @return {Array.<PrivateKey>}\n     */\n\n  }, {\n    key: \"getKeyByRole\",\n    value: function getKeyByRole(role) {\n      if (role === undefined) throw new Error(\"role should be defined.\");\n      if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(\"Invalid role number: \".concat(role));\n      var key = this._keys[role];\n\n      if (key.length === 0 && role > KEY_ROLE.roleTransactionKey) {\n        if (this._keys[KEY_ROLE.roleTransactionKey].length === 0) {\n          throw new Error(\"The key with \".concat(KEY_ROLE[role], \" role does not exist. The \").concat(KEY_ROLE[0], \" for the default role is also empty.\"));\n        }\n\n        key = this._keys[KEY_ROLE.roleTransactionKey];\n      }\n\n      return key;\n    }\n    /**\n     * returns an instance of Account.\n     *\n     * @param {WeightedMultiSigOptions|Array.<WeightedMultiSigOptions>} [options] The options that includes 'threshold' and 'weight'. This is only necessary when keyring use multiple private keys.\n     * @return {Account}\n     */\n\n  }, {\n    key: \"toAccount\",\n    value: function toAccount(options) {\n      if (options !== undefined && !_.isArray(options)) throw new Error(\"options for an account should define threshold and weight for each roles in an array format\");\n      var lengths = [];\n\n      var _iterator4 = _createForOfIteratorHelper(this.keys),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var k = _step4.value;\n          lengths.push(k.length);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      options = fillWeightedMultiSigOptionsForRoleBased(lengths, options);\n      var publicKeysByRole = this.getPublicKey();\n      return Account.createWithAccountKeyRoleBased(this.address, publicKeysByRole, options);\n    }\n    /**\n     * encrypts a keyring and returns a keystore v4 object.\n     *\n     * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} options The options to use when encrypt a keyring. Also address can be defined specifically in options object.\n     * @return {object}\n     */\n\n    /**\n     * options can include below\n     * {\n     *   salt: ...,\n     *   iv: ...,\n     *   kdf: ...,\n     *   dklen: ...,\n     *   c: ...,\n     *   n: ...,\n     *   r: ...,\n     *   p: ...,\n     *   cipher: ...,\n     *   uuid: ...,\n     *   cipher: ...,\n     * }\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(password) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var keyring = [];\n\n      for (var i = KEY_ROLE.roleTransactionKey; i < KEY_ROLE.roleLast; i++) {\n        var roledKey = this._keys[i];\n        keyring.push(encryptKey(roledKey, password, options));\n      }\n\n      return formatEncrypted(4, this._address, keyring, options);\n    }\n  }, {\n    key: \"keys\",\n    get: function get() {\n      return this._keys;\n    },\n    set: function set(keyInput) {\n      if (keyInput === null) {\n        this._key = null;\n        return;\n      }\n\n      this._keys = formattingForKeyInKeyring(keyInput);\n    }\n    /**\n     * @type {Array.<PrivateKey>}\n     */\n\n  }, {\n    key: \"roleTransactionKey\",\n    get: function get() {\n      return this.getKeyByRole(KEY_ROLE.roleTransactionKey);\n    }\n    /**\n     * @type {Array.<PrivateKey>}\n     */\n\n  }, {\n    key: \"roleAccountUpdateKey\",\n    get: function get() {\n      return this.getKeyByRole(KEY_ROLE.roleAccountUpdateKey);\n    }\n    /**\n     * @type {Array.<PrivateKey>}\n     */\n\n  }, {\n    key: \"roleFeePayerKey\",\n    get: function get() {\n      return this.getKeyByRole(KEY_ROLE.roleFeePayerKey);\n    }\n  }]);\n\n  return RoleBasedKeyring;\n}(AbstractKeyring);\n\nmodule.exports = RoleBasedKeyring;\n/**\n * Format the key parameters passed by the user to create a keyring instance into a two-dimensional array containing PrivateKey instances.\n *\n * The cases of the parameter that the user passes to the function is as follows, and this function formats it as a two-dimensional array.\n * PrivateKey instance: PrivateKey{}\n * single private key string: `0x{private key}`\n * multiple private key strings: [`0x{private key}`, `0x{private key}`]\n * multiple PrivateKey instances: [PrivateKey{}, PrivateKey{}]\n * role-based private key strings: [[`0x{private key}`], [`0x{private key}`, `0x{private key}`], [`0x{private key}`]]\n * role-based PrivateKey instances: [[PrivateKey{}], [PrivateKey{}, PrivateKey{}], [PrivateKey{}]]\n *\n * @param {string|PrivateKey|Array.<string|PrivateKey>|Array.<Array.<string|PrivateKey>>} keyInput The input parameter for key variable in Keyring.\n * @return {Array.<Array.<PrivateKey>>}\n */\n\nfunction formattingForKeyInKeyring(keyInput) {\n  if (keyInput === null) {\n    return keyInput;\n  }\n\n  if (keyInput instanceof PrivateKey || _.isString(keyInput)) {\n    keyInput = [[keyInput], [], []];\n  } else if (isMultipleKeysFormat(keyInput)) {\n    // [`0x{private key}`, `0x{private key}`, `0x{private key}`]\n    keyInput = [keyInput, [], []];\n  } else if (!isRoleBasedKeysFormat(keyInput)) {\n    throw new Error(\"Invalid format for key variable in keyring\");\n  }\n\n  var keys = generateKeysFormat();\n\n  for (var i = 0; i < KEY_ROLE.roleLast; i++) {\n    fillRoleKey(keys, i, keyInput[i]);\n  }\n\n  return keys;\n}\n\nfunction generateKeysFormat() {\n  return Array(KEY_ROLE.roleLast).fill(null).map(function () {\n    return [];\n  });\n}\n\nfunction fillRoleKey(keys, role, keyToAdd) {\n  if (keyToAdd === undefined) return;\n  keyToAdd = Array.isArray(keyToAdd) ? keyToAdd : [keyToAdd];\n  if (keyToAdd.length > MAXIMUM_KEY_NUM) throw new Error(\"The maximum number of private keys that can be used in keyring is \".concat(MAXIMUM_KEY_NUM, \".\"));\n  if (role >= KEY_ROLE.roleLast) throw new Error(\"Unsupported role number. The role number should be less than \".concat(KEY_ROLE.roleLast, \". Please use 'caver.wallet.keyring.role'\"));\n\n  var _iterator5 = _createForOfIteratorHelper(keyToAdd),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var keyString = _step5.value;\n      var key = keyString instanceof PrivateKey ? keyString : new PrivateKey(keyString);\n      keys[role].push(key);\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n}","map":{"version":3,"sources":["/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/caver-js/packages/caver-wallet/src/keyring/roleBasedKeyring.js"],"names":["_","require","AbstractKeyring","utils","PrivateKey","KEY_ROLE","MAXIMUM_KEY_NUM","isMultipleKeysFormat","isRoleBasedKeysFormat","Account","fillWeightedMultiSigOptionsForRoleBased","validateForSigning","validateIndexWithKeys","encryptKey","formatEncrypted","RoleBasedKeyring","address","keys","publicKeys","generateKeysFormat","i","roleLast","_keys","k","push","getPublicKey","transactionHash","chainId","role","index","getKeyByRole","undefined","length","sign","signatures","message","Error","messageHash","hashMessage","signMessage","key","roleTransactionKey","options","isArray","lengths","publicKeysByRole","createWithAccountKeyRoleBased","password","keyring","roledKey","_address","keyInput","_key","formattingForKeyInKeyring","roleAccountUpdateKey","roleFeePayerKey","module","exports","isString","fillRoleKey","Array","fill","map","keyToAdd","keyString"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,IAAMC,eAAe,GAAGD,OAAO,CAAC,mBAAD,CAA/B;;AAEA,IAAME,KAAK,GAAGF,OAAO,CAAC,sBAAD,CAArB;;AACA,IAAMG,UAAU,GAAGH,OAAO,CAAC,cAAD,CAA1B;;eACmFA,OAAO,CAAC,iBAAD,C;IAAlFI,Q,YAAAA,Q;IAAUC,e,YAAAA,e;IAAiBC,oB,YAAAA,oB;IAAsBC,qB,YAAAA,qB;;AACzD,IAAMC,OAAO,GAAGR,OAAO,CAAC,wBAAD,CAAvB;;gBACoDA,OAAO,CAAC,wDAAD,C;IAAnDS,uC,aAAAA,uC;;gBAC2ET,OAAO,CAAC,iBAAD,C;IAAlFU,kB,aAAAA,kB;IAAoBC,qB,aAAAA,qB;IAAuBC,U,aAAAA,U;IAAYC,e,aAAAA,e;AAE/D;AACA;AACA;AACA;;;IACMC,gB;;;;;;;AACF;AACJ;AACA;AACA;AACA;AACI,4BAAYC,OAAZ,EAAqBC,IAArB,EAA2B;AAAA;;AAAA;;AACvB,8BAAMD,OAAN;AACA,UAAKC,IAAL,GAAYA,IAAZ;AAFuB;AAG1B;AAED;AACJ;AACA;;;;;;AAmCI;AACJ;AACA;AACA;AACA;mCACmB;AACX,UAAMC,UAAU,GAAGC,kBAAkB,EAArC;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGf,QAAQ,CAACgB,QAA7B,EAAuCD,CAAC,EAAxC,EAA4C;AAAA,mDACxB,KAAKE,KAAL,CAAWF,CAAX,CADwB;AAAA;;AAAA;AACxC,8DAA+B;AAAA,gBAApBG,CAAoB;AAC3BL,YAAAA,UAAU,CAACE,CAAD,CAAV,CAAcI,IAAd,CAAmBD,CAAC,CAACE,YAAF,EAAnB;AACH;AAHuC;AAAA;AAAA;AAAA;AAAA;AAI3C;;AACD,aAAOP,UAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;;2BACW;AACH,aAAO,IAAIH,gBAAJ,CAAqB,KAAKC,OAA1B,EAAmC,KAAKC,IAAxC,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;yBACSS,e,EAAiBC,O,EAASC,I,EAAMC,K,EAAO;AACxClB,MAAAA,kBAAkB,CAACe,eAAD,EAAkBC,OAAlB,CAAlB;AAEA,UAAMV,IAAI,GAAG,KAAKa,YAAL,CAAkBF,IAAlB,CAAb;;AAEA,UAAIC,KAAK,KAAKE,SAAd,EAAyB;AACrBnB,QAAAA,qBAAqB,CAACiB,KAAD,EAAQZ,IAAI,CAACe,MAAb,CAArB;AACA,eAAOf,IAAI,CAACY,KAAD,CAAJ,CAAYI,IAAZ,CAAiBP,eAAjB,EAAkCC,OAAlC,CAAP;AACH;;AAED,UAAMO,UAAU,GAAG,EAAnB;;AAVwC,kDAWxBjB,IAXwB;AAAA;;AAAA;AAWxC,+DAAsB;AAAA,cAAXM,CAAW;AAClBW,UAAAA,UAAU,CAACV,IAAX,CAAgBD,CAAC,CAACU,IAAF,CAAOP,eAAP,EAAwBC,OAAxB,CAAhB;AACH;AAbuC;AAAA;AAAA;AAAA;AAAA;;AAcxC,aAAOO,UAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;gCACgBC,O,EAASP,I,EAAMC,K,EAAO;AAC9B,UAAID,IAAI,KAAKG,SAAb,EAAwB,MAAM,IAAIK,KAAJ,mFAAN;AACxB,UAAMC,WAAW,GAAGlC,KAAK,CAACmC,WAAN,CAAkBH,OAAlB,CAApB;AAEA,UAAMlB,IAAI,GAAG,KAAKa,YAAL,CAAkBF,IAAlB,CAAb;AAEA,UAAMM,UAAU,GAAG,EAAnB;;AACA,UAAIL,KAAK,KAAKE,SAAd,EAAyB;AACrBnB,QAAAA,qBAAqB,CAACiB,KAAD,EAAQZ,IAAI,CAACe,MAAb,CAArB;AACAE,QAAAA,UAAU,CAACV,IAAX,CAAgBP,IAAI,CAACY,KAAD,CAAJ,CAAYU,WAAZ,CAAwBF,WAAxB,CAAhB;AACH,OAHD,MAGO;AAAA,oDACapB,IADb;AAAA;;AAAA;AACH,iEAAsB;AAAA,gBAAXM,CAAW;AAClBW,YAAAA,UAAU,CAACV,IAAX,CAAgBD,CAAC,CAACgB,WAAF,CAAcF,WAAd,CAAhB;AACH;AAHE;AAAA;AAAA;AAAA;AAAA;AAIN;;AACD,aAAO;AACHA,QAAAA,WAAW,EAAXA,WADG;AAEHH,QAAAA,UAAU,EAAVA,UAFG;AAGHC,QAAAA,OAAO,EAAPA;AAHG,OAAP;AAKH;AAED;AACJ;AACA;AACA;AACA;AACA;;;;iCACiBP,I,EAAM;AACf,UAAIA,IAAI,KAAKG,SAAb,EAAwB,MAAM,IAAIK,KAAJ,2BAAN;AACxB,UAAIR,IAAI,IAAIvB,QAAQ,CAACgB,QAAjB,IAA6BO,IAAI,GAAG,CAAxC,EAA2C,MAAM,IAAIQ,KAAJ,gCAAkCR,IAAlC,EAAN;AAC3C,UAAIY,GAAG,GAAG,KAAKlB,KAAL,CAAWM,IAAX,CAAV;;AACA,UAAIY,GAAG,CAACR,MAAJ,KAAe,CAAf,IAAoBJ,IAAI,GAAGvB,QAAQ,CAACoC,kBAAxC,EAA4D;AACxD,YAAI,KAAKnB,KAAL,CAAWjB,QAAQ,CAACoC,kBAApB,EAAwCT,MAAxC,KAAmD,CAAvD,EAA0D;AACtD,gBAAM,IAAII,KAAJ,wBACc/B,QAAQ,CAACuB,IAAD,CADtB,uCACyDvB,QAAQ,CAAC,CAAD,CADjE,0CAAN;AAGH;;AAEDmC,QAAAA,GAAG,GAAG,KAAKlB,KAAL,CAAWjB,QAAQ,CAACoC,kBAApB,CAAN;AACH;;AACD,aAAOD,GAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;;8BACcE,O,EAAS;AACf,UAAIA,OAAO,KAAKX,SAAZ,IAAyB,CAAC/B,CAAC,CAAC2C,OAAF,CAAUD,OAAV,CAA9B,EACI,MAAM,IAAIN,KAAJ,+FAAN;AAEJ,UAAMQ,OAAO,GAAG,EAAhB;;AAJe,kDAKC,KAAK3B,IALN;AAAA;;AAAA;AAKf;AAAA,cAAWM,CAAX;AAA2BqB,UAAAA,OAAO,CAACpB,IAAR,CAAaD,CAAC,CAACS,MAAf;AAA3B;AALe;AAAA;AAAA;AAAA;AAAA;;AAMfU,MAAAA,OAAO,GAAGhC,uCAAuC,CAACkC,OAAD,EAAUF,OAAV,CAAjD;AAEA,UAAMG,gBAAgB,GAAG,KAAKpB,YAAL,EAAzB;AACA,aAAOhB,OAAO,CAACqC,6BAAR,CAAsC,KAAK9B,OAA3C,EAAoD6B,gBAApD,EAAsEH,OAAtE,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;4BACYK,Q,EAAwB;AAAA,UAAdL,OAAc,uEAAJ,EAAI;AAC5B,UAAMM,OAAO,GAAG,EAAhB;;AAEA,WAAK,IAAI5B,CAAC,GAAGf,QAAQ,CAACoC,kBAAtB,EAA0CrB,CAAC,GAAGf,QAAQ,CAACgB,QAAvD,EAAiED,CAAC,EAAlE,EAAsE;AAClE,YAAM6B,QAAQ,GAAG,KAAK3B,KAAL,CAAWF,CAAX,CAAjB;AACA4B,QAAAA,OAAO,CAACxB,IAAR,CAAaX,UAAU,CAACoC,QAAD,EAAWF,QAAX,EAAqBL,OAArB,CAAvB;AACH;;AAED,aAAO5B,eAAe,CAAC,CAAD,EAAI,KAAKoC,QAAT,EAAmBF,OAAnB,EAA4BN,OAA5B,CAAtB;AACH;;;wBA1LU;AACP,aAAO,KAAKpB,KAAZ;AACH,K;sBAEQ6B,Q,EAAU;AACf,UAAIA,QAAQ,KAAK,IAAjB,EAAuB;AACnB,aAAKC,IAAL,GAAY,IAAZ;AACA;AACH;;AAED,WAAK9B,KAAL,GAAa+B,yBAAyB,CAACF,QAAD,CAAtC;AACH;AAED;AACJ;AACA;;;;wBAC6B;AACrB,aAAO,KAAKrB,YAAL,CAAkBzB,QAAQ,CAACoC,kBAA3B,CAAP;AACH;AAED;AACJ;AACA;;;;wBAC+B;AACvB,aAAO,KAAKX,YAAL,CAAkBzB,QAAQ,CAACiD,oBAA3B,CAAP;AACH;AAED;AACJ;AACA;;;;wBAC0B;AAClB,aAAO,KAAKxB,YAAL,CAAkBzB,QAAQ,CAACkD,eAA3B,CAAP;AACH;;;;EA9C0BrD,e;;AA2M/BsD,MAAM,CAACC,OAAP,GAAiB1C,gBAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASsC,yBAAT,CAAmCF,QAAnC,EAA6C;AACzC,MAAIA,QAAQ,KAAK,IAAjB,EAAuB;AACnB,WAAOA,QAAP;AACH;;AAED,MAAIA,QAAQ,YAAY/C,UAApB,IAAkCJ,CAAC,CAAC0D,QAAF,CAAWP,QAAX,CAAtC,EAA4D;AACxDA,IAAAA,QAAQ,GAAG,CAAC,CAACA,QAAD,CAAD,EAAa,EAAb,EAAiB,EAAjB,CAAX;AACH,GAFD,MAEO,IAAI5C,oBAAoB,CAAC4C,QAAD,CAAxB,EAAoC;AACvC;AACAA,IAAAA,QAAQ,GAAG,CAACA,QAAD,EAAW,EAAX,EAAe,EAAf,CAAX;AACH,GAHM,MAGA,IAAI,CAAC3C,qBAAqB,CAAC2C,QAAD,CAA1B,EAAsC;AACzC,UAAM,IAAIf,KAAJ,8CAAN;AACH;;AAED,MAAMnB,IAAI,GAAGE,kBAAkB,EAA/B;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGf,QAAQ,CAACgB,QAA7B,EAAuCD,CAAC,EAAxC,EAA4C;AACxCuC,IAAAA,WAAW,CAAC1C,IAAD,EAAOG,CAAP,EAAU+B,QAAQ,CAAC/B,CAAD,CAAlB,CAAX;AACH;;AAED,SAAOH,IAAP;AACH;;AAED,SAASE,kBAAT,GAA8B;AAC1B,SAAOyC,KAAK,CAACvD,QAAQ,CAACgB,QAAV,CAAL,CACFwC,IADE,CACG,IADH,EAEFC,GAFE,CAEE;AAAA,WAAM,EAAN;AAAA,GAFF,CAAP;AAGH;;AAED,SAASH,WAAT,CAAqB1C,IAArB,EAA2BW,IAA3B,EAAiCmC,QAAjC,EAA2C;AACvC,MAAIA,QAAQ,KAAKhC,SAAjB,EAA4B;AAC5BgC,EAAAA,QAAQ,GAAGH,KAAK,CAACjB,OAAN,CAAcoB,QAAd,IAA0BA,QAA1B,GAAqC,CAACA,QAAD,CAAhD;AAEA,MAAIA,QAAQ,CAAC/B,MAAT,GAAkB1B,eAAtB,EACI,MAAM,IAAI8B,KAAJ,6EAA+E9B,eAA/E,OAAN;AACJ,MAAIsB,IAAI,IAAIvB,QAAQ,CAACgB,QAArB,EACI,MAAM,IAAIe,KAAJ,wEAC8D/B,QAAQ,CAACgB,QADvE,8CAAN;;AAPmC,8CAWf0C,QAXe;AAAA;;AAAA;AAWvC,2DAAkC;AAAA,UAAvBC,SAAuB;AAC9B,UAAMxB,GAAG,GAAGwB,SAAS,YAAY5D,UAArB,GAAkC4D,SAAlC,GAA8C,IAAI5D,UAAJ,CAAe4D,SAAf,CAA1D;AACA/C,MAAAA,IAAI,CAACW,IAAD,CAAJ,CAAWJ,IAAX,CAAgBgB,GAAhB;AACH;AAdsC;AAAA;AAAA;AAAA;AAAA;AAe1C","sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst _ = require('lodash')\nconst AbstractKeyring = require('./abstractKeyring')\n\nconst utils = require('../../../caver-utils')\nconst PrivateKey = require('./privateKey')\nconst { KEY_ROLE, MAXIMUM_KEY_NUM, isMultipleKeysFormat, isRoleBasedKeysFormat } = require('./keyringHelper')\nconst Account = require('../../../caver-account')\nconst { fillWeightedMultiSigOptionsForRoleBased } = require('../../../caver-account/src/accountKey/accountKeyHelper')\nconst { validateForSigning, validateIndexWithKeys, encryptKey, formatEncrypted } = require('./keyringHelper')\n\n/**\n * representing a Keyring which includes `address` and `private keys` by roles.\n * @class\n */\nclass RoleBasedKeyring extends AbstractKeyring {\n    /**\n     * creates a RoleBasedKeyring.\n     * @param {string} address - The address of keyring.\n     * @param {Array.<Array<string>>|Array.<Array<PrivateKey>>} keys - The keys to use in RoleBasedKeyring.\n     */\n    constructor(address, keys) {\n        super(address)\n        this.keys = keys\n    }\n\n    /**\n     * @type {Array.<Array.<PrivateKey>>}\n     */\n    get keys() {\n        return this._keys\n    }\n\n    set keys(keyInput) {\n        if (keyInput === null) {\n            this._key = null\n            return\n        }\n\n        this._keys = formattingForKeyInKeyring(keyInput)\n    }\n\n    /**\n     * @type {Array.<PrivateKey>}\n     */\n    get roleTransactionKey() {\n        return this.getKeyByRole(KEY_ROLE.roleTransactionKey)\n    }\n\n    /**\n     * @type {Array.<PrivateKey>}\n     */\n    get roleAccountUpdateKey() {\n        return this.getKeyByRole(KEY_ROLE.roleAccountUpdateKey)\n    }\n\n    /**\n     * @type {Array.<PrivateKey>}\n     */\n    get roleFeePayerKey() {\n        return this.getKeyByRole(KEY_ROLE.roleFeePayerKey)\n    }\n\n    /**\n     * returns public key strings in format of role-based.\n     *\n     * @return {Array.<Array<string>>}\n     */\n    getPublicKey() {\n        const publicKeys = generateKeysFormat()\n        for (let i = 0; i < KEY_ROLE.roleLast; i++) {\n            for (const k of this._keys[i]) {\n                publicKeys[i].push(k.getPublicKey())\n            }\n        }\n        return publicKeys\n    }\n\n    /**\n     * returns a copied roleBasedKeyring instance\n     *\n     * @return {RoleBasedKeyring}\n     */\n    copy() {\n        return new RoleBasedKeyring(this.address, this.keys)\n    }\n\n    /**\n     * signs with transactionHash with key and returns signature.\n     *\n     * @param {string} transactionHash The hash of transaction.\n     * @param {string|number} chainId The chainId specific to the network.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n     * @return {Array.<string>|Array.<Array.<string>>}\n     */\n    sign(transactionHash, chainId, role, index) {\n        validateForSigning(transactionHash, chainId)\n\n        const keys = this.getKeyByRole(role)\n\n        if (index !== undefined) {\n            validateIndexWithKeys(index, keys.length)\n            return keys[index].sign(transactionHash, chainId)\n        }\n\n        const signatures = []\n        for (const k of keys) {\n            signatures.push(k.sign(transactionHash, chainId))\n        }\n        return signatures\n    }\n\n    /**\n     * signs with hashed message and returns result object that includes `signatures`, `message` and `messageHash`\n     *\n     * @param {string} message The message string to sign.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used.\n     * @return {object}\n     */\n    signMessage(message, role, index) {\n        if (role === undefined) throw new Error(`role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.`)\n        const messageHash = utils.hashMessage(message)\n\n        const keys = this.getKeyByRole(role)\n\n        const signatures = []\n        if (index !== undefined) {\n            validateIndexWithKeys(index, keys.length)\n            signatures.push(keys[index].signMessage(messageHash))\n        } else {\n            for (const k of keys) {\n                signatures.push(k.signMessage(messageHash))\n            }\n        }\n        return {\n            messageHash,\n            signatures,\n            message,\n        }\n    }\n\n    /**\n     * returns keys by role.If the key of the role passed as parameter is empty, the default key is returned.\n     *\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @return {Array.<PrivateKey>}\n     */\n    getKeyByRole(role) {\n        if (role === undefined) throw new Error(`role should be defined.`)\n        if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(`Invalid role number: ${role}`)\n        let key = this._keys[role]\n        if (key.length === 0 && role > KEY_ROLE.roleTransactionKey) {\n            if (this._keys[KEY_ROLE.roleTransactionKey].length === 0) {\n                throw new Error(\n                    `The key with ${KEY_ROLE[role]} role does not exist. The ${KEY_ROLE[0]} for the default role is also empty.`\n                )\n            }\n\n            key = this._keys[KEY_ROLE.roleTransactionKey]\n        }\n        return key\n    }\n\n    /**\n     * returns an instance of Account.\n     *\n     * @param {WeightedMultiSigOptions|Array.<WeightedMultiSigOptions>} [options] The options that includes 'threshold' and 'weight'. This is only necessary when keyring use multiple private keys.\n     * @return {Account}\n     */\n    toAccount(options) {\n        if (options !== undefined && !_.isArray(options))\n            throw new Error(`options for an account should define threshold and weight for each roles in an array format`)\n\n        const lengths = []\n        for (const k of this.keys) lengths.push(k.length)\n        options = fillWeightedMultiSigOptionsForRoleBased(lengths, options)\n\n        const publicKeysByRole = this.getPublicKey()\n        return Account.createWithAccountKeyRoleBased(this.address, publicKeysByRole, options)\n    }\n\n    /**\n     * encrypts a keyring and returns a keystore v4 object.\n     *\n     * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} options The options to use when encrypt a keyring. Also address can be defined specifically in options object.\n     * @return {object}\n     */\n    /**\n     * options can include below\n     * {\n     *   salt: ...,\n     *   iv: ...,\n     *   kdf: ...,\n     *   dklen: ...,\n     *   c: ...,\n     *   n: ...,\n     *   r: ...,\n     *   p: ...,\n     *   cipher: ...,\n     *   uuid: ...,\n     *   cipher: ...,\n     * }\n     */\n    encrypt(password, options = {}) {\n        const keyring = []\n\n        for (let i = KEY_ROLE.roleTransactionKey; i < KEY_ROLE.roleLast; i++) {\n            const roledKey = this._keys[i]\n            keyring.push(encryptKey(roledKey, password, options))\n        }\n\n        return formatEncrypted(4, this._address, keyring, options)\n    }\n}\n\nmodule.exports = RoleBasedKeyring\n\n/**\n * Format the key parameters passed by the user to create a keyring instance into a two-dimensional array containing PrivateKey instances.\n *\n * The cases of the parameter that the user passes to the function is as follows, and this function formats it as a two-dimensional array.\n * PrivateKey instance: PrivateKey{}\n * single private key string: `0x{private key}`\n * multiple private key strings: [`0x{private key}`, `0x{private key}`]\n * multiple PrivateKey instances: [PrivateKey{}, PrivateKey{}]\n * role-based private key strings: [[`0x{private key}`], [`0x{private key}`, `0x{private key}`], [`0x{private key}`]]\n * role-based PrivateKey instances: [[PrivateKey{}], [PrivateKey{}, PrivateKey{}], [PrivateKey{}]]\n *\n * @param {string|PrivateKey|Array.<string|PrivateKey>|Array.<Array.<string|PrivateKey>>} keyInput The input parameter for key variable in Keyring.\n * @return {Array.<Array.<PrivateKey>>}\n */\nfunction formattingForKeyInKeyring(keyInput) {\n    if (keyInput === null) {\n        return keyInput\n    }\n\n    if (keyInput instanceof PrivateKey || _.isString(keyInput)) {\n        keyInput = [[keyInput], [], []]\n    } else if (isMultipleKeysFormat(keyInput)) {\n        // [`0x{private key}`, `0x{private key}`, `0x{private key}`]\n        keyInput = [keyInput, [], []]\n    } else if (!isRoleBasedKeysFormat(keyInput)) {\n        throw new Error(`Invalid format for key variable in keyring`)\n    }\n\n    const keys = generateKeysFormat()\n    for (let i = 0; i < KEY_ROLE.roleLast; i++) {\n        fillRoleKey(keys, i, keyInput[i])\n    }\n\n    return keys\n}\n\nfunction generateKeysFormat() {\n    return Array(KEY_ROLE.roleLast)\n        .fill(null)\n        .map(() => [])\n}\n\nfunction fillRoleKey(keys, role, keyToAdd) {\n    if (keyToAdd === undefined) return\n    keyToAdd = Array.isArray(keyToAdd) ? keyToAdd : [keyToAdd]\n\n    if (keyToAdd.length > MAXIMUM_KEY_NUM)\n        throw new Error(`The maximum number of private keys that can be used in keyring is ${MAXIMUM_KEY_NUM}.`)\n    if (role >= KEY_ROLE.roleLast)\n        throw new Error(\n            `Unsupported role number. The role number should be less than ${KEY_ROLE.roleLast}. Please use 'caver.wallet.keyring.role'`\n        )\n\n    for (const keyString of keyToAdd) {\n        const key = keyString instanceof PrivateKey ? keyString : new PrivateKey(keyString)\n        keys[role].push(key)\n    }\n}\n"]},"metadata":{},"sourceType":"script"}