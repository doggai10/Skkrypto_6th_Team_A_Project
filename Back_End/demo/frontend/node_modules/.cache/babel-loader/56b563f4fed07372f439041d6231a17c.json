{"ast":null,"code":"var _classCallCheck = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nvar _ = require('lodash');\n\nvar AbstractKeyring = require('./abstractKeyring');\n\nvar utils = require('../../../caver-utils');\n\nvar PrivateKey = require('./privateKey');\n\nvar _require = require('./keyringHelper'),\n    KEY_ROLE = _require.KEY_ROLE,\n    MAXIMUM_KEY_NUM = _require.MAXIMUM_KEY_NUM,\n    isMultipleKeysFormat = _require.isMultipleKeysFormat,\n    isRoleBasedKeysFormat = _require.isRoleBasedKeysFormat;\n\nvar Account = require('../../../caver-account');\n\nvar _require2 = require('../../../caver-account/src/accountKey/accountKeyHelper'),\n    fillWeightedMultiSigOptionsForRoleBased = _require2.fillWeightedMultiSigOptionsForRoleBased;\n\nvar _require3 = require('./keyringHelper'),\n    validateForSigning = _require3.validateForSigning,\n    validateIndexWithKeys = _require3.validateIndexWithKeys,\n    encryptKey = _require3.encryptKey,\n    formatEncrypted = _require3.formatEncrypted;\n/**\n * representing a Keyring which includes `address` and `private keys` by roles.\n * @class\n */\n\n\nvar RoleBasedKeyring =\n/*#__PURE__*/\nfunction (_AbstractKeyring) {\n  \"use strict\";\n\n  _inherits(RoleBasedKeyring, _AbstractKeyring);\n\n  /**\n   * creates a RoleBasedKeyring.\n   * @param {string} address - The address of keyring.\n   * @param {Array.<Array<string>>|Array.<Array<PrivateKey>>} keys - The keys to use in RoleBasedKeyring.\n   */\n  function RoleBasedKeyring(address, keys) {\n    var _this;\n\n    _classCallCheck(this, RoleBasedKeyring);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RoleBasedKeyring).call(this, address));\n    _this.keys = keys;\n    return _this;\n  }\n  /**\n   * @type {Array.<Array.<PrivateKey>>}\n   */\n\n\n  _createClass(RoleBasedKeyring, [{\n    key: \"getPublicKey\",\n\n    /**\n     * returns public key strings in format of role-based.\n     *\n     * @return {Array.<Array<string>>}\n     */\n    value: function getPublicKey() {\n      var publicKeys = generateKeysFormat();\n\n      for (var i = 0; i < KEY_ROLE.roleLast; i++) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this._keys[i][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var k = _step.value;\n            publicKeys[i].push(k.getPublicKey());\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return publicKeys;\n    }\n    /**\n     * returns a copied roleBasedKeyring instance\n     *\n     * @return {RoleBasedKeyring}\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new RoleBasedKeyring(this.address, this.keys);\n    }\n    /**\n     * signs with transactionHash with key and returns signature.\n     *\n     * @param {string} transactionHash The hash of transaction.\n     * @param {string|number} chainId The chainId specific to the network.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n     * @return {Array.<string>|Array.<Array.<string>>}\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(transactionHash, chainId, role, index) {\n      validateForSigning(transactionHash, chainId);\n      var keys = this.getKeyByRole(role);\n\n      if (index !== undefined) {\n        validateIndexWithKeys(index, keys.length);\n        return keys[index].sign(transactionHash, chainId);\n      }\n\n      var signatures = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var k = _step2.value;\n          signatures.push(k.sign(transactionHash, chainId));\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return signatures;\n    }\n    /**\n     * signs with hashed message and returns result object that includes `signatures`, `message` and `messageHash`\n     *\n     * @param {string} message The message string to sign.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used.\n     * @return {object}\n     */\n\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(message, role, index) {\n      if (role === undefined) throw new Error(\"role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.\");\n      var messageHash = utils.hashMessage(message);\n      var keys = this.getKeyByRole(role);\n      var signatures = [];\n\n      if (index !== undefined) {\n        validateIndexWithKeys(index, keys.length);\n        signatures.push(keys[index].signMessage(messageHash));\n      } else {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var k = _step3.value;\n            signatures.push(k.signMessage(messageHash));\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n\n      return {\n        messageHash: messageHash,\n        signatures: signatures,\n        message: message\n      };\n    }\n    /**\n     * returns keys by role.If the key of the role passed as parameter is empty, the default key is returned.\n     *\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @return {Array.<PrivateKey>}\n     */\n\n  }, {\n    key: \"getKeyByRole\",\n    value: function getKeyByRole(role) {\n      if (role === undefined) throw new Error(\"role should be defined.\");\n      if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(\"Invalid role number: \".concat(role));\n      var key = this._keys[role];\n\n      if (key.length === 0 && role > KEY_ROLE.roleTransactionKey) {\n        if (this._keys[KEY_ROLE.roleTransactionKey].length === 0) {\n          throw new Error(\"The key with \".concat(KEY_ROLE[role], \" role does not exist. The \").concat(KEY_ROLE[0], \" for the default role is also empty.\"));\n        }\n\n        key = this._keys[KEY_ROLE.roleTransactionKey];\n      }\n\n      return key;\n    }\n    /**\n     * returns an instance of Account.\n     *\n     * @param {WeightedMultiSigOptions|Array.<WeightedMultiSigOptions>} [options] The options that includes 'threshold' and 'weight'. This is only necessary when keyring use multiple private keys.\n     * @return {Account}\n     */\n\n  }, {\n    key: \"toAccount\",\n    value: function toAccount(options) {\n      if (options !== undefined && !_.isArray(options)) throw new Error(\"options for an account should define threshold and weight for each roles in an array format\");\n      var lengths = [];\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this.keys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var k = _step4.value;\n          lengths.push(k.length);\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      options = fillWeightedMultiSigOptionsForRoleBased(lengths, options);\n      var publicKeysByRole = this.getPublicKey();\n      return Account.createWithAccountKeyRoleBased(this.address, publicKeysByRole, options);\n    }\n    /**\n     * encrypts a keyring and returns a keystore v4 object.\n     *\n     * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} options The options to use when encrypt a keyring. Also address can be defined specifically in options object.\n     * @return {object}\n     */\n\n    /**\n     * options can include below\n     * {\n     *   salt: ...,\n     *   iv: ...,\n     *   kdf: ...,\n     *   dklen: ...,\n     *   c: ...,\n     *   n: ...,\n     *   r: ...,\n     *   p: ...,\n     *   cipher: ...,\n     *   uuid: ...,\n     *   cipher: ...,\n     * }\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(password) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var keyring = [];\n\n      for (var i = KEY_ROLE.roleTransactionKey; i < KEY_ROLE.roleLast; i++) {\n        var roledKey = this._keys[i];\n        keyring.push(encryptKey(roledKey, password, options));\n      }\n\n      return formatEncrypted(4, this._address, keyring, options);\n    }\n  }, {\n    key: \"keys\",\n    get: function get() {\n      return this._keys;\n    },\n    set: function set(keyInput) {\n      if (keyInput === null) {\n        this._key = null;\n        return;\n      }\n\n      this._keys = formattingForKeyInKeyring(keyInput);\n    }\n    /**\n     * @type {Array.<PrivateKey>}\n     */\n\n  }, {\n    key: \"roleTransactionKey\",\n    get: function get() {\n      return this.getKeyByRole(KEY_ROLE.roleTransactionKey);\n    }\n    /**\n     * @type {Array.<PrivateKey>}\n     */\n\n  }, {\n    key: \"roleAccountUpdateKey\",\n    get: function get() {\n      return this.getKeyByRole(KEY_ROLE.roleAccountUpdateKey);\n    }\n    /**\n     * @type {Array.<PrivateKey>}\n     */\n\n  }, {\n    key: \"roleFeePayerKey\",\n    get: function get() {\n      return this.getKeyByRole(KEY_ROLE.roleFeePayerKey);\n    }\n  }]);\n\n  return RoleBasedKeyring;\n}(AbstractKeyring);\n\nmodule.exports = RoleBasedKeyring;\n/**\n * Format the key parameters passed by the user to create a keyring instance into a two-dimensional array containing PrivateKey instances.\n *\n * The cases of the parameter that the user passes to the function is as follows, and this function formats it as a two-dimensional array.\n * PrivateKey instance: PrivateKey{}\n * single private key string: `0x{private key}`\n * multiple private key strings: [`0x{private key}`, `0x{private key}`]\n * multiple PrivateKey instances: [PrivateKey{}, PrivateKey{}]\n * role-based private key strings: [[`0x{private key}`], [`0x{private key}`, `0x{private key}`], [`0x{private key}`]]\n * role-based PrivateKey instances: [[PrivateKey{}], [PrivateKey{}, PrivateKey{}], [PrivateKey{}]]\n *\n * @param {string|PrivateKey|Array.<string|PrivateKey>|Array.<Array.<string|PrivateKey>>} keyInput The input parameter for key variable in Keyring.\n * @return {Array.<Array.<PrivateKey>>}\n */\n\nfunction formattingForKeyInKeyring(keyInput) {\n  if (keyInput === null) {\n    return keyInput;\n  }\n\n  if (keyInput instanceof PrivateKey || _.isString(keyInput)) {\n    keyInput = [[keyInput], [], []];\n  } else if (isMultipleKeysFormat(keyInput)) {\n    // [`0x{private key}`, `0x{private key}`, `0x{private key}`]\n    keyInput = [keyInput, [], []];\n  } else if (!isRoleBasedKeysFormat(keyInput)) {\n    throw new Error(\"Invalid format for key variable in keyring\");\n  }\n\n  var keys = generateKeysFormat();\n\n  for (var i = 0; i < KEY_ROLE.roleLast; i++) {\n    fillRoleKey(keys, i, keyInput[i]);\n  }\n\n  return keys;\n}\n\nfunction generateKeysFormat() {\n  return Array(KEY_ROLE.roleLast).fill(null).map(function () {\n    return [];\n  });\n}\n\nfunction fillRoleKey(keys, role, keyToAdd) {\n  if (keyToAdd === undefined) return;\n  keyToAdd = Array.isArray(keyToAdd) ? keyToAdd : [keyToAdd];\n  if (keyToAdd.length > MAXIMUM_KEY_NUM) throw new Error(\"The maximum number of private keys that can be used in keyring is \".concat(MAXIMUM_KEY_NUM, \".\"));\n  if (role >= KEY_ROLE.roleLast) throw new Error(\"Unsupported role number. The role number should be less than \".concat(KEY_ROLE.roleLast, \". Please use 'caver.wallet.keyring.role'\"));\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = keyToAdd[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var keyString = _step5.value;\n      var key = keyString instanceof PrivateKey ? keyString : new PrivateKey(keyString);\n      keys[role].push(key);\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}