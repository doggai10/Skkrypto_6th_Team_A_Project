{"ast":null,"code":"/**\n * Multihash implementation in JavaScript.\n *\n * @module multihash\n */\n'use strict';\n\nvar multibase = require('multibase');\n\nvar varint = require('varint');\n\nvar _require = require('./constants'),\n    names = _require.names;\n\nvar uint8ArrayToString = require('uint8arrays/to-string');\n\nvar uint8ArrayFromString = require('uint8arrays/from-string');\n\nvar uint8ArrayConcat = require('uint8arrays/concat');\n\nvar codes =\n/** @type {import('./types').CodeNameMap} */\n{}; // eslint-disable-next-line guard-for-in\n\nfor (var key in names) {\n  codes[names[key]] = key;\n}\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\n\n\nfunction toHexString(hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array');\n  }\n\n  return uint8ArrayToString(hash, 'base16');\n}\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Uint8Array}\n */\n\n\nfunction fromHexString(hash) {\n  return uint8ArrayFromString(hash, 'base16');\n}\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\n\n\nfunction toB58String(hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array');\n  }\n\n  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1);\n}\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Uint8Array} hash\n * @returns {Uint8Array}\n */\n\n\nfunction fromB58String(hash) {\n  var encoded = hash instanceof Uint8Array ? uint8ArrayToString(hash) : hash;\n  return multibase.decode('z' + encoded);\n}\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Uint8Array} bytes\n * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result\n */\n\n\nfunction decode(bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new Error('multihash must be a Uint8Array');\n  }\n\n  if (bytes.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.');\n  }\n\n  var code = varint.decode(bytes);\n\n  if (!isValidCode(code)) {\n    throw new Error(\"multihash unknown function code: 0x\".concat(code.toString(16)));\n  }\n\n  bytes = bytes.slice(varint.decode.bytes);\n  var len = varint.decode(bytes);\n\n  if (len < 0) {\n    throw new Error(\"multihash invalid length: \".concat(len));\n  }\n\n  bytes = bytes.slice(varint.decode.bytes);\n\n  if (bytes.length !== len) {\n    throw new Error(\"multihash length inconsistent: 0x\".concat(uint8ArrayToString(bytes, 'base16')));\n  }\n\n  return {\n    code: code,\n    name: codes[code],\n    length: len,\n    digest: bytes\n  };\n}\n/**\n * Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Uint8Array} digest\n * @param {HashName | HashCode} code\n * @param {number} [length]\n * @returns {Uint8Array}\n */\n\n\nfunction encode(digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code');\n  } // ensure it's a hashfunction code.\n\n\n  var hashfn = coerceCode(code);\n\n  if (!(digest instanceof Uint8Array)) {\n    throw new Error('digest should be a Uint8Array');\n  }\n\n  if (length == null) {\n    length = digest.length;\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.');\n  }\n\n  var hash = varint.encode(hashfn);\n  var len = varint.encode(length);\n  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length);\n}\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n *\n * @param {HashName | number} name\n * @returns {number}\n */\n\n\nfunction coerceCode(name) {\n  var code = name;\n\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(\"Unrecognized hash function named: \".concat(name));\n    }\n\n    code = names[name];\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(\"Hash function code should be a number. Got: \".concat(code));\n  }\n\n  if (codes[code] === undefined && !isAppCode(code)) {\n    throw new Error(\"Unrecognized function code: \".concat(code));\n  }\n\n  return code;\n}\n/**\n * Checks if a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\n\n\nfunction isAppCode(code) {\n  return code > 0 && code < 0x10;\n}\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {HashCode} code\n * @returns {boolean}\n */\n\n\nfunction isValidCode(code) {\n  if (isAppCode(code)) {\n    return true;\n  }\n\n  if (codes[code]) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {void}\n * @throws {Error}\n */\n\n\nfunction validate(multihash) {\n  decode(multihash); // throws if bad.\n}\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n * @throws {Error}\n */\n\n\nfunction prefix(multihash) {\n  validate(multihash);\n  return multihash.subarray(0, 2);\n}\n\nmodule.exports = {\n  names: names,\n  codes: Object.freeze(codes),\n  toHexString: toHexString,\n  fromHexString: fromHexString,\n  toB58String: toB58String,\n  fromB58String: fromB58String,\n  decode: decode,\n  encode: encode,\n  coerceCode: coerceCode,\n  isAppCode: isAppCode,\n  validate: validate,\n  prefix: prefix,\n  isValidCode: isValidCode\n};\n/**\n * @typedef { import(\"./constants\").HashCode } HashCode\n * @typedef { import(\"./constants\").HashName } HashName\n */","map":{"version":3,"sources":["/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/multihashes/src/index.js"],"names":["multibase","require","varint","names","uint8ArrayToString","uint8ArrayFromString","uint8ArrayConcat","codes","key","toHexString","hash","Uint8Array","Error","fromHexString","toB58String","encode","slice","fromB58String","encoded","decode","bytes","length","code","isValidCode","toString","len","name","digest","undefined","hashfn","coerceCode","isAppCode","validate","multihash","prefix","subarray","module","exports","Object","freeze"],"mappings":"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","sourcesContent":["/**\n * Multihash implementation in JavaScript.\n *\n * @module multihash\n */\n'use strict'\n\nconst multibase = require('multibase')\nconst varint = require('varint')\nconst { names } = require('./constants')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\nconst uint8ArrayConcat = require('uint8arrays/concat')\n\nconst codes = /** @type {import('./types').CodeNameMap} */({})\n\n// eslint-disable-next-line guard-for-in\nfor (const key in names) {\n  codes[names[key]] = key\n}\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toHexString (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return uint8ArrayToString(hash, 'base16')\n}\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Uint8Array}\n */\nfunction fromHexString (hash) {\n  return uint8ArrayFromString(hash, 'base16')\n}\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toB58String (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1)\n}\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Uint8Array} hash\n * @returns {Uint8Array}\n */\nfunction fromB58String (hash) {\n  const encoded = hash instanceof Uint8Array\n    ? uint8ArrayToString(hash)\n    : hash\n\n  return multibase.decode('z' + encoded)\n}\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Uint8Array} bytes\n * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result\n */\nfunction decode (bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new Error('multihash must be a Uint8Array')\n  }\n\n  if (bytes.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.')\n  }\n\n  const code = varint.decode(bytes)\n  if (!isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\n  }\n  bytes = bytes.slice(varint.decode.bytes)\n\n  const len = varint.decode(bytes)\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`)\n  }\n  bytes = bytes.slice(varint.decode.bytes)\n\n  if (bytes.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`)\n  }\n\n  return {\n    code,\n    name: codes[code],\n    length: len,\n    digest: bytes\n  }\n}\n\n/**\n * Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Uint8Array} digest\n * @param {HashName | HashCode} code\n * @param {number} [length]\n * @returns {Uint8Array}\n */\nfunction encode (digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code')\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = coerceCode(code)\n\n  if (!(digest instanceof Uint8Array)) {\n    throw new Error('digest should be a Uint8Array')\n  }\n\n  if (length == null) {\n    length = digest.length\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.')\n  }\n\n  const hash = varint.encode(hashfn)\n  const len = varint.encode(length)\n  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length)\n}\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n *\n * @param {HashName | number} name\n * @returns {number}\n */\nfunction coerceCode (name) {\n  let code = name\n\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`)\n    }\n    code = names[name]\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\n  }\n\n  if (codes[code] === undefined && !isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`)\n  }\n\n  return code\n}\n\n/**\n * Checks if a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction isAppCode (code) {\n  return code > 0 && code < 0x10\n}\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {HashCode} code\n * @returns {boolean}\n */\nfunction isValidCode (code) {\n  if (isAppCode(code)) {\n    return true\n  }\n\n  if (codes[code]) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {void}\n * @throws {Error}\n */\nfunction validate (multihash) {\n  decode(multihash) // throws if bad.\n}\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n * @throws {Error}\n */\nfunction prefix (multihash) {\n  validate(multihash)\n\n  return multihash.subarray(0, 2)\n}\n\nmodule.exports = {\n  names,\n  codes: Object.freeze(codes),\n  toHexString,\n  fromHexString,\n  toB58String,\n  fromB58String,\n  decode,\n  encode,\n  coerceCode,\n  isAppCode,\n  validate,\n  prefix,\n  isValidCode\n}\n\n/**\n * @typedef { import(\"./constants\").HashCode } HashCode\n * @typedef { import(\"./constants\").HashName } HashName\n */\n"]},"metadata":{},"sourceType":"script"}