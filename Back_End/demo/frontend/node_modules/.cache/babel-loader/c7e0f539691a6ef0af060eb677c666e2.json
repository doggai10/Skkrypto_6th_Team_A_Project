{"ast":null,"code":"var _classCallCheck = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nvar AbstractKeyring = require('./abstractKeyring');\n\nvar utils = require('../../../caver-utils');\n\nvar PrivateKey = require('./privateKey');\n\nvar _require = require('./keyringHelper'),\n    KEY_ROLE = _require.KEY_ROLE;\n\nvar Account = require('../../../caver-account');\n\nvar _require2 = require('./keyringHelper'),\n    validateForSigning = _require2.validateForSigning,\n    validateIndexWithKeys = _require2.validateIndexWithKeys,\n    encryptKey = _require2.encryptKey,\n    formatEncrypted = _require2.formatEncrypted;\n/**\n * representing a Keyring which includes `address` and a `private key`.\n * @class\n */\n\n\nvar SingleKeyring = /*#__PURE__*/function (_AbstractKeyring) {\n  \"use strict\";\n\n  _inherits(SingleKeyring, _AbstractKeyring);\n\n  var _super = _createSuper(SingleKeyring);\n\n  /**\n   * creates a SingleKeyring.\n   * @param {string} address - The address of keyring.\n   * @param {string|PrivateKey} key - The key to use in SingleKeyring.\n   */\n  function SingleKeyring(address, key) {\n    var _this;\n\n    _classCallCheck(this, SingleKeyring);\n\n    _this = _super.call(this, address);\n    _this.key = key;\n    return _this;\n  }\n  /**\n   * @type {PrivateKey}\n   */\n\n\n  _createClass(SingleKeyring, [{\n    key: \"getPublicKey\",\n\n    /**\n     * returns public key string.\n     *\n     * @return {string}\n     */\n    value: function getPublicKey() {\n      return this.key.getPublicKey();\n    }\n    /**\n     * returns a copied singleKeyring instance\n     *\n     * @return {SingleKeyring}\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new SingleKeyring(this.address, this.key);\n    }\n    /**\n     * signs with transactionHash with a key and returns signature(s).\n     *\n     * @param {string} transactionHash The hash of transaction.\n     * @param {string|number} chainId The chainId specific to the network.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n     * @return {Array.<string>|Array.<Array.<string>>}\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(transactionHash, chainId, role, index) {\n      validateForSigning(transactionHash, chainId);\n      var key = this.getKeyByRole(role);\n\n      if (index !== undefined) {\n        validateIndexWithKeys(index, 1);\n        return key.sign(transactionHash, chainId);\n      }\n\n      return [key.sign(transactionHash, chainId)];\n    }\n    /**\n     * signs with hashed message and returns result object that includes `signatures`, `message` and `messageHash`\n     *\n     * @param {string} message The message string to sign.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used.\n     * @return {object}\n     */\n\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(message, role, index) {\n      if (role === undefined) throw new Error(\"role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.\");\n      var messageHash = utils.hashMessage(message);\n      var key = this.getKeyByRole(role);\n      var signatures = [];\n\n      if (index !== undefined) {\n        validateIndexWithKeys(index, 1);\n      }\n\n      signatures.push(key.signMessage(messageHash));\n      return {\n        messageHash: messageHash,\n        signatures: signatures,\n        message: message\n      };\n    }\n    /**\n     * returns keys by role. If the key of the role passed as parameter is empty, the default key is returned.\n     *\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @return {Array.<PrivateKey>}\n     */\n\n  }, {\n    key: \"getKeyByRole\",\n    value: function getKeyByRole(role) {\n      if (role === undefined) throw new Error(\"role should be defined.\");\n      if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(\"Invalid role number: \".concat(role));\n      return this.key;\n    }\n    /**\n     * returns KlaytnWalletKey format. If keyring uses more than one private key, this function will throw error.\n     *\n     * @return {string}\n     */\n\n  }, {\n    key: \"getKlaytnWalletKey\",\n    value: function getKlaytnWalletKey() {\n      return \"\".concat(this.key.privateKey, \"0x00\").concat(this.address);\n    }\n    /**\n     * returns an instance of Account.\n     *\n     * @return {Account}\n     */\n\n  }, {\n    key: \"toAccount\",\n    value: function toAccount() {\n      if (!this.key) throw new Error(\"Failed to create Account instance: Empty key in keyring.\");\n      var publicKey = this.getPublicKey();\n      return Account.createWithAccountKeyPublic(this.address, publicKey);\n    }\n    /**\n     * encrypts a keyring and returns a keystore v4 object.\n     *\n     * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} options The options to use when encrypt a keyring. Also address can be defined specifically in options object.\n     * @return {object}\n     */\n\n    /**\n     * options can include below\n     * {\n     *   salt: ...,\n     *   iv: ...,\n     *   kdf: ...,\n     *   dklen: ...,\n     *   c: ...,\n     *   n: ...,\n     *   r: ...,\n     *   p: ...,\n     *   cipher: ...,\n     *   uuid: ...,\n     *   cipher: ...,\n     * }\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(password) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var keyring = [];\n      keyring = encryptKey(this.key, password, options);\n      return formatEncrypted(4, this.address, keyring, options);\n    }\n    /**\n     * encrypts a keyring and returns a keystore v3 object.\n     *\n     * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} options The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n     * @return {object}\n     */\n\n  }, {\n    key: \"encryptV3\",\n    value: function encryptV3(password, options) {\n      options = options || {};\n      var crypto = encryptKey(this.key, password, options)[0];\n      return formatEncrypted(3, this.address, crypto, options);\n    }\n    /**\n     * returns true if keyring has decoupled key.\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isDecoupled\",\n    value: function isDecoupled() {\n      return this.address.toLowerCase() !== this.key.getDerivedAddress().toLowerCase();\n    }\n  }, {\n    key: \"key\",\n    get: function get() {\n      return this._key;\n    },\n    set: function set(keyInput) {\n      if (keyInput === null) {\n        this._key = null;\n        return;\n      }\n\n      this._key = keyInput instanceof PrivateKey ? keyInput : new PrivateKey(keyInput);\n    }\n  }]);\n\n  return SingleKeyring;\n}(AbstractKeyring);\n\nmodule.exports = SingleKeyring;","map":{"version":3,"sources":["/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/caver-js/packages/caver-wallet/src/keyring/singleKeyring.js"],"names":["AbstractKeyring","require","utils","PrivateKey","KEY_ROLE","Account","validateForSigning","validateIndexWithKeys","encryptKey","formatEncrypted","SingleKeyring","address","key","getPublicKey","transactionHash","chainId","role","index","getKeyByRole","undefined","sign","message","Error","messageHash","hashMessage","signatures","push","signMessage","roleLast","privateKey","publicKey","createWithAccountKeyPublic","password","options","keyring","crypto","toLowerCase","getDerivedAddress","_key","keyInput","module","exports"],"mappings":"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","sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst AbstractKeyring = require('./abstractKeyring')\nconst utils = require('../../../caver-utils')\nconst PrivateKey = require('./privateKey')\nconst { KEY_ROLE } = require('./keyringHelper')\nconst Account = require('../../../caver-account')\nconst { validateForSigning, validateIndexWithKeys, encryptKey, formatEncrypted } = require('./keyringHelper')\n\n/**\n * representing a Keyring which includes `address` and a `private key`.\n * @class\n */\nclass SingleKeyring extends AbstractKeyring {\n    /**\n     * creates a SingleKeyring.\n     * @param {string} address - The address of keyring.\n     * @param {string|PrivateKey} key - The key to use in SingleKeyring.\n     */\n    constructor(address, key) {\n        super(address)\n        this.key = key\n    }\n\n    /**\n     * @type {PrivateKey}\n     */\n    get key() {\n        return this._key\n    }\n\n    set key(keyInput) {\n        if (keyInput === null) {\n            this._key = null\n            return\n        }\n        this._key = keyInput instanceof PrivateKey ? keyInput : new PrivateKey(keyInput)\n    }\n\n    /**\n     * returns public key string.\n     *\n     * @return {string}\n     */\n    getPublicKey() {\n        return this.key.getPublicKey()\n    }\n\n    /**\n     * returns a copied singleKeyring instance\n     *\n     * @return {SingleKeyring}\n     */\n    copy() {\n        return new SingleKeyring(this.address, this.key)\n    }\n\n    /**\n     * signs with transactionHash with a key and returns signature(s).\n     *\n     * @param {string} transactionHash The hash of transaction.\n     * @param {string|number} chainId The chainId specific to the network.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n     * @return {Array.<string>|Array.<Array.<string>>}\n     */\n    sign(transactionHash, chainId, role, index) {\n        validateForSigning(transactionHash, chainId)\n\n        const key = this.getKeyByRole(role)\n\n        if (index !== undefined) {\n            validateIndexWithKeys(index, 1)\n            return key.sign(transactionHash, chainId)\n        }\n\n        return [key.sign(transactionHash, chainId)]\n    }\n\n    /**\n     * signs with hashed message and returns result object that includes `signatures`, `message` and `messageHash`\n     *\n     * @param {string} message The message string to sign.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used.\n     * @return {object}\n     */\n    signMessage(message, role, index) {\n        if (role === undefined) throw new Error(`role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.`)\n        const messageHash = utils.hashMessage(message)\n\n        const key = this.getKeyByRole(role)\n        const signatures = []\n        if (index !== undefined) {\n            validateIndexWithKeys(index, 1)\n        }\n\n        signatures.push(key.signMessage(messageHash))\n        return {\n            messageHash,\n            signatures,\n            message,\n        }\n    }\n\n    /**\n     * returns keys by role. If the key of the role passed as parameter is empty, the default key is returned.\n     *\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @return {Array.<PrivateKey>}\n     */\n    getKeyByRole(role) {\n        if (role === undefined) throw new Error(`role should be defined.`)\n        if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(`Invalid role number: ${role}`)\n        return this.key\n    }\n\n    /**\n     * returns KlaytnWalletKey format. If keyring uses more than one private key, this function will throw error.\n     *\n     * @return {string}\n     */\n    getKlaytnWalletKey() {\n        return `${this.key.privateKey}0x00${this.address}`\n    }\n\n    /**\n     * returns an instance of Account.\n     *\n     * @return {Account}\n     */\n    toAccount() {\n        if (!this.key) throw new Error(`Failed to create Account instance: Empty key in keyring.`)\n        const publicKey = this.getPublicKey()\n        return Account.createWithAccountKeyPublic(this.address, publicKey)\n    }\n\n    /**\n     * encrypts a keyring and returns a keystore v4 object.\n     *\n     * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} options The options to use when encrypt a keyring. Also address can be defined specifically in options object.\n     * @return {object}\n     */\n    /**\n     * options can include below\n     * {\n     *   salt: ...,\n     *   iv: ...,\n     *   kdf: ...,\n     *   dklen: ...,\n     *   c: ...,\n     *   n: ...,\n     *   r: ...,\n     *   p: ...,\n     *   cipher: ...,\n     *   uuid: ...,\n     *   cipher: ...,\n     * }\n     */\n    encrypt(password, options = {}) {\n        let keyring = []\n        keyring = encryptKey(this.key, password, options)\n        return formatEncrypted(4, this.address, keyring, options)\n    }\n\n    /**\n     * encrypts a keyring and returns a keystore v3 object.\n     *\n     * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} options The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n     * @return {object}\n     */\n    encryptV3(password, options) {\n        options = options || {}\n\n        const crypto = encryptKey(this.key, password, options)[0]\n\n        return formatEncrypted(3, this.address, crypto, options)\n    }\n\n    /**\n     * returns true if keyring has decoupled key.\n     *\n     * @return {boolean}\n     */\n    isDecoupled() {\n        return this.address.toLowerCase() !== this.key.getDerivedAddress().toLowerCase()\n    }\n}\n\nmodule.exports = SingleKeyring\n"]},"metadata":{},"sourceType":"script"}