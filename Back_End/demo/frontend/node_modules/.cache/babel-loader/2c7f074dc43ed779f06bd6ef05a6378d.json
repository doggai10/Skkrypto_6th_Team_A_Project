{"ast":null,"code":"/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-eth-contract/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file contract.js\n *\n * To initialize a contract use:\n *\n *  let Contract = require('web3-eth-contract');\n *  Contract.setProvider('ws://localhost:8546');\n *  let contract = new Contract(abi, address, ...);\n *\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nvar _ = require('lodash');\n\nvar core = require('../../caver-core');\n\nvar Method = require('../../caver-core-method');\n\nvar utils = require('../../caver-utils');\n\nvar Subscription = require('../../caver-core-subscriptions').subscription;\n\nvar SmartContractDeploy = require('../../caver-transaction/src/transactionTypes/smartContractDeploy/smartContractDeploy');\n\nvar SmartContractExecution = require('../../caver-transaction/src/transactionTypes/smartContractExecution/smartContractExecution');\n\nvar KeyringContainer = require('../../caver-wallet');\n\nvar _require = require('../../caver-core-helpers'),\n    formatters = _require.formatters;\n\nvar _require2 = require('../../caver-core-helpers'),\n    errors = _require2.errors;\n\nvar abi = require('../../caver-abi');\n/**\n * Should be called to create new contract instance\n *\n * @method Contract\n * @constructor\n * @param {Array} jsonInterface\n * @param {String} address\n * @param {Object} options\n */\n\n/**\n * let myContract = new cav.klay.Contract([...], '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe', {\n *   from: '0x1234567890123456789012345678901234567891', // default from address\n *   gasPrice: '20000000000', // default gas price in wei, 20 gwei in this case\n *   data: '',(bytecode, when contract deploy)\n *   gas: 200000, (gas limit)\n * });\n */\n\n\nvar Contract = function Contract(jsonInterface, address, options) {\n  var _this = this;\n\n  var args = Array.prototype.slice.call(arguments);\n\n  if (!(this instanceof Contract)) {\n    throw new Error('Please use the \"new\" keyword to instantiate a caver.contract() or caver.klay.Contract() object!');\n  } // sets _requestmanager\n\n\n  core.packageInit(this, [this.constructor.currentProvider]);\n  this.clearSubscriptions = this._requestManager.clearSubscriptions;\n\n  if (!jsonInterface || !Array.isArray(jsonInterface)) {\n    throw new Error('You must provide the json interface of the contract when instantiating a contract object.');\n  } // create the options object\n\n\n  this.options = {};\n  var lastArg = args[args.length - 1];\n\n  if (_.isObject(lastArg) && !_.isArray(lastArg)) {\n    options = lastArg;\n    this.options = _.extend(this.options, this._getOrSetDefaultOptions(options));\n\n    if (_.isObject(address)) {\n      address = null;\n    }\n  }\n\n  Object.defineProperty(this, 'defaultSendOptions', {\n    get: function get() {\n      return _this.options;\n    }\n  }); // set address\n\n  Object.defineProperty(this.options, 'address', {\n    set: function set(value) {\n      if (value) {\n        _this._address = utils.toChecksumAddress(formatters.inputAddressFormatter(value));\n      }\n    },\n    get: function get() {\n      return _this._address;\n    },\n    enumerable: true\n  }); // add method and event signatures, when the jsonInterface gets set\n\n  Object.defineProperty(this.options, 'jsonInterface', {\n    set: function set(value) {\n      _this.methods = {};\n      _this.events = {};\n      _this._jsonInterface = value.map(function (method) {\n        var func;\n        var funcName;\n\n        if (method.name) {\n          funcName = utils._jsonInterfaceMethodToString(method);\n        } // function\n\n\n        if (method.type === 'function') {\n          method.signature = abi.encodeFunctionSignature(funcName);\n          func = _this._createTxObject.bind({\n            method: method,\n            parent: _this\n          }); // add method only if not one already exists\n\n          if (!_this.methods[method.name]) {\n            _this.methods[method.name] = func;\n          } else {\n            var cascadeFunc = _this._createTxObject.bind({\n              method: method,\n              parent: _this,\n              nextMethod: _this.methods[method.name]\n            });\n\n            _this.methods[method.name] = cascadeFunc;\n          } // definitely add the method based on its signature\n\n\n          _this.methods[method.signature] = func; // add method by name\n\n          _this.methods[funcName] = func; // event\n        } else if (method.type === 'event') {\n          method.signature = abi.encodeEventSignature(funcName);\n\n          var event = _this._on.bind(_this, method.signature); // add method only if not already exists\n\n\n          if (!_this.events[method.name] || _this.events[method.name].name === 'bound ') {\n            _this.events[method.name] = event;\n          } // definitely add the method based on its signature\n\n\n          _this.events[method.signature] = event; // add event by name\n\n          _this.events[funcName] = event;\n        }\n\n        return method;\n      }); // add allEvents\n\n      _this.events.allEvents = _this._on.bind(_this, 'allevents');\n      return _this._jsonInterface;\n    },\n    get: function get() {\n      return _this._jsonInterface;\n    },\n    enumerable: true\n  }); // get default account from the Class\n\n  var defaultAccount = this.constructor.defaultAccount;\n  var defaultBlock = this.constructor.defaultBlock || 'latest';\n  Object.defineProperty(this, 'defaultAccount', {\n    get: function get() {\n      return defaultAccount;\n    },\n    set: function set(val) {\n      if (val) {\n        defaultAccount = utils.toChecksumAddress(formatters.inputAddressFormatter(val));\n      }\n\n      return val;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, 'defaultBlock', {\n    get: function get() {\n      return defaultBlock;\n    },\n    set: function set(val) {\n      if (!utils.isValidBlockNumberCandidate(val)) {\n        throw new Error('Invalid default block number.');\n      }\n\n      defaultBlock = val;\n      return val;\n    },\n    enumerable: true\n  }); // Check for setting options property.\n\n  Object.defineProperty(this.options, 'from', {\n    set: function set(value) {\n      if (value) {\n        _this._from = utils.toChecksumAddress(formatters.inputAddressFormatter(value));\n      }\n    },\n    get: function get() {\n      return _this._from;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'gasPrice', {\n    set: function set(value) {\n      if (value) {\n        if (!utils.isValidNSHSN(value)) {\n          throw errors.invalidGasPrice();\n        }\n\n        _this._gasPrice = value;\n      }\n    },\n    get: function get() {\n      return _this._gasPrice;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'gas', {\n    set: function set(value) {\n      if (value) {\n        if (!utils.isValidNSHSN(value)) throw errors.invalidGasLimit();\n        _this._gas = value;\n      }\n    },\n    get: function get() {\n      return _this._gas;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'data', {\n    set: function set(value) {\n      if (value) {\n        if (!utils.isHexStrict(value)) throw errors.invalidData();\n        _this._data = value;\n      }\n    },\n    get: function get() {\n      return _this._data;\n    },\n    enumerable: true\n  }); // properties\n\n  this.methods = {};\n  this.events = {};\n  this._address = null;\n  this._jsonInterface = []; // set getter/setter properties\n\n  this.options.address = address;\n  this.options.jsonInterface = jsonInterface;\n};\n\nContract.setProvider = function (provider, accounts) {\n  core.packageInit(this, [provider]);\n  this._klayAccounts = accounts;\n};\n/**\n * Set _keyrings in contract instance.\n * When _keyrings is exsit, contract will use _keyrings instead of _klayAccounts\n *\n * @param {KeyringContainer} keyrings\n */\n\n\nContract.prototype.setKeyrings = function (keyrings) {\n  if (!(keyrings instanceof KeyringContainer)) throw new Error(\"keyrings should be an instance of 'KeyringContainer'\");\n  this._keyrings = keyrings;\n};\n\nContract.prototype.addAccounts = function (accounts) {\n  this._klayAccounts = accounts;\n};\n/**\n * Get the callback and modiufy the array if necessary\n *\n * @method _getCallback\n * @param {Array} args\n * @return {Function} the callback\n */\n\n\nContract.prototype._getCallback = function getCallback(args) {\n  if (args && _.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Checks that no listener with name \"newListener\" or \"removeListener\" is added.\n *\n * @method _checkListener\n * @param {String} type\n * @param {String} event\n * @return {Object} the contract instance\n */\n\n/**\n * this._checkListener('newListener', subOptions.event.name);\n * this._checkListener('removeListener', subOptions.event.name);\n */\n\n\nContract.prototype._checkListener = function (type, event) {\n  if (event === type) {\n    throw new Error(\"The event \\\"\".concat(type, \"\\\" is a reserved event name, you can't use it.\"));\n  }\n};\n/**\n * Use default values, if options are not available\n *\n * @method _getOrSetDefaultOptions\n * @param {Object} options the options gived by the user\n * @return {Object} the options with gaps filled by defaults\n */\n\n\nContract.prototype._getOrSetDefaultOptions = function getOrSetDefaultOptions(options) {\n  var gasPrice = options.gasPrice ? String(options.gasPrice) : null;\n  var from = options.from ? utils.toChecksumAddress(formatters.inputAddressFormatter(options.from)) : null;\n  options.data = options.data || this.options.data;\n  options.from = from || this.options.from;\n  options.gasPrice = gasPrice || this.options.gasPrice; // If options.gas isn't set manually, use options.gasLimit, this.options.gas instead.\n\n  if (typeof options.gas === 'undefined') {\n    options.gas = options.gasLimit || this.options.gas;\n  } // TODO replace with only gasLimit?\n\n\n  delete options.gasLimit;\n  return options;\n};\n/**\n * Should be used to encode indexed params and options to one final object\n *\n * @method _encodeEventABI\n * @param {Object} event\n * @param {Object} options\n * @return {Object} everything combined together and encoded\n */\n\n/**\n * _encodeEventABI\n * 1. options\n * options = {\n *   filter: {...},\n *   topics: [...],\n * }\n *   cf. topics\n *   - This allows you to manually set the topics for the event filter.\n *   - If given the filter property and event signature, (topic[0]) will not\n *   - be set automatically.\n *\n * 2. event\n * {\n *   anonymous: Bool,\n *   signature:\n *   name: String,\n *   inputs: [...],\n * }\n * cf) signature\n * - The signatureâ€™s hash of the event is one of the topics,\n * - unless you used the anonymous specifier to declare the event.\n * - This would mean filtering for anonymous, specific events by name is not possible.\n * - keccak256(\"burned(address,uint)\") = 0x0970ce1235167a71...\n */\n\n\nContract.prototype._encodeEventABI = function (event, options) {\n  options = options || {};\n  var filter = options.filter || {};\n  var result = {};\n  ['fromBlock', 'toBlock'].filter(function (f) {\n    return options[f] !== undefined;\n  }).forEach(function (f) {\n    result[f] = formatters.inputBlockNumberFormatter(options[f]);\n  }); // use given topics\n\n  if (_.isArray(options.topics)) {\n    result.topics = options.topics; // create topics based on filter\n  } else {\n    result.topics = []; // add event signature\n\n    if (event && !event.anonymous && event.name !== 'ALLEVENTS') {\n      result.topics.push(event.signature);\n    } // add event topics (indexed arguments)\n\n\n    if (event.name !== 'ALLEVENTS') {\n      var indexedTopics = event.inputs.filter(function (i) {\n        return i.indexed === true;\n      }).map(function (i) {\n        var value = filter[i.name];\n        if (!value) return null; // TODO: https://github.com/ethereum/web3.js/issues/344\n\n        if (_.isArray(value)) {\n          return value.map(function (v) {\n            return abi.encodeParameter(i.type, v);\n          });\n        }\n\n        return abi.encodeParameter(i.type, value);\n      });\n      result.topics = result.topics.concat(indexedTopics);\n    }\n\n    if (!result.topics.length) delete result.topics;\n  }\n\n  if (this.options.address) {\n    result.address = this.options.address.toLowerCase();\n  }\n\n  return result;\n};\n/**\n * Should be used to decode indexed params and options\n *\n * @method _decodeEventABI\n * @param {Object} data\n * @return {Object} result object with decoded indexed && not indexed params\n */\n\n\nContract.prototype._decodeEventABI = function (data) {\n  var event = this;\n  data.data = data.data || '';\n  data.topics = data.topics || [];\n  var result = formatters.outputLogFormatter(data); // if allEvents get the right event\n\n  if (event.name === 'ALLEVENTS') {\n    event = event.jsonInterface.find(function (intf) {\n      return intf.signature === data.topics[0];\n    }) || {\n      anonymous: true\n    };\n  } // create empty inputs if none are present (e.g. anonymous events on allEvents)\n\n\n  event.inputs = event.inputs || [];\n  var argTopics = event.anonymous ? data.topics : data.topics.slice(1);\n  result.returnValues = abi.decodeLog(event.inputs, data.data, argTopics);\n  delete result.returnValues.__length__; // add name\n\n  result.event = event.name; // add signature\n\n  result.signature = event.anonymous || !data.topics[0] ? null : data.topics[0]; // move the data and topics to \"raw\"\n\n  result.raw = {\n    data: result.data,\n    topics: result.topics\n  };\n  delete result.data;\n  delete result.topics;\n  return result;\n};\n/**\n * Encodes an ABI for a method, including signature or the method.\n * Or when constructor encodes only the constructor parameters.\n *\n * @method _encodeMethodABI\n * @param {Mixed} args the arguments to encode\n * @param {String} the encoded ABI\n */\n\n\nContract.prototype._encodeMethodABI = function _encodeMethodABI() {\n  var methodSignature = this._method.signature;\n  var args = this.arguments || [];\n  var signature = false;\n  var paramsABI = this._parent.options.jsonInterface.filter(function (json) {\n    return methodSignature === 'constructor' && json.type === methodSignature || (json.signature === methodSignature || json.signature === methodSignature.replace('0x', '') || json.name === methodSignature) && json.type === 'function';\n  }).map(function (json) {\n    var inputLength = _.isArray(json.inputs) ? json.inputs.length : 0;\n\n    if (inputLength !== args.length) {\n      throw new Error(\"The number of arguments is not matching the methods required number. You need to pass \".concat(inputLength, \" arguments.\"));\n    }\n\n    if (json.type === 'function') {\n      signature = json.signature;\n    }\n\n    return _.isArray(json.inputs) ? json.inputs : [];\n  }).map(function (inputs) {\n    return abi.encodeParameters(inputs, args).replace('0x', '');\n  })[0] || ''; // return constructor\n\n  if (methodSignature === 'constructor') {\n    if (!this._deployData) {\n      throw new Error('The contract has no contract data option set. This is necessary to append the constructor parameters.');\n    }\n\n    return this._deployData + paramsABI; // return method\n  }\n\n  var returnValue = signature ? signature + paramsABI : paramsABI;\n\n  if (!returnValue) {\n    throw new Error(\"Couldn't find a matching contract method named \\\"\".concat(this._method.name, \"\\\".\"));\n  } else {\n    return returnValue;\n  }\n};\n/**\n * Decode method return values\n *\n * @method _decodeMethodReturn\n * @param {Array} outputs\n * @param {String} returnValues\n * @return {Object} decoded output return values\n */\n\n\nContract.prototype._decodeMethodReturn = function (outputs, returnValues) {\n  if (!returnValues) {\n    return null;\n  }\n\n  returnValues = returnValues.length >= 2 ? returnValues.slice(2) : returnValues;\n  var result = abi.decodeParameters(outputs, returnValues);\n\n  if (result.__length__ === 1) {\n    return result[0];\n  }\n\n  delete result.__length__;\n  return result;\n};\n/**\n * Deploys a contract and fire events based on its state: transactionHash, receipt\n *\n * All event listeners will be removed, once the last possible event is fired (\"error\", or \"receipt\")\n *\n * @method deploy\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\n\n\nContract.prototype.deploy = function (options, callback) {\n  options = options || {};\n  options.arguments = options.arguments || [];\n  options = this._getOrSetDefaultOptions(options); // return error, if no \"data\" is specified\n\n  if (!options.data) {\n    return utils._fireError(new Error('No \"data\" specified in neither the given options, nor the default options.'), null, null, callback);\n  }\n\n  var constructor = _.find(this.options.jsonInterface, function (method) {\n    return method.type === 'constructor';\n  }) || {};\n  constructor.signature = 'constructor';\n  return this._createTxObject.apply({\n    method: constructor,\n    parent: this,\n    deployData: options.data,\n    _klayAccounts: this.constructor._klayAccounts,\n    _keyrings: this._keyrings\n  }, options.arguments);\n};\n/**\n * Gets the event signature and outputformatters\n *\n * @method _generateEventOptions\n * @param {Object} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event options object\n */\n\n\nContract.prototype._generateEventOptions = function () {\n  var args = Array.prototype.slice.call(arguments); // get the callback\n\n  var callback = this._getCallback(args); // get the options\n\n\n  var options = _.isObject(args[args.length - 1]) ? args.pop() : {};\n  var event = _.isString(args[0]) ? args[0] : 'allevents';\n  event = event.toLowerCase() === 'allevents' ? {\n    name: 'ALLEVENTS',\n    jsonInterface: this.options.jsonInterface\n  } : this.options.jsonInterface.find(function (json) {\n    return json.type === 'event' && (json.name === event || json.signature === \"0x\".concat(event.replace('0x', '')));\n  });\n\n  if (!event) {\n    throw new Error(\"Event \\\"\".concat(event.name, \"\\\" doesn't exist in this contract.\"));\n  }\n\n  if (!utils.isAddress(this.options.address)) {\n    throw new Error(\"This contract object doesn't have address set yet, please set an address first.\");\n  }\n\n  return {\n    params: this._encodeEventABI(event, options),\n    event: event,\n    callback: callback\n  };\n};\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n *\n * @method clone\n * @return {Object} the event subscription\n */\n\n\nContract.prototype.clone = function () {\n  var contractAddress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.address;\n  return new this.constructor(this.options.jsonInterface, contractAddress, this.options);\n};\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n * (Subscribes to an event and unsubscribes immediately after the first event or error. Will only fire for a single event.)\n *\n *\n * @method once\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event subscription\n *\n * myContract.once('MyEvent', {\n      filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23\n      fromBlock: 0\n  }, function(error, event){ console.log(event); });\n\n  // event output example\n  > {\n      returnValues: {\n          myIndexedParam: 20,\n          myOtherIndexedParam: '0x123456789...',\n          myNonIndexParam: 'My String'\n      },\n      raw: {\n          data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n          topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\n      },\n      event: 'MyEvent',\n      signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      logIndex: 0,\n      transactionIndex: 0,\n      transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n      blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      blockNumber: 1234,\n      address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\n  }\n */\n\n\nContract.prototype.once = function (event, options, callback) {\n  var args = Array.prototype.slice.call(arguments); // get the callback\n\n  callback = this._getCallback(args);\n\n  if (!callback) {\n    throw new Error('Once requires a callback as the second parameter.');\n  } // don't allow fromBlock\n\n\n  if (options) {\n    delete options.fromBlock;\n  } // don't return as once shouldn't provide \"on\"\n\n\n  this._on(event, options, function (err, res, sub) {\n    sub.unsubscribe();\n\n    if (_.isFunction(callback)) {\n      callback(err, res, sub);\n    }\n  });\n\n  return undefined;\n};\n/**\n * Adds event listeners and creates a subscription.\n *\n * @method _on\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event subscription\n */\n\n\nContract.prototype._on = function () {\n  var subOptions = this._generateEventOptions.apply(this, arguments); // prevent the event \"newListener\" and \"removeListener\" from being overwritten\n\n\n  this._checkListener('newListener', subOptions.event.name);\n\n  this._checkListener('removeListener', subOptions.event.name); // TODO check if listener already exists? and reuse subscription if options are the same.\n\n\n  var subscription = new Subscription({\n    subscription: {\n      params: 1,\n      inputFormatter: [formatters.inputLogFormatter],\n      outputFormatter: this._decodeEventABI.bind(subOptions.event),\n      // DUBLICATE, also in caver-klay\n      subscriptionHandler: function subscriptionHandler(output) {\n        this.emit('data', output);\n\n        if (_.isFunction(this.callback)) {\n          this.callback(null, output, this);\n        }\n      }\n    },\n    type: 'klay',\n    requestManager: this._requestManager\n  });\n  subscription.subscribe('logs', subOptions.params, subOptions.callback || function () {});\n  return subscription;\n};\n/**\n * Get past events from contracts\n *\n * @method getPastEvents\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the promievent\n */\n\n/**\n * myContract.getPastEvents('MyEvent', {\n      filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23\n      fromBlock: 0,\n      toBlock: 'latest'\n  }, function(error, events){ console.log(events); })\n  .then(function(events){\n      console.log(events) // same results as the optional callback above\n  });\n\n  > [{\n      returnValues: {\n          myIndexedParam: 20,\n          myOtherIndexedParam: '0x123456789...',\n          myNonIndexParam: 'My String'\n      },\n      raw: {\n          data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n          topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\n      },\n      event: 'MyEvent',\n      signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      logIndex: 0,\n      transactionIndex: 0,\n      transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n      blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      blockNumber: 1234,\n      address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\n  },{\n      ...\n  }]\n */\n\n\nContract.prototype.getPastEvents = function () {\n  var subOptions = this._generateEventOptions.apply(this, arguments);\n\n  var getPastLogs = new Method({\n    name: 'getPastLogs',\n    call: 'klay_getLogs',\n    params: 1,\n    inputFormatter: [formatters.inputLogFormatter],\n    outputFormatter: this._decodeEventABI.bind(subOptions.event)\n  });\n  getPastLogs.setRequestManager(this._requestManager);\n  var call = getPastLogs.buildCall();\n  getPastLogs = null;\n  return call(subOptions.params, subOptions.callback);\n};\n/**\n * returns the an object with call, send, estimate functions\n *\n * @method _createTxObject\n * @returns {Object} an object with functions to call the methods\n */\n\n\nContract.prototype._createTxObject = function _createTxObject() {\n  var args = Array.prototype.slice.call(arguments);\n  var txObject = {};\n\n  if (this.method.type === 'function') {\n    txObject.call = this.parent._executeMethod.bind(txObject, 'call');\n    txObject.call.request = this.parent._executeMethod.bind(txObject, 'call', true); // to make batch requests\n  }\n\n  txObject.send = this.parent._executeMethod.bind(txObject, 'send');\n  txObject.send.request = this.parent._executeMethod.bind(txObject, 'send', true); // to make batch requests\n\n  txObject.encodeABI = this.parent._encodeMethodABI.bind(txObject);\n  txObject.estimateGas = this.parent._executeMethod.bind(txObject, 'estimate');\n\n  if (args && this.method.inputs && args.length !== this.method.inputs.length) {\n    if (this.nextMethod) {\n      return this.nextMethod.apply(null, args);\n    }\n\n    throw errors.InvalidNumberOfParams(args.length, this.method.inputs.length, this.method.name);\n  }\n\n  txObject.arguments = args || [];\n  txObject._method = this.method;\n  txObject._parent = this.parent;\n  txObject._klayAccounts = this.parent.constructor._klayAccounts || this._klayAccounts;\n  txObject._keyrings = this.parent._keyrings || this._keyrings;\n\n  if (this.deployData) {\n    txObject._deployData = this.deployData;\n  }\n\n  return txObject;\n};\n/**\n * Generates the options for the execute call\n *\n * @method _processExecuteArguments\n * @param {Array} args\n * @param {Promise} defer\n */\n\n\nContract.prototype._processExecuteArguments = function _processExecuteArguments(args, defer) {\n  var processedArgs = {};\n  processedArgs.type = args.shift(); // get the callback\n\n  processedArgs.callback = this._parent._getCallback(args); // get block number to use for call\n\n  if (processedArgs.type === 'call' && args[args.length - 1] !== true && (_.isString(args[args.length - 1]) || isFinite(args[args.length - 1]))) {\n    processedArgs.defaultBlock = args.pop();\n  } // get the options\n\n\n  processedArgs.options = _.isObject(args[args.length - 1]) ? args.pop() : {}; // get the generateRequest argument for batch requests\n\n  processedArgs.generateRequest = args[args.length - 1] === true ? args.pop() : false;\n  processedArgs.options = this._parent._getOrSetDefaultOptions(processedArgs.options);\n  processedArgs.options.data = this.encodeABI(); // add contract address\n\n  if (!this._deployData && !utils.isAddress(this._parent.options.address)) {\n    throw new Error(\"This contract object doesn't have address set yet, please set an address first.\");\n  }\n\n  if (!this._deployData) {\n    processedArgs.options.to = this._parent.options.address;\n  } // return error, if no \"data\" is specified\n\n\n  if (!processedArgs.options.data) {\n    return utils._fireError(new Error(\"Couldn't find a matching contract method, or the number of parameters is wrong.\"), defer.eventEmitter, defer.reject, processedArgs.callback);\n  }\n\n  return processedArgs;\n};\n/**\n * Executes a call, transact or estimateGas on a contract function\n *\n * @method _executeMethod\n * @param {String} type the type this execute function should execute\n * @param {Boolean} makeRequest if true, it simply returns the request parameters, rather than executing it\n */\n\n\nContract.prototype._executeMethod = function _executeMethod() {\n  var _this = this;\n\n  var args = this._parent._processExecuteArguments.call(this, Array.prototype.slice.call(arguments), defer);\n\n  var defer = utils.promiEvent(args.type !== 'send');\n  /* eslint-disable-line no-var */\n\n  var klayAccounts = _this.constructor._klayAccounts || _this._klayAccounts;\n  var keyrings = _this._parent._keyrings || _this._keyrings; // Not allow to specify options.gas to 0.\n\n  if (args.options && args.options.gas === 0) {\n    throw errors.notAllowedZeroGas();\n  } // simple return request for batch requests\n\n\n  if (args.generateRequest) {\n    var payload = {\n      params: [formatters.inputCallFormatter.call(this._parent, args.options)],\n      callback: args.callback\n    };\n\n    if (args.type === 'call') {\n      payload.params.push(formatters.inputDefaultBlockNumberFormatter.call(this._parent, args.defaultBlock));\n      payload.method = 'klay_call';\n      payload.format = this._parent._decodeMethodReturn.bind(null, this._method.outputs);\n    } else {\n      payload.method = 'klay_sendTransaction';\n    }\n\n    return payload;\n  }\n\n  switch (args.type) {\n    case 'estimate':\n      var estimateGas = new Method({\n        name: 'estimateGas',\n        call: 'klay_estimateGas',\n        params: 1,\n        inputFormatter: [formatters.inputCallFormatter],\n        outputFormatter: utils.hexToNumber,\n        requestManager: _this._parent._requestManager,\n        accounts: klayAccounts,\n        // is klay.accounts (necessary for wallet signing)\n        defaultAccount: _this._parent.defaultAccount,\n        defaultBlock: _this._parent.defaultBlock\n      }).createFunction();\n      return estimateGas(args.options, args.callback);\n\n    case 'call':\n      // TODO check errors: missing \"from\" should give error on deploy and send, call ?\n      var call = new Method({\n        name: 'call',\n        call: 'klay_call',\n        params: 2,\n        inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter],\n        // add output formatter for decoding\n        outputFormatter: function outputFormatter(result) {\n          return _this._parent._decodeMethodReturn(_this._method.outputs, result);\n        },\n        requestManager: _this._parent._requestManager,\n        accounts: klayAccounts,\n        // is klay.accounts (necessary for wallet signing)\n        defaultAccount: _this._parent.defaultAccount,\n        defaultBlock: _this._parent.defaultBlock\n      }).createFunction();\n      return call(args.options, args.defaultBlock, args.callback);\n\n    case 'send':\n      // return error, if no \"from\" is specified\n      if (!utils.isAddress(args.options.from)) {\n        return utils._fireError(new Error('No \"from\" address specified in neither the given options, nor the default options.'), defer.eventEmitter, defer.reject, args.callback);\n      }\n\n      if (_.isBoolean(this._method.payable) && !this._method.payable && args.options.value && args.options.value > 0) {\n        return utils._fireError(new Error('Can not send value to non-payable contract method or constructor'), defer.eventEmitter, defer.reject, args.callback);\n      } // make sure receipt logs are decoded\n\n\n      var extraFormatters = {\n        receiptFormatter: function receiptFormatter(receipt) {\n          if (_.isArray(receipt.logs)) {\n            // decode logs\n            var events = _.map(receipt.logs, function (log) {\n              return _this._parent._decodeEventABI.call({\n                name: 'ALLEVENTS',\n                jsonInterface: _this._parent.options.jsonInterface\n              }, log);\n            }); // make log names keys\n\n\n            receipt.events = {};\n            var count = 0;\n            events.forEach(function (ev) {\n              if (ev.event) {\n                // if > 1 of the same event, don't overwrite any existing events\n                if (receipt.events[ev.event]) {\n                  if (Array.isArray(receipt.events[ev.event])) {\n                    receipt.events[ev.event].push(ev);\n                  } else {\n                    receipt.events[ev.event] = [receipt.events[ev.event], ev];\n                  }\n                } else {\n                  receipt.events[ev.event] = ev;\n                }\n              } else {\n                receipt.events[count] = ev;\n                count++;\n              }\n            });\n            delete receipt.logs;\n          }\n\n          return receipt;\n        },\n        contractDeployFormatter: function contractDeployFormatter(receipt) {\n          var newContract = _this._parent.clone(receipt.contractAddress);\n\n          return newContract;\n        }\n      };\n      var sendTransaction = new Method({\n        name: 'sendTransaction',\n        call: 'klay_sendTransaction',\n        params: 1,\n        inputFormatter: [formatters.inputTransactionFormatter],\n        requestManager: _this._parent._requestManager,\n        accounts: klayAccounts,\n        // is klay.accounts (necessary for wallet signing)\n        defaultAccount: _this._parent.defaultAccount,\n        defaultBlock: _this._parent.defaultBlock,\n        extraFormatters: extraFormatters\n      }).createFunction();\n\n      if (keyrings) {\n        var isExisted = keyrings.getKeyring(args.options.from);\n\n        if (!isExisted) {\n          return sendTransaction(args.options, args.callback);\n        }\n\n        var sendRawTransaction = new Method({\n          name: 'sendRawTransaction',\n          call: 'klay_sendRawTransaction',\n          params: 1,\n          requestManager: _this._parent._requestManager,\n          defaultAccount: _this._parent.defaultAccount,\n          defaultBlock: _this._parent.defaultBlock,\n          extraFormatters: extraFormatters\n        }).createFunction();\n        var transaction;\n\n        if (this._deployData !== undefined) {\n          transaction = new SmartContractDeploy(args.options);\n        } else {\n          transaction = new SmartContractExecution(args.options);\n        }\n\n        return keyrings.sign(transaction.from, transaction).then(function (signedTx) {\n          return sendRawTransaction(signedTx.getRLPEncoding());\n        });\n      }\n\n      if (args.options.type === undefined) {\n        if (this._deployData !== undefined) {\n          args.options.type = 'SMART_CONTRACT_DEPLOY';\n        } else {\n          args.options.type = 'SMART_CONTRACT_EXECUTION';\n        }\n      }\n\n      if (args.options.type !== 'SMART_CONTRACT_EXECUTION' && args.options.type !== 'SMART_CONTRACT_DEPLOY') {\n        throw new Error('Unsupported transaction type. Please use SMART_CONTRACT_EXECUTION or SMART_CONTRACT_DEPLOY.');\n      }\n\n      var fromInWallet = sendTransaction.method.accounts.wallet[args.options.from.toLowerCase()];\n\n      if (!fromInWallet || !fromInWallet.privateKey) {\n        args.options.type = 'LEGACY';\n      }\n\n      return sendTransaction(args.options, args.callback);\n  }\n};\n\nmodule.exports = Contract;","map":{"version":3,"sources":["/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/caver-js/packages/caver-contract/src/index.js"],"names":["_","require","core","Method","utils","Subscription","subscription","SmartContractDeploy","SmartContractExecution","KeyringContainer","formatters","errors","abi","Contract","jsonInterface","address","options","_this","args","Array","prototype","slice","call","arguments","Error","packageInit","constructor","currentProvider","clearSubscriptions","_requestManager","isArray","lastArg","length","isObject","extend","_getOrSetDefaultOptions","Object","defineProperty","get","set","value","_address","toChecksumAddress","inputAddressFormatter","enumerable","methods","events","_jsonInterface","map","method","func","funcName","name","_jsonInterfaceMethodToString","type","signature","encodeFunctionSignature","_createTxObject","bind","parent","cascadeFunc","nextMethod","encodeEventSignature","event","_on","allEvents","defaultAccount","defaultBlock","val","isValidBlockNumberCandidate","_from","isValidNSHSN","invalidGasPrice","_gasPrice","invalidGasLimit","_gas","isHexStrict","invalidData","_data","setProvider","provider","accounts","_klayAccounts","setKeyrings","keyrings","_keyrings","addAccounts","_getCallback","getCallback","isFunction","pop","_checkListener","getOrSetDefaultOptions","gasPrice","String","from","data","gas","gasLimit","_encodeEventABI","filter","result","f","undefined","forEach","inputBlockNumberFormatter","topics","anonymous","push","indexedTopics","inputs","i","indexed","v","encodeParameter","concat","toLowerCase","_decodeEventABI","outputLogFormatter","find","intf","argTopics","returnValues","decodeLog","__length__","raw","_encodeMethodABI","methodSignature","_method","paramsABI","_parent","json","replace","inputLength","encodeParameters","_deployData","returnValue","_decodeMethodReturn","outputs","decodeParameters","deploy","callback","_fireError","apply","deployData","_generateEventOptions","isString","isAddress","params","clone","contractAddress","once","fromBlock","err","res","sub","unsubscribe","subOptions","inputFormatter","inputLogFormatter","outputFormatter","subscriptionHandler","output","emit","requestManager","subscribe","getPastEvents","getPastLogs","setRequestManager","buildCall","txObject","_executeMethod","request","send","encodeABI","estimateGas","InvalidNumberOfParams","_processExecuteArguments","defer","processedArgs","shift","isFinite","generateRequest","to","eventEmitter","reject","promiEvent","klayAccounts","notAllowedZeroGas","payload","inputCallFormatter","inputDefaultBlockNumberFormatter","format","hexToNumber","createFunction","isBoolean","payable","extraFormatters","receiptFormatter","receipt","logs","log","count","ev","contractDeployFormatter","newContract","sendTransaction","inputTransactionFormatter","isExisted","getKeyring","sendRawTransaction","transaction","sign","then","signedTx","getRLPEncoding","fromInWallet","wallet","privateKey","module","exports"],"mappings":"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","sourcesContent":["/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-eth-contract/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n/**\n * @file contract.js\n *\n * To initialize a contract use:\n *\n *  let Contract = require('web3-eth-contract');\n *  Contract.setProvider('ws://localhost:8546');\n *  let contract = new Contract(abi, address, ...);\n *\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nconst _ = require('lodash')\nconst core = require('../../caver-core')\nconst Method = require('../../caver-core-method')\nconst utils = require('../../caver-utils')\nconst Subscription = require('../../caver-core-subscriptions').subscription\nconst SmartContractDeploy = require('../../caver-transaction/src/transactionTypes/smartContractDeploy/smartContractDeploy')\nconst SmartContractExecution = require('../../caver-transaction/src/transactionTypes/smartContractExecution/smartContractExecution')\nconst KeyringContainer = require('../../caver-wallet')\nconst { formatters } = require('../../caver-core-helpers')\nconst { errors } = require('../../caver-core-helpers')\nconst abi = require('../../caver-abi')\n\n/**\n * Should be called to create new contract instance\n *\n * @method Contract\n * @constructor\n * @param {Array} jsonInterface\n * @param {String} address\n * @param {Object} options\n */\n\n/**\n * let myContract = new cav.klay.Contract([...], '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe', {\n *   from: '0x1234567890123456789012345678901234567891', // default from address\n *   gasPrice: '20000000000', // default gas price in wei, 20 gwei in this case\n *   data: '',(bytecode, when contract deploy)\n *   gas: 200000, (gas limit)\n * });\n */\nconst Contract = function Contract(jsonInterface, address, options) {\n    const _this = this\n    const args = Array.prototype.slice.call(arguments)\n\n    if (!(this instanceof Contract)) {\n        throw new Error('Please use the \"new\" keyword to instantiate a caver.contract() or caver.klay.Contract() object!')\n    }\n\n    // sets _requestmanager\n    core.packageInit(this, [this.constructor.currentProvider])\n\n    this.clearSubscriptions = this._requestManager.clearSubscriptions\n\n    if (!jsonInterface || !Array.isArray(jsonInterface)) {\n        throw new Error('You must provide the json interface of the contract when instantiating a contract object.')\n    }\n\n    // create the options object\n    this.options = {}\n\n    const lastArg = args[args.length - 1]\n    if (_.isObject(lastArg) && !_.isArray(lastArg)) {\n        options = lastArg\n        this.options = _.extend(this.options, this._getOrSetDefaultOptions(options))\n\n        if (_.isObject(address)) {\n            address = null\n        }\n    }\n\n    Object.defineProperty(this, 'defaultSendOptions', {\n        get() {\n            return _this.options\n        },\n    })\n\n    // set address\n    Object.defineProperty(this.options, 'address', {\n        set(value) {\n            if (value) {\n                _this._address = utils.toChecksumAddress(formatters.inputAddressFormatter(value))\n            }\n        },\n        get() {\n            return _this._address\n        },\n        enumerable: true,\n    })\n\n    // add method and event signatures, when the jsonInterface gets set\n    Object.defineProperty(this.options, 'jsonInterface', {\n        set(value) {\n            _this.methods = {}\n            _this.events = {}\n\n            _this._jsonInterface = value.map(function(method) {\n                let func\n                let funcName\n                if (method.name) {\n                    funcName = utils._jsonInterfaceMethodToString(method)\n                }\n\n                // function\n                if (method.type === 'function') {\n                    method.signature = abi.encodeFunctionSignature(funcName)\n                    func = _this._createTxObject.bind({\n                        method,\n                        parent: _this,\n                    })\n\n                    // add method only if not one already exists\n                    if (!_this.methods[method.name]) {\n                        _this.methods[method.name] = func\n                    } else {\n                        const cascadeFunc = _this._createTxObject.bind({\n                            method,\n                            parent: _this,\n                            nextMethod: _this.methods[method.name],\n                        })\n                        _this.methods[method.name] = cascadeFunc\n                    }\n\n                    // definitely add the method based on its signature\n                    _this.methods[method.signature] = func\n\n                    // add method by name\n                    _this.methods[funcName] = func\n\n                    // event\n                } else if (method.type === 'event') {\n                    method.signature = abi.encodeEventSignature(funcName)\n                    const event = _this._on.bind(_this, method.signature)\n\n                    // add method only if not already exists\n                    if (!_this.events[method.name] || _this.events[method.name].name === 'bound ') {\n                        _this.events[method.name] = event\n                    }\n\n                    // definitely add the method based on its signature\n                    _this.events[method.signature] = event\n\n                    // add event by name\n                    _this.events[funcName] = event\n                }\n\n                return method\n            })\n\n            // add allEvents\n            _this.events.allEvents = _this._on.bind(_this, 'allevents')\n\n            return _this._jsonInterface\n        },\n        get() {\n            return _this._jsonInterface\n        },\n        enumerable: true,\n    })\n\n    // get default account from the Class\n    let { defaultAccount } = this.constructor\n    let defaultBlock = this.constructor.defaultBlock || 'latest'\n\n    Object.defineProperty(this, 'defaultAccount', {\n        get() {\n            return defaultAccount\n        },\n        set(val) {\n            if (val) {\n                defaultAccount = utils.toChecksumAddress(formatters.inputAddressFormatter(val))\n            }\n\n            return val\n        },\n        enumerable: true,\n    })\n    Object.defineProperty(this, 'defaultBlock', {\n        get() {\n            return defaultBlock\n        },\n        set(val) {\n            if (!utils.isValidBlockNumberCandidate(val)) {\n                throw new Error('Invalid default block number.')\n            }\n            defaultBlock = val\n\n            return val\n        },\n        enumerable: true,\n    })\n\n    // Check for setting options property.\n    Object.defineProperty(this.options, 'from', {\n        set(value) {\n            if (value) {\n                _this._from = utils.toChecksumAddress(formatters.inputAddressFormatter(value))\n            }\n        },\n        get() {\n            return _this._from\n        },\n        enumerable: true,\n    })\n\n    Object.defineProperty(this.options, 'gasPrice', {\n        set(value) {\n            if (value) {\n                if (!utils.isValidNSHSN(value)) {\n                    throw errors.invalidGasPrice()\n                }\n                _this._gasPrice = value\n            }\n        },\n        get() {\n            return _this._gasPrice\n        },\n        enumerable: true,\n    })\n\n    Object.defineProperty(this.options, 'gas', {\n        set(value) {\n            if (value) {\n                if (!utils.isValidNSHSN(value)) throw errors.invalidGasLimit()\n                _this._gas = value\n            }\n        },\n        get() {\n            return _this._gas\n        },\n        enumerable: true,\n    })\n\n    Object.defineProperty(this.options, 'data', {\n        set(value) {\n            if (value) {\n                if (!utils.isHexStrict(value)) throw errors.invalidData()\n                _this._data = value\n            }\n        },\n        get() {\n            return _this._data\n        },\n        enumerable: true,\n    })\n\n    // properties\n    this.methods = {}\n    this.events = {}\n\n    this._address = null\n    this._jsonInterface = []\n\n    // set getter/setter properties\n    this.options.address = address\n    this.options.jsonInterface = jsonInterface\n}\n\nContract.setProvider = function(provider, accounts) {\n    core.packageInit(this, [provider])\n\n    this._klayAccounts = accounts\n}\n\n/**\n * Set _keyrings in contract instance.\n * When _keyrings is exsit, contract will use _keyrings instead of _klayAccounts\n *\n * @param {KeyringContainer} keyrings\n */\nContract.prototype.setKeyrings = function(keyrings) {\n    if (!(keyrings instanceof KeyringContainer)) throw new Error(`keyrings should be an instance of 'KeyringContainer'`)\n    this._keyrings = keyrings\n}\n\nContract.prototype.addAccounts = function(accounts) {\n    this._klayAccounts = accounts\n}\n\n/**\n * Get the callback and modiufy the array if necessary\n *\n * @method _getCallback\n * @param {Array} args\n * @return {Function} the callback\n */\nContract.prototype._getCallback = function getCallback(args) {\n    if (args && _.isFunction(args[args.length - 1])) {\n        return args.pop() // modify the args array!\n    }\n}\n\n/**\n * Checks that no listener with name \"newListener\" or \"removeListener\" is added.\n *\n * @method _checkListener\n * @param {String} type\n * @param {String} event\n * @return {Object} the contract instance\n */\n/**\n * this._checkListener('newListener', subOptions.event.name);\n * this._checkListener('removeListener', subOptions.event.name);\n */\nContract.prototype._checkListener = function(type, event) {\n    if (event === type) {\n        throw new Error(`The event \"${type}\" is a reserved event name, you can't use it.`)\n    }\n}\n\n/**\n * Use default values, if options are not available\n *\n * @method _getOrSetDefaultOptions\n * @param {Object} options the options gived by the user\n * @return {Object} the options with gaps filled by defaults\n */\nContract.prototype._getOrSetDefaultOptions = function getOrSetDefaultOptions(options) {\n    const gasPrice = options.gasPrice ? String(options.gasPrice) : null\n    const from = options.from ? utils.toChecksumAddress(formatters.inputAddressFormatter(options.from)) : null\n\n    options.data = options.data || this.options.data\n\n    options.from = from || this.options.from\n    options.gasPrice = gasPrice || this.options.gasPrice\n\n    // If options.gas isn't set manually, use options.gasLimit, this.options.gas instead.\n    if (typeof options.gas === 'undefined') {\n        options.gas = options.gasLimit || this.options.gas\n    }\n\n    // TODO replace with only gasLimit?\n    delete options.gasLimit\n\n    return options\n}\n\n/**\n * Should be used to encode indexed params and options to one final object\n *\n * @method _encodeEventABI\n * @param {Object} event\n * @param {Object} options\n * @return {Object} everything combined together and encoded\n */\n\n/**\n * _encodeEventABI\n * 1. options\n * options = {\n *   filter: {...},\n *   topics: [...],\n * }\n *   cf. topics\n *   - This allows you to manually set the topics for the event filter.\n *   - If given the filter property and event signature, (topic[0]) will not\n *   - be set automatically.\n *\n * 2. event\n * {\n *   anonymous: Bool,\n *   signature:\n *   name: String,\n *   inputs: [...],\n * }\n * cf) signature\n * - The signatureâ€™s hash of the event is one of the topics,\n * - unless you used the anonymous specifier to declare the event.\n * - This would mean filtering for anonymous, specific events by name is not possible.\n * - keccak256(\"burned(address,uint)\") = 0x0970ce1235167a71...\n */\nContract.prototype._encodeEventABI = function(event, options) {\n    options = options || {}\n    const filter = options.filter || {}\n    const result = {}\n\n    ;['fromBlock', 'toBlock']\n        .filter(function(f) {\n            return options[f] !== undefined\n        })\n        .forEach(function(f) {\n            result[f] = formatters.inputBlockNumberFormatter(options[f])\n        })\n\n    // use given topics\n    if (_.isArray(options.topics)) {\n        result.topics = options.topics\n        // create topics based on filter\n    } else {\n        result.topics = []\n\n        // add event signature\n        if (event && !event.anonymous && event.name !== 'ALLEVENTS') {\n            result.topics.push(event.signature)\n        }\n\n        // add event topics (indexed arguments)\n        if (event.name !== 'ALLEVENTS') {\n            const indexedTopics = event.inputs\n                .filter(i => i.indexed === true)\n                .map(i => {\n                    const value = filter[i.name]\n                    if (!value) return null\n\n                    // TODO: https://github.com/ethereum/web3.js/issues/344\n\n                    if (_.isArray(value)) {\n                        return value.map(v => abi.encodeParameter(i.type, v))\n                    }\n                    return abi.encodeParameter(i.type, value)\n                })\n\n            result.topics = result.topics.concat(indexedTopics)\n        }\n        if (!result.topics.length) delete result.topics\n    }\n    if (this.options.address) {\n        result.address = this.options.address.toLowerCase()\n    }\n\n    return result\n}\n\n/**\n * Should be used to decode indexed params and options\n *\n * @method _decodeEventABI\n * @param {Object} data\n * @return {Object} result object with decoded indexed && not indexed params\n */\n\nContract.prototype._decodeEventABI = function(data) {\n    let event = this\n\n    data.data = data.data || ''\n    data.topics = data.topics || []\n    const result = formatters.outputLogFormatter(data)\n\n    // if allEvents get the right event\n    if (event.name === 'ALLEVENTS') {\n        event = event.jsonInterface.find(function(intf) {\n            return intf.signature === data.topics[0]\n        }) || { anonymous: true }\n    }\n\n    // create empty inputs if none are present (e.g. anonymous events on allEvents)\n    event.inputs = event.inputs || []\n\n    const argTopics = event.anonymous ? data.topics : data.topics.slice(1)\n\n    result.returnValues = abi.decodeLog(event.inputs, data.data, argTopics)\n    delete result.returnValues.__length__\n\n    // add name\n    result.event = event.name\n\n    // add signature\n    result.signature = event.anonymous || !data.topics[0] ? null : data.topics[0]\n\n    // move the data and topics to \"raw\"\n    result.raw = {\n        data: result.data,\n        topics: result.topics,\n    }\n    delete result.data\n    delete result.topics\n\n    return result\n}\n\n/**\n * Encodes an ABI for a method, including signature or the method.\n * Or when constructor encodes only the constructor parameters.\n *\n * @method _encodeMethodABI\n * @param {Mixed} args the arguments to encode\n * @param {String} the encoded ABI\n */\nContract.prototype._encodeMethodABI = function _encodeMethodABI() {\n    const methodSignature = this._method.signature\n    const args = this.arguments || []\n\n    let signature = false\n    const paramsABI =\n        this._parent.options.jsonInterface\n            .filter(function(json) {\n                return (\n                    (methodSignature === 'constructor' && json.type === methodSignature) ||\n                    ((json.signature === methodSignature ||\n                        json.signature === methodSignature.replace('0x', '') ||\n                        json.name === methodSignature) &&\n                        json.type === 'function')\n                )\n            })\n            .map(function(json) {\n                const inputLength = _.isArray(json.inputs) ? json.inputs.length : 0\n\n                if (inputLength !== args.length) {\n                    throw new Error(\n                        `The number of arguments is not matching the methods required number. You need to pass ${inputLength} arguments.`\n                    )\n                }\n                if (json.type === 'function') {\n                    signature = json.signature\n                }\n                return _.isArray(json.inputs) ? json.inputs : []\n            })\n            .map(function(inputs) {\n                return abi.encodeParameters(inputs, args).replace('0x', '')\n            })[0] || ''\n\n    // return constructor\n    if (methodSignature === 'constructor') {\n        if (!this._deployData) {\n            throw new Error('The contract has no contract data option set. This is necessary to append the constructor parameters.')\n        }\n\n        return this._deployData + paramsABI\n\n        // return method\n    }\n    const returnValue = signature ? signature + paramsABI : paramsABI\n\n    if (!returnValue) {\n        throw new Error(`Couldn't find a matching contract method named \"${this._method.name}\".`)\n    } else {\n        return returnValue\n    }\n}\n\n/**\n * Decode method return values\n *\n * @method _decodeMethodReturn\n * @param {Array} outputs\n * @param {String} returnValues\n * @return {Object} decoded output return values\n */\nContract.prototype._decodeMethodReturn = function(outputs, returnValues) {\n    if (!returnValues) {\n        return null\n    }\n\n    returnValues = returnValues.length >= 2 ? returnValues.slice(2) : returnValues\n    const result = abi.decodeParameters(outputs, returnValues)\n\n    if (result.__length__ === 1) {\n        return result[0]\n    }\n    delete result.__length__\n    return result\n}\n\n/**\n * Deploys a contract and fire events based on its state: transactionHash, receipt\n *\n * All event listeners will be removed, once the last possible event is fired (\"error\", or \"receipt\")\n *\n * @method deploy\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\n\nContract.prototype.deploy = function(options, callback) {\n    options = options || {}\n\n    options.arguments = options.arguments || []\n    options = this._getOrSetDefaultOptions(options)\n\n    // return error, if no \"data\" is specified\n    if (!options.data) {\n        return utils._fireError(\n            new Error('No \"data\" specified in neither the given options, nor the default options.'),\n            null,\n            null,\n            callback\n        )\n    }\n\n    const constructor =\n        _.find(this.options.jsonInterface, function(method) {\n            return method.type === 'constructor'\n        }) || {}\n    constructor.signature = 'constructor'\n\n    return this._createTxObject.apply(\n        {\n            method: constructor,\n            parent: this,\n            deployData: options.data,\n            _klayAccounts: this.constructor._klayAccounts,\n            _keyrings: this._keyrings,\n        },\n        options.arguments\n    )\n}\n\n/**\n * Gets the event signature and outputformatters\n *\n * @method _generateEventOptions\n * @param {Object} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event options object\n */\nContract.prototype._generateEventOptions = function() {\n    const args = Array.prototype.slice.call(arguments)\n\n    // get the callback\n    const callback = this._getCallback(args)\n\n    // get the options\n    const options = _.isObject(args[args.length - 1]) ? args.pop() : {}\n\n    let event = _.isString(args[0]) ? args[0] : 'allevents'\n    event =\n        event.toLowerCase() === 'allevents'\n            ? {\n                  name: 'ALLEVENTS',\n                  jsonInterface: this.options.jsonInterface,\n              }\n            : this.options.jsonInterface.find(function(json) {\n                  return json.type === 'event' && (json.name === event || json.signature === `0x${event.replace('0x', '')}`)\n              })\n\n    if (!event) {\n        throw new Error(`Event \"${event.name}\" doesn't exist in this contract.`)\n    }\n\n    if (!utils.isAddress(this.options.address)) {\n        throw new Error(\"This contract object doesn't have address set yet, please set an address first.\")\n    }\n\n    return {\n        params: this._encodeEventABI(event, options),\n        event,\n        callback,\n    }\n}\n\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n *\n * @method clone\n * @return {Object} the event subscription\n */\nContract.prototype.clone = function(contractAddress = this.options.address) {\n    return new this.constructor(this.options.jsonInterface, contractAddress, this.options)\n}\n\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n * (Subscribes to an event and unsubscribes immediately after the first event or error. Will only fire for a single event.)\n *\n *\n * @method once\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event subscription\n *\n * myContract.once('MyEvent', {\n      filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23\n      fromBlock: 0\n  }, function(error, event){ console.log(event); });\n\n  // event output example\n  > {\n      returnValues: {\n          myIndexedParam: 20,\n          myOtherIndexedParam: '0x123456789...',\n          myNonIndexParam: 'My String'\n      },\n      raw: {\n          data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n          topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\n      },\n      event: 'MyEvent',\n      signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      logIndex: 0,\n      transactionIndex: 0,\n      transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n      blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      blockNumber: 1234,\n      address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\n  }\n */\nContract.prototype.once = function(event, options, callback) {\n    const args = Array.prototype.slice.call(arguments)\n\n    // get the callback\n    callback = this._getCallback(args)\n\n    if (!callback) {\n        throw new Error('Once requires a callback as the second parameter.')\n    }\n\n    // don't allow fromBlock\n    if (options) {\n        delete options.fromBlock\n    }\n\n    // don't return as once shouldn't provide \"on\"\n    this._on(event, options, function(err, res, sub) {\n        sub.unsubscribe()\n        if (_.isFunction(callback)) {\n            callback(err, res, sub)\n        }\n    })\n\n    return undefined\n}\n\n/**\n * Adds event listeners and creates a subscription.\n *\n * @method _on\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event subscription\n */\nContract.prototype._on = function() {\n    const subOptions = this._generateEventOptions.apply(this, arguments)\n\n    // prevent the event \"newListener\" and \"removeListener\" from being overwritten\n    this._checkListener('newListener', subOptions.event.name)\n    this._checkListener('removeListener', subOptions.event.name)\n\n    // TODO check if listener already exists? and reuse subscription if options are the same.\n\n    const subscription = new Subscription({\n        subscription: {\n            params: 1,\n            inputFormatter: [formatters.inputLogFormatter],\n            outputFormatter: this._decodeEventABI.bind(subOptions.event),\n            // DUBLICATE, also in caver-klay\n            subscriptionHandler(output) {\n                this.emit('data', output)\n\n                if (_.isFunction(this.callback)) {\n                    this.callback(null, output, this)\n                }\n            },\n        },\n        type: 'klay',\n        requestManager: this._requestManager,\n    })\n    subscription.subscribe('logs', subOptions.params, subOptions.callback || function() {})\n\n    return subscription\n}\n\n/**\n * Get past events from contracts\n *\n * @method getPastEvents\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the promievent\n */\n\n/**\n * myContract.getPastEvents('MyEvent', {\n      filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23\n      fromBlock: 0,\n      toBlock: 'latest'\n  }, function(error, events){ console.log(events); })\n  .then(function(events){\n      console.log(events) // same results as the optional callback above\n  });\n\n  > [{\n      returnValues: {\n          myIndexedParam: 20,\n          myOtherIndexedParam: '0x123456789...',\n          myNonIndexParam: 'My String'\n      },\n      raw: {\n          data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n          topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\n      },\n      event: 'MyEvent',\n      signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      logIndex: 0,\n      transactionIndex: 0,\n      transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n      blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      blockNumber: 1234,\n      address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\n  },{\n      ...\n  }]\n */\nContract.prototype.getPastEvents = function() {\n    const subOptions = this._generateEventOptions.apply(this, arguments)\n\n    let getPastLogs = new Method({\n        name: 'getPastLogs',\n        call: 'klay_getLogs',\n        params: 1,\n        inputFormatter: [formatters.inputLogFormatter],\n        outputFormatter: this._decodeEventABI.bind(subOptions.event),\n    })\n    getPastLogs.setRequestManager(this._requestManager)\n    const call = getPastLogs.buildCall()\n\n    getPastLogs = null\n\n    return call(subOptions.params, subOptions.callback)\n}\n\n/**\n * returns the an object with call, send, estimate functions\n *\n * @method _createTxObject\n * @returns {Object} an object with functions to call the methods\n */\n\nContract.prototype._createTxObject = function _createTxObject() {\n    const args = Array.prototype.slice.call(arguments)\n    const txObject = {}\n\n    if (this.method.type === 'function') {\n        txObject.call = this.parent._executeMethod.bind(txObject, 'call')\n        txObject.call.request = this.parent._executeMethod.bind(txObject, 'call', true) // to make batch requests\n    }\n\n    txObject.send = this.parent._executeMethod.bind(txObject, 'send')\n    txObject.send.request = this.parent._executeMethod.bind(txObject, 'send', true) // to make batch requests\n    txObject.encodeABI = this.parent._encodeMethodABI.bind(txObject)\n    txObject.estimateGas = this.parent._executeMethod.bind(txObject, 'estimate')\n\n    if (args && this.method.inputs && args.length !== this.method.inputs.length) {\n        if (this.nextMethod) {\n            return this.nextMethod.apply(null, args)\n        }\n        throw errors.InvalidNumberOfParams(args.length, this.method.inputs.length, this.method.name)\n    }\n\n    txObject.arguments = args || []\n    txObject._method = this.method\n    txObject._parent = this.parent\n    txObject._klayAccounts = this.parent.constructor._klayAccounts || this._klayAccounts\n    txObject._keyrings = this.parent._keyrings || this._keyrings\n\n    if (this.deployData) {\n        txObject._deployData = this.deployData\n    }\n\n    return txObject\n}\n\n/**\n * Generates the options for the execute call\n *\n * @method _processExecuteArguments\n * @param {Array} args\n * @param {Promise} defer\n */\nContract.prototype._processExecuteArguments = function _processExecuteArguments(args, defer) {\n    const processedArgs = {}\n\n    processedArgs.type = args.shift()\n\n    // get the callback\n    processedArgs.callback = this._parent._getCallback(args)\n\n    // get block number to use for call\n    if (\n        processedArgs.type === 'call' &&\n        args[args.length - 1] !== true &&\n        (_.isString(args[args.length - 1]) || isFinite(args[args.length - 1]))\n    ) {\n        processedArgs.defaultBlock = args.pop()\n    }\n\n    // get the options\n    processedArgs.options = _.isObject(args[args.length - 1]) ? args.pop() : {}\n\n    // get the generateRequest argument for batch requests\n    processedArgs.generateRequest = args[args.length - 1] === true ? args.pop() : false\n\n    processedArgs.options = this._parent._getOrSetDefaultOptions(processedArgs.options)\n    processedArgs.options.data = this.encodeABI()\n\n    // add contract address\n    if (!this._deployData && !utils.isAddress(this._parent.options.address)) {\n        throw new Error(\"This contract object doesn't have address set yet, please set an address first.\")\n    }\n\n    if (!this._deployData) {\n        processedArgs.options.to = this._parent.options.address\n    }\n\n    // return error, if no \"data\" is specified\n    if (!processedArgs.options.data) {\n        return utils._fireError(\n            new Error(\"Couldn't find a matching contract method, or the number of parameters is wrong.\"),\n            defer.eventEmitter,\n            defer.reject,\n            processedArgs.callback\n        )\n    }\n\n    return processedArgs\n}\n\n/**\n * Executes a call, transact or estimateGas on a contract function\n *\n * @method _executeMethod\n * @param {String} type the type this execute function should execute\n * @param {Boolean} makeRequest if true, it simply returns the request parameters, rather than executing it\n */\n\nContract.prototype._executeMethod = function _executeMethod() {\n    const _this = this\n    const args = this._parent._processExecuteArguments.call(this, Array.prototype.slice.call(arguments), defer)\n    var defer = utils.promiEvent(args.type !== 'send') /* eslint-disable-line no-var */\n    const klayAccounts = _this.constructor._klayAccounts || _this._klayAccounts\n    const keyrings = _this._parent._keyrings || _this._keyrings\n\n    // Not allow to specify options.gas to 0.\n    if (args.options && args.options.gas === 0) {\n        throw errors.notAllowedZeroGas()\n    }\n\n    // simple return request for batch requests\n    if (args.generateRequest) {\n        const payload = {\n            params: [formatters.inputCallFormatter.call(this._parent, args.options)],\n            callback: args.callback,\n        }\n\n        if (args.type === 'call') {\n            payload.params.push(formatters.inputDefaultBlockNumberFormatter.call(this._parent, args.defaultBlock))\n            payload.method = 'klay_call'\n            payload.format = this._parent._decodeMethodReturn.bind(null, this._method.outputs)\n        } else {\n            payload.method = 'klay_sendTransaction'\n        }\n\n        return payload\n    }\n    switch (args.type) {\n        case 'estimate':\n            const estimateGas = new Method({\n                name: 'estimateGas',\n                call: 'klay_estimateGas',\n                params: 1,\n                inputFormatter: [formatters.inputCallFormatter],\n                outputFormatter: utils.hexToNumber,\n                requestManager: _this._parent._requestManager,\n                accounts: klayAccounts, // is klay.accounts (necessary for wallet signing)\n                defaultAccount: _this._parent.defaultAccount,\n                defaultBlock: _this._parent.defaultBlock,\n            }).createFunction()\n\n            return estimateGas(args.options, args.callback)\n\n        case 'call':\n            // TODO check errors: missing \"from\" should give error on deploy and send, call ?\n\n            const call = new Method({\n                name: 'call',\n                call: 'klay_call',\n                params: 2,\n                inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter],\n                // add output formatter for decoding\n                outputFormatter(result) {\n                    return _this._parent._decodeMethodReturn(_this._method.outputs, result)\n                },\n                requestManager: _this._parent._requestManager,\n                accounts: klayAccounts, // is klay.accounts (necessary for wallet signing)\n                defaultAccount: _this._parent.defaultAccount,\n                defaultBlock: _this._parent.defaultBlock,\n            }).createFunction()\n\n            return call(args.options, args.defaultBlock, args.callback)\n\n        case 'send':\n            // return error, if no \"from\" is specified\n            if (!utils.isAddress(args.options.from)) {\n                return utils._fireError(\n                    new Error('No \"from\" address specified in neither the given options, nor the default options.'),\n                    defer.eventEmitter,\n                    defer.reject,\n                    args.callback\n                )\n            }\n\n            if (_.isBoolean(this._method.payable) && !this._method.payable && args.options.value && args.options.value > 0) {\n                return utils._fireError(\n                    new Error('Can not send value to non-payable contract method or constructor'),\n                    defer.eventEmitter,\n                    defer.reject,\n                    args.callback\n                )\n            }\n\n            // make sure receipt logs are decoded\n            const extraFormatters = {\n                receiptFormatter(receipt) {\n                    if (_.isArray(receipt.logs)) {\n                        // decode logs\n                        const events = _.map(receipt.logs, function(log) {\n                            return _this._parent._decodeEventABI.call(\n                                {\n                                    name: 'ALLEVENTS',\n                                    jsonInterface: _this._parent.options.jsonInterface,\n                                },\n                                log\n                            )\n                        })\n\n                        // make log names keys\n                        receipt.events = {}\n                        let count = 0\n                        events.forEach(function(ev) {\n                            if (ev.event) {\n                                // if > 1 of the same event, don't overwrite any existing events\n                                if (receipt.events[ev.event]) {\n                                    if (Array.isArray(receipt.events[ev.event])) {\n                                        receipt.events[ev.event].push(ev)\n                                    } else {\n                                        receipt.events[ev.event] = [receipt.events[ev.event], ev]\n                                    }\n                                } else {\n                                    receipt.events[ev.event] = ev\n                                }\n                            } else {\n                                receipt.events[count] = ev\n                                count++\n                            }\n                        })\n\n                        delete receipt.logs\n                    }\n                    return receipt\n                },\n                contractDeployFormatter(receipt) {\n                    const newContract = _this._parent.clone(receipt.contractAddress)\n                    return newContract\n                },\n            }\n\n            const sendTransaction = new Method({\n                name: 'sendTransaction',\n                call: 'klay_sendTransaction',\n                params: 1,\n                inputFormatter: [formatters.inputTransactionFormatter],\n                requestManager: _this._parent._requestManager,\n                accounts: klayAccounts, // is klay.accounts (necessary for wallet signing)\n                defaultAccount: _this._parent.defaultAccount,\n                defaultBlock: _this._parent.defaultBlock,\n                extraFormatters,\n            }).createFunction()\n\n            if (keyrings) {\n                const isExisted = keyrings.getKeyring(args.options.from)\n                if (!isExisted) {\n                    return sendTransaction(args.options, args.callback)\n                }\n\n                const sendRawTransaction = new Method({\n                    name: 'sendRawTransaction',\n                    call: 'klay_sendRawTransaction',\n                    params: 1,\n                    requestManager: _this._parent._requestManager,\n                    defaultAccount: _this._parent.defaultAccount,\n                    defaultBlock: _this._parent.defaultBlock,\n                    extraFormatters,\n                }).createFunction()\n\n                let transaction\n                if (this._deployData !== undefined) {\n                    transaction = new SmartContractDeploy(args.options)\n                } else {\n                    transaction = new SmartContractExecution(args.options)\n                }\n\n                return keyrings.sign(transaction.from, transaction).then(signedTx => {\n                    return sendRawTransaction(signedTx.getRLPEncoding())\n                })\n            }\n\n            if (args.options.type === undefined) {\n                if (this._deployData !== undefined) {\n                    args.options.type = 'SMART_CONTRACT_DEPLOY'\n                } else {\n                    args.options.type = 'SMART_CONTRACT_EXECUTION'\n                }\n            }\n\n            if (args.options.type !== 'SMART_CONTRACT_EXECUTION' && args.options.type !== 'SMART_CONTRACT_DEPLOY') {\n                throw new Error('Unsupported transaction type. Please use SMART_CONTRACT_EXECUTION or SMART_CONTRACT_DEPLOY.')\n            }\n\n            const fromInWallet = sendTransaction.method.accounts.wallet[args.options.from.toLowerCase()]\n            if (!fromInWallet || !fromInWallet.privateKey) {\n                args.options.type = 'LEGACY'\n            }\n\n            return sendTransaction(args.options, args.callback)\n    }\n}\n\nmodule.exports = Contract\n"]},"metadata":{},"sourceType":"script"}