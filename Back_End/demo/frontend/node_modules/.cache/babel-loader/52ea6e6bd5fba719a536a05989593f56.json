{"ast":null,"code":"/*\n Modifications copyright 2018 The caver-js Authors\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n This file is derived from web3.js/packages/web3-utils/src/soliditySha3.js (2019/06/12).\n Modified and improved for the caver-js development.\n */\n\n/**\n * @file soliditySha3.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nvar _ = require('lodash');\n\nvar BN = require('bn.js');\n\nvar utils = require('./utils.js');\n\nvar _elementaryName = function _elementaryName(name) {\n  if (name.startsWith('int[')) {\n    return \"int256\".concat(name.slice(3));\n  }\n\n  if (name === 'int') {\n    return 'int256';\n  }\n\n  if (name.startsWith('uint[')) {\n    return \"uint256\".concat(name.slice(4));\n  }\n\n  if (name === 'uint') {\n    return 'uint256';\n  }\n\n  if (name.startsWith('fixed[')) {\n    return \"fixed128x128\".concat(name.slice(5));\n  }\n\n  if (name === 'fixed') {\n    return 'fixed128x128';\n  }\n\n  if (name.startsWith('ufixed[')) {\n    return \"ufixed128x128\".concat(name.slice(6));\n  }\n\n  if (name === 'ufixed') {\n    return 'ufixed128x128';\n  }\n\n  return name;\n}; // Parse N from type<N>\n\n\nvar _parseTypeN = function _parseTypeN(type) {\n  var typesize = /^\\D+(\\d+).*$/.exec(type);\n  return typesize ? parseInt(typesize[1], 10) : null;\n}; // Parse N from type[<N>]\n\n\nvar _parseTypeNArray = function _parseTypeNArray(type) {\n  var arraySize = /^\\D+\\d*\\[(\\d+)\\]$/.exec(type);\n  return arraySize ? parseInt(arraySize[1], 10) : null;\n};\n\nvar _parseNumber = function _parseNumber(arg) {\n  var type = typeof arg;\n\n  if (type === 'string') {\n    if (utils.isHexStrict(arg)) {\n      return new BN(arg.replace(/0x/i, ''), 16);\n    }\n\n    return new BN(arg, 10);\n  }\n\n  if (type === 'number') {\n    return new BN(arg);\n  }\n\n  if (utils.isBigNumber(arg)) {\n    return new BN(arg.toString(10));\n  }\n\n  if (utils.isBN(arg)) {\n    return arg;\n  }\n\n  throw new Error(\"\".concat(arg, \" is not a number\"));\n};\n/* eslint-disable complexity */\n\n\nvar _solidityPack = function _solidityPack(type, value, arraySize) {\n  var size;\n  var num;\n  type = _elementaryName(type);\n\n  if (type === 'bytes') {\n    if (value.replace(/^0x/i, '').length % 2 !== 0) {\n      throw new Error(\"Invalid bytes characters \".concat(value.length));\n    }\n\n    return value;\n  }\n\n  if (type === 'string') {\n    return utils.utf8ToHex(value);\n  }\n\n  if (type === 'bool') {\n    return value ? '01' : '00';\n  }\n\n  if (type.startsWith('address')) {\n    if (arraySize) {\n      size = 64;\n    } else {\n      size = 40;\n    }\n\n    if (!utils.isAddress(value)) {\n      throw new Error(\"\".concat(value, \" is not a valid address, or the checksum is invalid.\"));\n    }\n\n    return utils.leftPad(value.toLowerCase(), size);\n  }\n\n  size = _parseTypeN(type);\n\n  if (type.startsWith('bytes')) {\n    if (!size) {\n      throw new Error('bytes[] not yet supported in solidity');\n    } // must be 32 byte slices when in an array\n\n\n    if (arraySize) {\n      size = 32;\n    }\n\n    if (size < 1 || size > 32 || size < value.replace(/^0x/i, '').length / 2) {\n      throw new Error(\"Invalid bytes\".concat(size, \" for \").concat(value));\n    }\n\n    return utils.rightPad(value, size * 2);\n  }\n\n  if (type.startsWith('uint')) {\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error(\"Invalid uint\".concat(size, \" size\"));\n    }\n\n    num = _parseNumber(value);\n\n    if (num.bitLength() > size) {\n      throw new Error(\"Supplied uint exceeds width: \".concat(size, \" vs \").concat(num.bitLength()));\n    }\n\n    if (num.lt(new BN(0))) {\n      throw new Error(\"Supplied uint \".concat(num.toString(), \" is negative\"));\n    }\n\n    return size ? utils.leftPad(num.toString('hex'), size / 8 * 2) : num;\n  }\n\n  if (type.startsWith('int')) {\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error(\"Invalid int\".concat(size, \" size\"));\n    }\n\n    num = _parseNumber(value);\n\n    if (num.bitLength() > size) {\n      throw new Error(\"Supplied int exceeds width: \".concat(size, \" vs \").concat(num.bitLength()));\n    }\n\n    if (num.lt(new BN(0))) {\n      return num.toTwos(size).toString('hex');\n    }\n\n    return size ? utils.leftPad(num.toString('hex'), size / 8 * 2) : num;\n  } // FIXME: support all other types\n\n\n  throw new Error(\"Unsupported or invalid type: \".concat(type));\n};\n/* eslint-enable complexity */\n\n/* eslint-disable complexity */\n\n\nvar _processSoliditySha3Args = function _processSoliditySha3Args(arg) {\n  if (_.isArray(arg)) {\n    throw new Error('Autodetection of array types is not supported.');\n  }\n\n  var type;\n  var value = '';\n  var hexArg;\n  var arraySize; // if type is given\n\n  if (_.isObject(arg) && (Object.prototype.hasOwnProperty.call(arg, 'v') || Object.prototype.hasOwnProperty.call(arg, 't') || Object.prototype.hasOwnProperty.call(arg, 'value') || Object.prototype.hasOwnProperty.call(arg, 'type'))) {\n    type = Object.prototype.hasOwnProperty.call(arg, 't') ? arg.t : arg.type;\n    value = Object.prototype.hasOwnProperty.call(arg, 'v') ? arg.v : arg.value; // otherwise try to guess the type\n  } else {\n    type = utils.toHex(arg, true);\n    value = utils.toHex(arg);\n\n    if (!type.startsWith('int') && !type.startsWith('uint')) {\n      type = 'bytes';\n    }\n  }\n\n  if ((type.startsWith('int') || type.startsWith('uint')) && typeof value === 'string' && !/^(-)?0x/i.test(value)) {\n    value = new BN(value);\n  } // get the array size\n\n\n  if (_.isArray(value)) {\n    arraySize = _parseTypeNArray(type);\n\n    if (arraySize && value.length !== arraySize) {\n      throw new Error(\"\".concat(type, \" is not matching the given array \").concat(JSON.stringify(value)));\n    } else {\n      arraySize = value.length;\n    }\n  }\n\n  if (_.isArray(value)) {\n    hexArg = value.map(function (val) {\n      return _solidityPack(type, val, arraySize).toString('hex').replace('0x', '');\n    });\n    return hexArg.join('');\n  }\n\n  hexArg = _solidityPack(type, value, arraySize);\n  return hexArg.toString('hex').replace('0x', '');\n};\n/* eslint-enable complexity */\n\n/**\n * Hashes solidity values to a sha3 hash using keccak 256\n *\n * @method soliditySha3\n * @return {Object} the sha3\n */\n\n\nvar soliditySha3 = function soliditySha3() {\n  var args = Array.prototype.slice.call(arguments);\n\n  var hexArgs = _.map(args, _processSoliditySha3Args);\n\n  return utils.sha3(\"0x\".concat(hexArgs.join('')));\n};\n\nmodule.exports = soliditySha3;","map":null,"metadata":{},"sourceType":"script"}