{"ast":null,"code":"var _toConsumableArray = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nvar _ = require('lodash');\n\nvar scrypt = require('scrypt-js');\n\nvar uuid = require('uuid');\n\nvar cryp = typeof global === 'undefined' ? require('crypto-browserify') : require('crypto');\n\nvar utils = require('../../../caver-utils');\n\nvar PrivateKey = require('./privateKey');\n\nvar KEY_ROLE = {\n  roleTransactionKey: 0,\n  0: 'roleTransactionKey',\n  roleAccountUpdateKey: 1,\n  1: 'roleAccountUpdateKey',\n  roleFeePayerKey: 2,\n  2: 'roleFeePayerKey',\n  roleLast: 3\n};\nvar MAXIMUM_KEY_NUM = 10;\n\nvar isMultipleKeysFormat = function isMultipleKeysFormat(keys) {\n  if (!_.isArray(keys)) return false;\n  return keys.every(function (key) {\n    return _.isString(key);\n  });\n};\n\nvar isRoleBasedKeysFormat = function isRoleBasedKeysFormat(roledBasedKeyArray) {\n  if (!_.isArray(roledBasedKeyArray)) return false;\n  if (roledBasedKeyArray.length > KEY_ROLE.roleLast) return false;\n  return roledBasedKeyArray.every(function (arr) {\n    return _.isArray(arr);\n  });\n};\n\nvar validateForSigning = function validateForSigning(hash, chainId) {\n  if (!utils.isValidHashStrict(hash)) throw new Error(\"Invalid transaction hash: \".concat(hash));\n\n  if (chainId === undefined) {\n    throw new Error(\"chainId should be defined to sign.\");\n  }\n};\n\nvar validateIndexWithKeys = function validateIndexWithKeys(index, keyLength) {\n  if (!_.isNumber(index)) throw new Error(\"Invalid type of index(\".concat(index, \"): index should be number type.\"));\n  if (index < 0) throw new Error(\"Invalid index(\".concat(index, \"): index cannot be negative.\"));\n  if (index >= keyLength) throw new Error(\"Invalid index(\".concat(index, \"): index must be less than the length of keys(\").concat(keyLength, \").\"));\n};\n\nvar decryptKey = function decryptKey(encryptedArray, password) {\n  if (!encryptedArray || encryptedArray.length === 0) return undefined;\n  var decryptedArray = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = encryptedArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var encrypted = _step.value;\n      var derivedKey = void 0;\n      var kdfparams = void 0;\n      /**\n       * Supported kdf modules are the following:\n       * 1) pbkdf2\n       * 2) scrypt\n       */\n\n      if (encrypted.kdf === 'scrypt') {\n        kdfparams = encrypted.kdfparams; // FIXME: support progress reporting callback\n\n        derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n      } else if (encrypted.kdf === 'pbkdf2') {\n        kdfparams = encrypted.kdfparams;\n\n        if (kdfparams.prf !== 'hmac-sha256') {\n          throw new Error('Unsupported parameters to PBKDF2');\n        }\n\n        derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n      } else {\n        throw new Error('Unsupported key derivation scheme');\n      }\n\n      var ciphertext = Buffer.from(encrypted.ciphertext, 'hex');\n      var mac = utils.sha3(Buffer.from([].concat(_toConsumableArray(derivedKey.slice(16, 32)), _toConsumableArray(ciphertext)))).replace('0x', '');\n\n      if (mac !== encrypted.mac) {\n        throw new Error('Key derivation failed - possibly wrong password');\n      }\n\n      var decipher = cryp.createDecipheriv(encrypted.cipher, derivedKey.slice(0, 16), Buffer.from(encrypted.cipherparams.iv, 'hex'));\n      decryptedArray.push(\"0x\".concat(Buffer.from([].concat(_toConsumableArray(decipher.update(ciphertext)), _toConsumableArray(decipher.final()))).toString('hex')));\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return decryptedArray;\n};\n\nvar encryptKey = function encryptKey(privateKey, password, options) {\n  var encryptedArray = [];\n  if (!privateKey) return encryptedArray;\n  var privateKeyArray = _.isArray(privateKey) ? privateKey : [privateKey];\n\n  for (var i = 0; i < privateKeyArray.length; i++) {\n    var salt = options.salt || cryp.randomBytes(32);\n    var iv = options.iv || cryp.randomBytes(16);\n    var derivedKey = void 0;\n    var kdf = options.kdf || 'scrypt';\n    var kdfparams = {\n      dklen: options.dklen || 32,\n      salt: salt.toString('hex')\n    };\n    /**\n     * Supported kdf modules are the following:\n     * 1) pbkdf2\n     * 2) scrypt - default\n     */\n\n    if (kdf === 'pbkdf2') {\n      kdfparams.c = options.c || 262144;\n      kdfparams.prf = 'hmac-sha256';\n      derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n    } else if (kdf === 'scrypt') {\n      // FIXME: support progress reporting callback\n      kdfparams.n = options.n || 4096; // 2048 4096 8192 16384\n\n      kdfparams.r = options.r || 8;\n      kdfparams.p = options.p || 1;\n      derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n    } else {\n      throw new Error('Unsupported kdf');\n    }\n\n    var cipher = cryp.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);\n\n    if (!cipher) {\n      throw new Error('Unsupported cipher');\n    }\n\n    var prv = privateKeyArray[i];\n    if (privateKeyArray[i] instanceof PrivateKey) prv = privateKeyArray[i].privateKey;\n    var ciphertext = Buffer.from([].concat(_toConsumableArray(cipher.update(Buffer.from(prv.replace('0x', ''), 'hex'))), _toConsumableArray(cipher.final())));\n    var mac = utils.sha3(Buffer.from([].concat(_toConsumableArray(derivedKey.slice(16, 32)), _toConsumableArray(ciphertext)))).replace('0x', '');\n    encryptedArray.push({\n      ciphertext: ciphertext.toString('hex'),\n      cipherparams: {\n        iv: iv.toString('hex')\n      },\n      cipher: options.cipher || 'aes-128-ctr',\n      kdf: kdf,\n      kdfparams: kdfparams,\n      mac: mac.toString('hex')\n    });\n  }\n\n  return encryptedArray;\n};\n\nvar formatEncrypted = function formatEncrypted(version, address, keyringOrCrypto, options) {\n  var keystore = {\n    version: version,\n    id: uuid.v4({\n      random: options.uuid || cryp.randomBytes(16)\n    }),\n    address: address.toLowerCase()\n  };\n\n  if (version === 3) {\n    keystore.crypto = keyringOrCrypto;\n  } else if (version === 4) {\n    keystore.keyring = keyringOrCrypto;\n  } else {\n    throw new Error(\"Unsupported version of keystore\");\n  }\n\n  return keystore;\n};\n\nmodule.exports = {\n  KEY_ROLE: KEY_ROLE,\n  MAXIMUM_KEY_NUM: MAXIMUM_KEY_NUM,\n  isMultipleKeysFormat: isMultipleKeysFormat,\n  isRoleBasedKeysFormat: isRoleBasedKeysFormat,\n  validateForSigning: validateForSigning,\n  validateIndexWithKeys: validateIndexWithKeys,\n  decryptKey: decryptKey,\n  encryptKey: encryptKey,\n  formatEncrypted: formatEncrypted\n};","map":null,"metadata":{},"sourceType":"script"}