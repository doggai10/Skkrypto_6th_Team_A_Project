{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n/* eslint-disable class-methods-use-this */\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nvar lodash = require('lodash');\n\nvar fs = require('fs');\n\nvar IPFSAPI = require('ipfs-api');\n\nvar multihash = require('multihashes');\n/**\n * Representing a class for uploading and loading files to IPFS.\n * @class\n */\n\n\nvar IPFS = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * Create an IPFS.\n   * @param {string} host The host url.\n   * @param {number} port The port number to use.\n   * @param {boolean} ssl With or without SSL.\n   */\n  function IPFS(host, port, ssl) {\n    _classCallCheck(this, IPFS);\n\n    if (host !== undefined && port !== undefined && ssl !== undefined) {\n      this.setIPFSNode(host, port, ssl);\n    }\n  }\n  /**\n   * sets a IPFS Node\n   *\n   * @param {string} host The host url.\n   * @param {number} port The port number to use.\n   * @param {boolean} ssl With or without SSL.\n   * @return {void}\n   */\n\n\n  _createClass(IPFS, [{\n    key: \"setIPFSNode\",\n    value: function setIPFSNode(host, port, ssl) {\n      var protocol = ssl ? 'https' : 'http';\n      this.ipfs = new IPFSAPI({\n        host: host,\n        port: port,\n        protocol: protocol\n      });\n    }\n    /**\n     * adds a file to IPFS\n     *\n     * @param {string|Buffer} data The file path string or file contents.\n     * @return {string}\n     */\n\n  }, {\n    key: \"add\",\n    value: function () {\n      var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {\n        var ret;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.ipfs) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Please set IPFS Node through 'caver.ipfs.setIPFSNode'.\");\n\n              case 2:\n                // Read file\n                if (lodash.isString(data)) data = fs.readFileSync(data);\n\n                if (lodash.isBuffer(data)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Invalid data: \".concat(data));\n\n              case 5:\n                _context.next = 7;\n                return this.ipfs.add(data);\n\n              case 7:\n                ret = _context.sent;\n                return _context.abrupt(\"return\", ret[0].hash);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function add(_x) {\n        return _add.apply(this, arguments);\n      }\n\n      return add;\n    }()\n    /**\n     * gets a file from IPFS\n     *\n     * @param {string} hash The file hash string.\n     * @return {Buffer}\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(hash) {\n        var ret;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.ipfs) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Please set IPFS Node through 'caver.ipfs.setIPFSNode'.\");\n\n              case 2:\n                _context2.next = 4;\n                return this.ipfs.cat(hash);\n\n              case 4:\n                ret = _context2.sent;\n                return _context2.abrupt(\"return\", ret);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function get(_x2) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * converts a hash to hex format.\n     *\n     * @param {string} hash The file hash string.\n     * @return {string}\n     */\n\n  }, {\n    key: \"toHex\",\n    value: function toHex(hash) {\n      var buf = multihash.fromB58String(hash);\n      return \"0x\".concat(multihash.toHexString(buf));\n    }\n    /**\n     * converts from a hex format.\n     *\n     * @param {string} hash The file hash string in hex format.\n     * @return {string}\n     */\n\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(contentHash) {\n      var hex = contentHash.substring(2);\n      var buf = multihash.fromHexString(hex);\n      return multihash.toB58String(buf);\n    }\n  }]);\n\n  return IPFS;\n}();\n\nmodule.exports = IPFS;","map":{"version":3,"sources":["/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/caver-js/packages/caver-ipfs/src/index.js"],"names":["lodash","require","fs","IPFSAPI","multihash","IPFS","host","port","ssl","undefined","setIPFSNode","protocol","ipfs","data","Error","isString","readFileSync","isBuffer","add","ret","hash","cat","buf","fromB58String","toHexString","contentHash","hex","substring","fromHexString","toB58String","module","exports"],"mappings":";;;;;;;;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMC,EAAE,GAAGD,OAAO,CAAC,IAAD,CAAlB;;AACA,IAAME,OAAO,GAAGF,OAAO,CAAC,UAAD,CAAvB;;AACA,IAAMG,SAAS,GAAGH,OAAO,CAAC,aAAD,CAAzB;AAEA;AACA;AACA;AACA;;;IACMI,I;;;AACF;AACJ;AACA;AACA;AACA;AACA;AACI,gBAAYC,IAAZ,EAAkBC,IAAlB,EAAwBC,GAAxB,EAA6B;AAAA;;AACzB,QAAIF,IAAI,KAAKG,SAAT,IAAsBF,IAAI,KAAKE,SAA/B,IAA4CD,GAAG,KAAKC,SAAxD,EAAmE;AAC/D,WAAKC,WAAL,CAAiBJ,IAAjB,EAAuBC,IAAvB,EAA6BC,GAA7B;AACH;AACJ;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;;gCACgBF,I,EAAMC,I,EAAMC,G,EAAK;AACzB,UAAMG,QAAQ,GAAGH,GAAG,GAAG,OAAH,GAAa,MAAjC;AACA,WAAKI,IAAL,GAAY,IAAIT,OAAJ,CAAY;AAAEG,QAAAA,IAAI,EAAJA,IAAF;AAAQC,QAAAA,IAAI,EAAJA,IAAR;AAAcI,QAAAA,QAAQ,EAARA;AAAd,OAAZ,CAAZ;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;;;2FACcE,I;;;;;;oBACD,KAAKD,I;;;;;sBAAY,IAAIE,KAAJ,0D;;;AAEtB;AACA,oBAAId,MAAM,CAACe,QAAP,CAAgBF,IAAhB,CAAJ,EAA2BA,IAAI,GAAGX,EAAE,CAACc,YAAH,CAAgBH,IAAhB,CAAP;;oBACtBb,MAAM,CAACiB,QAAP,CAAgBJ,IAAhB,C;;;;;sBAA6B,IAAIC,KAAJ,yBAA2BD,IAA3B,E;;;;uBAEhB,KAAKD,IAAL,CAAUM,GAAV,CAAcL,IAAd,C;;;AAAZM,gBAAAA,G;iDACCA,GAAG,CAAC,CAAD,CAAH,CAAOC,I;;;;;;;;;;;;;;;;AAGlB;AACJ;AACA;AACA;AACA;AACA;;;;;4FACcA,I;;;;;;oBACD,KAAKR,I;;;;;sBAAY,IAAIE,KAAJ,0D;;;;uBACJ,KAAKF,IAAL,CAAUS,GAAV,CAAcD,IAAd,C;;;AAAZD,gBAAAA,G;kDACCA,G;;;;;;;;;;;;;;;;AAGX;AACJ;AACA;AACA;AACA;AACA;;;;0BACUC,I,EAAM;AACR,UAAME,GAAG,GAAGlB,SAAS,CAACmB,aAAV,CAAwBH,IAAxB,CAAZ;AACA,yBAAYhB,SAAS,CAACoB,WAAV,CAAsBF,GAAtB,CAAZ;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;;4BACYG,W,EAAa;AACjB,UAAMC,GAAG,GAAGD,WAAW,CAACE,SAAZ,CAAsB,CAAtB,CAAZ;AACA,UAAML,GAAG,GAAGlB,SAAS,CAACwB,aAAV,CAAwBF,GAAxB,CAAZ;AACA,aAAOtB,SAAS,CAACyB,WAAV,CAAsBP,GAAtB,CAAP;AACH;;;;;;AAGLQ,MAAM,CAACC,OAAP,GAAiB1B,IAAjB","sourcesContent":["/* eslint-disable class-methods-use-this */\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst lodash = require('lodash')\nconst fs = require('fs')\nconst IPFSAPI = require('ipfs-api')\nconst multihash = require('multihashes')\n\n/**\n * Representing a class for uploading and loading files to IPFS.\n * @class\n */\nclass IPFS {\n    /**\n     * Create an IPFS.\n     * @param {string} host The host url.\n     * @param {number} port The port number to use.\n     * @param {boolean} ssl With or without SSL.\n     */\n    constructor(host, port, ssl) {\n        if (host !== undefined && port !== undefined && ssl !== undefined) {\n            this.setIPFSNode(host, port, ssl)\n        }\n    }\n\n    /**\n     * sets a IPFS Node\n     *\n     * @param {string} host The host url.\n     * @param {number} port The port number to use.\n     * @param {boolean} ssl With or without SSL.\n     * @return {void}\n     */\n    setIPFSNode(host, port, ssl) {\n        const protocol = ssl ? 'https' : 'http'\n        this.ipfs = new IPFSAPI({ host, port, protocol })\n    }\n\n    /**\n     * adds a file to IPFS\n     *\n     * @param {string|Buffer} data The file path string or file contents.\n     * @return {string}\n     */\n    async add(data) {\n        if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`)\n\n        // Read file\n        if (lodash.isString(data)) data = fs.readFileSync(data)\n        if (!lodash.isBuffer(data)) throw new Error(`Invalid data: ${data}`)\n\n        const ret = await this.ipfs.add(data)\n        return ret[0].hash\n    }\n\n    /**\n     * gets a file from IPFS\n     *\n     * @param {string} hash The file hash string.\n     * @return {Buffer}\n     */\n    async get(hash) {\n        if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`)\n        const ret = await this.ipfs.cat(hash)\n        return ret\n    }\n\n    /**\n     * converts a hash to hex format.\n     *\n     * @param {string} hash The file hash string.\n     * @return {string}\n     */\n    toHex(hash) {\n        const buf = multihash.fromB58String(hash)\n        return `0x${multihash.toHexString(buf)}`\n    }\n\n    /**\n     * converts from a hex format.\n     *\n     * @param {string} hash The file hash string in hex format.\n     * @return {string}\n     */\n    fromHex(contentHash) {\n        const hex = contentHash.substring(2)\n        const buf = multihash.fromHexString(hex)\n        return multihash.toB58String(buf)\n    }\n}\n\nmodule.exports = IPFS\n"]},"metadata":{},"sourceType":"script"}