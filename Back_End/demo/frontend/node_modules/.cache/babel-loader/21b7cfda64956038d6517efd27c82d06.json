{"ast":null,"code":"var _createForOfIteratorHelper = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nvar _ = require('lodash');\n\nvar AbstractKeyring = require('./abstractKeyring');\n\nvar utils = require('../../../caver-utils');\n\nvar PrivateKey = require('./privateKey');\n\nvar _require = require('./keyringHelper'),\n    KEY_ROLE = _require.KEY_ROLE;\n\nvar Account = require('../../../caver-account');\n\nvar _require2 = require('../../../caver-account/src/accountKey/accountKeyHelper'),\n    fillWeightedMultiSigOptionsForMultiSig = _require2.fillWeightedMultiSigOptionsForMultiSig;\n\nvar _require3 = require('./keyringHelper'),\n    validateForSigning = _require3.validateForSigning,\n    validateIndexWithKeys = _require3.validateIndexWithKeys,\n    encryptKey = _require3.encryptKey,\n    formatEncrypted = _require3.formatEncrypted;\n/**\n * representing a Keyring which includes `address` and `private keys`.\n * @class\n */\n\n\nvar MultipleKeyring = /*#__PURE__*/function (_AbstractKeyring) {\n  \"use strict\";\n\n  _inherits(MultipleKeyring, _AbstractKeyring);\n\n  var _super = _createSuper(MultipleKeyring);\n\n  /**\n   * creates a MultipleKeyring.\n   * @param {string} address - The address of keyring.\n   * @param {Array.<string>|Array.<PrivateKey>} keys - The keys to use in MultipleKeyring.\n   */\n  function MultipleKeyring(address, keys) {\n    var _this;\n\n    _classCallCheck(this, MultipleKeyring);\n\n    _this = _super.call(this, address);\n    _this.keys = keys;\n    return _this;\n  }\n  /**\n   * @type {Array.<PrivateKey>}\n   */\n\n\n  _createClass(MultipleKeyring, [{\n    key: \"getPublicKey\",\n\n    /**\n     * returns public key strings.\n     *\n     * @return {Array.<string>}\n     */\n    value: function getPublicKey() {\n      var publicKeys = [];\n\n      for (var i = 0; i < this.keys.length; i++) {\n        publicKeys.push(this.keys[i].getPublicKey());\n      }\n\n      return publicKeys;\n    }\n    /**\n     * returns a copied multipleKeyring instance\n     *\n     * @return {MultipleKeyring}\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new MultipleKeyring(this.address, this.keys);\n    }\n    /**\n     * signs with transactionHash with key and returns signature(s).\n     *\n     * @param {string} transactionHash The hash of transaction.\n     * @param {string|number} chainId The chainId specific to the network.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n     * @return {Array.<string>|Array.<Array.<string>>}\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(transactionHash, chainId, role, index) {\n      validateForSigning(transactionHash, chainId);\n      var keys = this.getKeyByRole(role);\n\n      if (index !== undefined) {\n        validateIndexWithKeys(index, keys.length);\n        return keys[index].sign(transactionHash, chainId);\n      }\n\n      var signatures = [];\n\n      var _iterator = _createForOfIteratorHelper(keys),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var k = _step.value;\n          signatures.push(k.sign(transactionHash, chainId));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return signatures;\n    }\n    /**\n     * signs with hashed message and returns result object that includes `signatures`, `message` and `messageHash`\n     *\n     * @param {string} message The message string to sign.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used.\n     * @return {object}\n     */\n\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(message, role, index) {\n      if (role === undefined) throw new Error(\"role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.\");\n      var messageHash = utils.hashMessage(message);\n      var keys = this.getKeyByRole(role);\n      var signatures = [];\n\n      if (index !== undefined) {\n        validateIndexWithKeys(index, keys.length);\n        signatures.push(keys[index].signMessage(messageHash));\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(keys),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var k = _step2.value;\n            signatures.push(k.signMessage(messageHash));\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return {\n        messageHash: messageHash,\n        signatures: signatures,\n        message: message\n      };\n    }\n    /**\n     * returns keys by role. If the key of the role passed as parameter is empty, the default key is returned.\n     *\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @return {Array.<PrivateKey>}\n     */\n\n  }, {\n    key: \"getKeyByRole\",\n    value: function getKeyByRole(role) {\n      if (role === undefined) throw new Error(\"role should be defined.\");\n      if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(\"Invalid role number: \".concat(role));\n      return this.keys;\n    }\n    /**\n     * returns an instance of Account.\n     *\n     * @param {WeightedMultiSigOptions} [options] The options that includes 'threshold' and 'weight'. This is only necessary when keyring use multiple private keys.\n     * @return {Account}\n     */\n\n  }, {\n    key: \"toAccount\",\n    value: function toAccount(options) {\n      if (_.isArray(options)) throw new Error(\"For AccountKeyWeightedMultiSig, options cannot be defined as an array of WeightedMultiSigOptions.\");\n      options = fillWeightedMultiSigOptionsForMultiSig(this.keys.length, options);\n      var publicKeys = this.getPublicKey();\n      return Account.createWithAccountKeyWeightedMultiSig(this.address, publicKeys, options);\n    }\n    /**\n     * encrypts a keyring and returns a keystore v4 object.\n     *\n     * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} options The options to use when encrypt a keyring. Also address can be defined specifically in options object.\n     * @return {object}\n     */\n\n    /**\n     * options can include below\n     * {\n     *   salt: ...,\n     *   iv: ...,\n     *   kdf: ...,\n     *   dklen: ...,\n     *   c: ...,\n     *   n: ...,\n     *   r: ...,\n     *   p: ...,\n     *   cipher: ...,\n     *   uuid: ...,\n     *   cipher: ...,\n     * }\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(password) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var keyring = [];\n      keyring = encryptKey(this.keys, password, options);\n      return formatEncrypted(4, this.address, keyring, options);\n    }\n  }, {\n    key: \"keys\",\n    get: function get() {\n      return this._keys;\n    },\n    set: function set(keyInput) {\n      if (keyInput === null) {\n        this._key = null;\n        return;\n      }\n\n      this._keys = formattingForKeyInKeyring(keyInput);\n    }\n  }]);\n\n  return MultipleKeyring;\n}(AbstractKeyring);\n\nmodule.exports = MultipleKeyring;\n/**\n * Format the key parameters passed by the user to create a keyring instance.\n * @param {Array.<string|PrivateKey>} keyInput The input parameter for key variable in Keyring.\n * @return {Array.<PrivateKey>}\n */\n\nfunction formattingForKeyInKeyring(keyInput) {\n  if (!_.isArray(keyInput)) {\n    throw new Error(\"Invalid parameter. The private keys to add should be defined as an array.\");\n  }\n\n  var keys = [];\n\n  for (var i = 0; i < keyInput.length; i++) {\n    keys.push(keyInput[i] instanceof PrivateKey ? keyInput[i] : new PrivateKey(keyInput[i]));\n  }\n\n  return keys;\n}","map":{"version":3,"sources":["/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/caver-js/packages/caver-wallet/src/keyring/multipleKeyring.js"],"names":["_","require","AbstractKeyring","utils","PrivateKey","KEY_ROLE","Account","fillWeightedMultiSigOptionsForMultiSig","validateForSigning","validateIndexWithKeys","encryptKey","formatEncrypted","MultipleKeyring","address","keys","publicKeys","i","length","push","getPublicKey","transactionHash","chainId","role","index","getKeyByRole","undefined","sign","signatures","k","message","Error","messageHash","hashMessage","signMessage","roleLast","options","isArray","createWithAccountKeyWeightedMultiSig","password","keyring","_keys","keyInput","_key","formattingForKeyInKeyring","module","exports"],"mappings":"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","sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst _ = require('lodash')\nconst AbstractKeyring = require('./abstractKeyring')\n\nconst utils = require('../../../caver-utils')\nconst PrivateKey = require('./privateKey')\nconst { KEY_ROLE } = require('./keyringHelper')\nconst Account = require('../../../caver-account')\nconst { fillWeightedMultiSigOptionsForMultiSig } = require('../../../caver-account/src/accountKey/accountKeyHelper')\nconst { validateForSigning, validateIndexWithKeys, encryptKey, formatEncrypted } = require('./keyringHelper')\n\n/**\n * representing a Keyring which includes `address` and `private keys`.\n * @class\n */\nclass MultipleKeyring extends AbstractKeyring {\n    /**\n     * creates a MultipleKeyring.\n     * @param {string} address - The address of keyring.\n     * @param {Array.<string>|Array.<PrivateKey>} keys - The keys to use in MultipleKeyring.\n     */\n    constructor(address, keys) {\n        super(address)\n        this.keys = keys\n    }\n\n    /**\n     * @type {Array.<PrivateKey>}\n     */\n    get keys() {\n        return this._keys\n    }\n\n    set keys(keyInput) {\n        if (keyInput === null) {\n            this._key = null\n            return\n        }\n        this._keys = formattingForKeyInKeyring(keyInput)\n    }\n\n    /**\n     * returns public key strings.\n     *\n     * @return {Array.<string>}\n     */\n    getPublicKey() {\n        const publicKeys = []\n        for (let i = 0; i < this.keys.length; i++) {\n            publicKeys.push(this.keys[i].getPublicKey())\n        }\n        return publicKeys\n    }\n\n    /**\n     * returns a copied multipleKeyring instance\n     *\n     * @return {MultipleKeyring}\n     */\n    copy() {\n        return new MultipleKeyring(this.address, this.keys)\n    }\n\n    /**\n     * signs with transactionHash with key and returns signature(s).\n     *\n     * @param {string} transactionHash The hash of transaction.\n     * @param {string|number} chainId The chainId specific to the network.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n     * @return {Array.<string>|Array.<Array.<string>>}\n     */\n    sign(transactionHash, chainId, role, index) {\n        validateForSigning(transactionHash, chainId)\n\n        const keys = this.getKeyByRole(role)\n\n        if (index !== undefined) {\n            validateIndexWithKeys(index, keys.length)\n            return keys[index].sign(transactionHash, chainId)\n        }\n\n        const signatures = []\n        for (const k of keys) {\n            signatures.push(k.sign(transactionHash, chainId))\n        }\n        return signatures\n    }\n\n    /**\n     * signs with hashed message and returns result object that includes `signatures`, `message` and `messageHash`\n     *\n     * @param {string} message The message string to sign.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used.\n     * @return {object}\n     */\n    signMessage(message, role, index) {\n        if (role === undefined) throw new Error(`role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.`)\n        const messageHash = utils.hashMessage(message)\n\n        const keys = this.getKeyByRole(role)\n\n        const signatures = []\n        if (index !== undefined) {\n            validateIndexWithKeys(index, keys.length)\n            signatures.push(keys[index].signMessage(messageHash))\n        } else {\n            for (const k of keys) {\n                signatures.push(k.signMessage(messageHash))\n            }\n        }\n        return {\n            messageHash,\n            signatures,\n            message,\n        }\n    }\n\n    /**\n     * returns keys by role. If the key of the role passed as parameter is empty, the default key is returned.\n     *\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @return {Array.<PrivateKey>}\n     */\n    getKeyByRole(role) {\n        if (role === undefined) throw new Error(`role should be defined.`)\n        if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(`Invalid role number: ${role}`)\n        return this.keys\n    }\n\n    /**\n     * returns an instance of Account.\n     *\n     * @param {WeightedMultiSigOptions} [options] The options that includes 'threshold' and 'weight'. This is only necessary when keyring use multiple private keys.\n     * @return {Account}\n     */\n    toAccount(options) {\n        if (_.isArray(options))\n            throw new Error(`For AccountKeyWeightedMultiSig, options cannot be defined as an array of WeightedMultiSigOptions.`)\n\n        options = fillWeightedMultiSigOptionsForMultiSig(this.keys.length, options)\n\n        const publicKeys = this.getPublicKey()\n        return Account.createWithAccountKeyWeightedMultiSig(this.address, publicKeys, options)\n    }\n\n    /**\n     * encrypts a keyring and returns a keystore v4 object.\n     *\n     * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} options The options to use when encrypt a keyring. Also address can be defined specifically in options object.\n     * @return {object}\n     */\n    /**\n     * options can include below\n     * {\n     *   salt: ...,\n     *   iv: ...,\n     *   kdf: ...,\n     *   dklen: ...,\n     *   c: ...,\n     *   n: ...,\n     *   r: ...,\n     *   p: ...,\n     *   cipher: ...,\n     *   uuid: ...,\n     *   cipher: ...,\n     * }\n     */\n    encrypt(password, options = {}) {\n        let keyring = []\n        keyring = encryptKey(this.keys, password, options)\n        return formatEncrypted(4, this.address, keyring, options)\n    }\n}\n\nmodule.exports = MultipleKeyring\n\n/**\n * Format the key parameters passed by the user to create a keyring instance.\n * @param {Array.<string|PrivateKey>} keyInput The input parameter for key variable in Keyring.\n * @return {Array.<PrivateKey>}\n */\nfunction formattingForKeyInKeyring(keyInput) {\n    if (!_.isArray(keyInput)) {\n        throw new Error(`Invalid parameter. The private keys to add should be defined as an array.`)\n    }\n\n    const keys = []\n    for (let i = 0; i < keyInput.length; i++) {\n        keys.push(keyInput[i] instanceof PrivateKey ? keyInput[i] : new PrivateKey(keyInput[i]))\n    }\n\n    return keys\n}\n"]},"metadata":{},"sourceType":"script"}