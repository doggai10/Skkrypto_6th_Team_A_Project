{"ast":null,"code":"var _createForOfIteratorHelper = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nvar _ = require('lodash');\n\nvar RLP = require('eth-lib/lib/rlp');\n\nvar Hash = require('eth-lib/lib/hash');\n\nvar Bytes = require('eth-lib/lib/bytes');\n\nvar TransactionHasher = require('../transactionHasher/transactionHasher');\n\nvar AbstractTransaction = require('./abstractTransaction');\n\nvar _require = require('../transactionHelper/transactionHelper'),\n    refineSignatures = _require.refineSignatures,\n    typeDetectionFromRLPEncoding = _require.typeDetectionFromRLPEncoding;\n\nvar Keyring = require('../../../caver-wallet/src/keyring/keyringFactory');\n\nvar AbstractKeyring = require('../../../caver-wallet/src/keyring/abstractKeyring');\n\nvar _require2 = require('../../../caver-wallet/src/keyring/keyringHelper'),\n    KEY_ROLE = _require2.KEY_ROLE;\n\nvar utils = require('../../../caver-utils/src');\n\nvar SignatureData = require('../../../caver-wallet/src/keyring/signatureData');\n/**\n * Abstract class that implements common logic for each fee delegated transaction type.\n * @class\n */\n\n\nvar AbstractFeeDelegatedTransaction = /*#__PURE__*/function (_AbstractTransaction) {\n  \"use strict\";\n\n  _inherits(AbstractFeeDelegatedTransaction, _AbstractTransaction);\n\n  var _super = _createSuper(AbstractFeeDelegatedTransaction);\n\n  /**\n   * Abstract class that implements common logic for each fee-delegated transaction type.\n   * In this constructor, feePayer and feePayerSignatures are set as transaction member variables.\n   *\n   * @constructor\n   * @param {string} typeString - The type string of transaction.\n   * @param {object} createTxObj - The parameters to create an instance of transaction.\n   */\n  function AbstractFeeDelegatedTransaction(typeString, createTxObj) {\n    var _this;\n\n    _classCallCheck(this, AbstractFeeDelegatedTransaction);\n\n    _this = _super.call(this, typeString, createTxObj);\n    _this.feePayer = createTxObj.feePayer;\n    _this.feePayerSignatures = createTxObj.feePayerSignatures || [];\n    return _this;\n  }\n  /**\n   * @type {string}\n   */\n\n\n  _createClass(AbstractFeeDelegatedTransaction, [{\n    key: \"signAsFeePayer\",\n\n    /**\n     * Signs to the transaction with private key(s) in `key` as a fee payer.\n     * @async\n     * @param {Keyring|string} key - The instance of Keyring, private key string or KlaytnWalletKey string.\n     * @param {number} [index] - The index of private key to use. If index is undefined, all private keys in keyring will be used.\n     * @param {function} [hasher] - The function to get the transaction hash.\n     * @return {Transaction}\n     */\n    value: function () {\n      var _signAsFeePayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(key, index) {\n        var hasher,\n            keyring,\n            hash,\n            sig,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                hasher = _args.length > 2 && _args[2] !== undefined ? _args[2] : TransactionHasher.getHashForFeePayerSignature;\n\n                // User parameter input cases\n                // (key) / (key index) / (key hasher) / (key index hasher)\n                if (_.isFunction(index)) {\n                  hasher = index;\n                  index = undefined;\n                }\n\n                keyring = key;\n\n                if (_.isString(key)) {\n                  keyring = Keyring.createFromPrivateKey(key);\n                }\n\n                if (keyring instanceof AbstractKeyring) {\n                  _context.next = 6;\n                  break;\n                }\n\n                throw new Error(\"Unsupported key type. The key parameter of the signAsFeePayer must be a single private key string, KlaytnWalletKey string, or Keyring instance.\");\n\n              case 6:\n                if (!this.feePayer || this.feePayer === '0x') this.feePayer = keyring.address;\n\n                if (!(this.feePayer.toLowerCase() !== keyring.address.toLowerCase())) {\n                  _context.next = 9;\n                  break;\n                }\n\n                throw new Error(\"The feePayer address of the transaction is different with the address of the keyring to use.\");\n\n              case 9:\n                _context.next = 11;\n                return this.fillTransaction();\n\n              case 11:\n                hash = hasher(this);\n                sig = keyring.sign(hash, this.chainId, KEY_ROLE.roleFeePayerKey, index);\n                this.appendFeePayerSignatures(sig);\n                return _context.abrupt(\"return\", this);\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function signAsFeePayer(_x, _x2) {\n        return _signAsFeePayer.apply(this, arguments);\n      }\n\n      return signAsFeePayer;\n    }()\n    /**\n     * Appends feePayerSignatures to the transaction.\n     *\n     * @param {SignatureData|Array.<SignatureData>|Array.<string>|Array.<Array.<string>>} signatures - An array of feePayerSignatures to append to the transaction.\n     *                                                      One feePayerSignature can be defined in the form of a one-dimensional array or two-dimensional array,\n     *                                                      and more than one feePayerSignatures should be defined in the form of a two-dimensional array.\n     */\n\n  }, {\n    key: \"appendFeePayerSignatures\",\n    value: function appendFeePayerSignatures(signatures) {\n      var sig = signatures;\n      if (_.isString(sig)) sig = utils.resolveSignature(sig);\n      if (sig instanceof SignatureData) sig = [sig];\n      if (!_.isArray(sig)) throw new Error(\"Failed to append signatures: invalid signatures format \".concat(sig));\n      if (_.isString(sig[0])) sig = [sig];\n      this.feePayerSignatures = this.feePayerSignatures.concat(sig);\n    }\n    /**\n     * Combines RLP-encoded transactions (rawTransaction) to the transaction from RLP-encoded transaction strings and returns a single transaction with all signatures combined.\n     * When combining the signatures into a transaction instance,\n     * an error is thrown if the decoded transaction contains different value except signatures.\n     *\n     * @param {Array.<string>} rlpEncodedTxs - An array of RLP-encoded transaction strings.\n     * @return {string}\n     */\n\n  }, {\n    key: \"combineSignedRawTransactions\",\n    value: function combineSignedRawTransactions(rlpEncodedTxs) {\n      if (!_.isArray(rlpEncodedTxs)) throw new Error(\"The parameter must be an array of RLP encoded transaction strings.\"); // If the signatures are empty, there may be an undefined member variable.\n      // In this case, the empty information is filled with the decoded result.\n\n      var fillVariables = false;\n      if (utils.isEmptySig(this.signatures) || utils.isEmptySig(this.feePayerSignatures)) fillVariables = true;\n\n      var _iterator = _createForOfIteratorHelper(rlpEncodedTxs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var encoded = _step.value;\n          var type = typeDetectionFromRLPEncoding(encoded);\n          if (this.type !== type) throw new Error(\"Transaction type mismatch: Signatures from different transactions cannot be combined.\");\n          var decoded = this.constructor.decode(encoded); // Signatures can only be combined for the same transaction.\n          // Therefore, compare whether the decoded transaction is the same as this.\n\n          for (var k in decoded) {\n            if (k === '_signatures' || k === '_feePayerSignatures') continue;\n\n            if (k === '_feePayer') {\n              if ((decoded[k] !== '0x' || this[k] === '0x') && fillVariables) this[k] = decoded[k];\n              if (decoded[k] === '0x') continue;\n            }\n\n            if (this[k] === undefined && fillVariables) this[k] = decoded[k];\n            var differentTxError = \"Transactions containing different information cannot be combined.\"; // Compare with the RLP-encoded accountKey string, because 'account' is an object.\n\n            if (k === '_account') {\n              if (this[k].getRLPEncodingAccountKey() !== decoded[k].getRLPEncodingAccountKey()) throw new Error(differentTxError);\n              continue;\n            }\n\n            if (this[k] !== decoded[k]) throw new Error(differentTxError);\n          }\n\n          this.appendSignatures(decoded.signatures);\n          this.appendFeePayerSignatures(decoded.feePayerSignatures);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return this.getRLPEncoding();\n    }\n    /**\n     * Returns a senderTxHash of transaction\n     *\n     * @return {string}\n     */\n\n  }, {\n    key: \"getSenderTxHash\",\n    value: function getSenderTxHash() {\n      var rlpEncoded = this.getRLPEncoding();\n      var type = rlpEncoded.slice(0, 4);\n      var typeDetached = \"0x\".concat(rlpEncoded.slice(4));\n      var data = RLP.decode(typeDetached);\n      return Hash.keccak256(type + RLP.encode(data.slice(0, data.length - 2)).slice(2));\n    }\n    /**\n     * Returns an RLP-encoded transaction string for making signature as a fee payer\n     *\n     * @return {string}\n     */\n\n  }, {\n    key: \"getRLPEncodingForFeePayerSignature\",\n    value: function getRLPEncodingForFeePayerSignature() {\n      return RLP.encode([this.getCommonRLPEncodingForSignature(), this.feePayer, Bytes.fromNat(this.chainId), '0x', '0x']);\n    }\n  }, {\n    key: \"feePayer\",\n    get: function get() {\n      return this._feePayer;\n    },\n    set: function set(f) {\n      if (f === undefined) f = '0x';\n      if (f !== '0x' && !utils.isAddress(f)) throw new Error(\"Invalid address of fee payer: \".concat(f));\n      this._feePayer = f.toLowerCase();\n    }\n    /**\n     * @type {Array.<Array.<string>>}\n     */\n\n  }, {\n    key: \"feePayerSignatures\",\n    get: function get() {\n      return this._feePayerSignatures;\n    },\n    set: function set(sigs) {\n      this._feePayerSignatures = refineSignatures(sigs);\n    }\n  }]);\n\n  return AbstractFeeDelegatedTransaction;\n}(AbstractTransaction);\n\nmodule.exports = AbstractFeeDelegatedTransaction;","map":{"version":3,"sources":["/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/caver-js/packages/caver-transaction/src/transactionTypes/abstractFeeDelegatedTransaction.js"],"names":["_","require","RLP","Hash","Bytes","TransactionHasher","AbstractTransaction","refineSignatures","typeDetectionFromRLPEncoding","Keyring","AbstractKeyring","KEY_ROLE","utils","SignatureData","AbstractFeeDelegatedTransaction","typeString","createTxObj","feePayer","feePayerSignatures","key","index","hasher","getHashForFeePayerSignature","isFunction","undefined","keyring","isString","createFromPrivateKey","Error","address","toLowerCase","fillTransaction","hash","sig","sign","chainId","roleFeePayerKey","appendFeePayerSignatures","signatures","resolveSignature","isArray","concat","rlpEncodedTxs","fillVariables","isEmptySig","encoded","type","decoded","constructor","decode","k","differentTxError","getRLPEncodingAccountKey","appendSignatures","getRLPEncoding","rlpEncoded","slice","typeDetached","data","keccak256","encode","length","getCommonRLPEncodingForSignature","fromNat","_feePayer","f","isAddress","_feePayerSignatures","sigs","module","exports"],"mappings":"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","sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst _ = require('lodash')\nconst RLP = require('eth-lib/lib/rlp')\nconst Hash = require('eth-lib/lib/hash')\nconst Bytes = require('eth-lib/lib/bytes')\nconst TransactionHasher = require('../transactionHasher/transactionHasher')\nconst AbstractTransaction = require('./abstractTransaction')\nconst { refineSignatures, typeDetectionFromRLPEncoding } = require('../transactionHelper/transactionHelper')\nconst Keyring = require('../../../caver-wallet/src/keyring/keyringFactory')\nconst AbstractKeyring = require('../../../caver-wallet/src/keyring/abstractKeyring')\nconst { KEY_ROLE } = require('../../../caver-wallet/src/keyring/keyringHelper')\nconst utils = require('../../../caver-utils/src')\nconst SignatureData = require('../../../caver-wallet/src/keyring/signatureData')\n\n/**\n * Abstract class that implements common logic for each fee delegated transaction type.\n * @class\n */\nclass AbstractFeeDelegatedTransaction extends AbstractTransaction {\n    /**\n     * Abstract class that implements common logic for each fee-delegated transaction type.\n     * In this constructor, feePayer and feePayerSignatures are set as transaction member variables.\n     *\n     * @constructor\n     * @param {string} typeString - The type string of transaction.\n     * @param {object} createTxObj - The parameters to create an instance of transaction.\n     */\n    constructor(typeString, createTxObj) {\n        super(typeString, createTxObj)\n        this.feePayer = createTxObj.feePayer\n        this.feePayerSignatures = createTxObj.feePayerSignatures || []\n    }\n\n    /**\n     * @type {string}\n     */\n    get feePayer() {\n        return this._feePayer\n    }\n\n    set feePayer(f) {\n        if (f === undefined) f = '0x'\n        if (f !== '0x' && !utils.isAddress(f)) throw new Error(`Invalid address of fee payer: ${f}`)\n\n        this._feePayer = f.toLowerCase()\n    }\n\n    /**\n     * @type {Array.<Array.<string>>}\n     */\n    get feePayerSignatures() {\n        return this._feePayerSignatures\n    }\n\n    set feePayerSignatures(sigs) {\n        this._feePayerSignatures = refineSignatures(sigs)\n    }\n\n    /**\n     * Signs to the transaction with private key(s) in `key` as a fee payer.\n     * @async\n     * @param {Keyring|string} key - The instance of Keyring, private key string or KlaytnWalletKey string.\n     * @param {number} [index] - The index of private key to use. If index is undefined, all private keys in keyring will be used.\n     * @param {function} [hasher] - The function to get the transaction hash.\n     * @return {Transaction}\n     */\n    async signAsFeePayer(key, index, hasher = TransactionHasher.getHashForFeePayerSignature) {\n        // User parameter input cases\n        // (key) / (key index) / (key hasher) / (key index hasher)\n        if (_.isFunction(index)) {\n            hasher = index\n            index = undefined\n        }\n\n        let keyring = key\n        if (_.isString(key)) {\n            keyring = Keyring.createFromPrivateKey(key)\n        }\n        if (!(keyring instanceof AbstractKeyring))\n            throw new Error(\n                `Unsupported key type. The key parameter of the signAsFeePayer must be a single private key string, KlaytnWalletKey string, or Keyring instance.`\n            )\n\n        if (!this.feePayer || this.feePayer === '0x') this.feePayer = keyring.address\n        if (this.feePayer.toLowerCase() !== keyring.address.toLowerCase())\n            throw new Error(`The feePayer address of the transaction is different with the address of the keyring to use.`)\n\n        await this.fillTransaction()\n        const hash = hasher(this)\n        const sig = keyring.sign(hash, this.chainId, KEY_ROLE.roleFeePayerKey, index)\n\n        this.appendFeePayerSignatures(sig)\n\n        return this\n    }\n\n    /**\n     * Appends feePayerSignatures to the transaction.\n     *\n     * @param {SignatureData|Array.<SignatureData>|Array.<string>|Array.<Array.<string>>} signatures - An array of feePayerSignatures to append to the transaction.\n     *                                                      One feePayerSignature can be defined in the form of a one-dimensional array or two-dimensional array,\n     *                                                      and more than one feePayerSignatures should be defined in the form of a two-dimensional array.\n     */\n    appendFeePayerSignatures(signatures) {\n        let sig = signatures\n        if (_.isString(sig)) sig = utils.resolveSignature(sig)\n        if (sig instanceof SignatureData) sig = [sig]\n\n        if (!_.isArray(sig)) throw new Error(`Failed to append signatures: invalid signatures format ${sig}`)\n\n        if (_.isString(sig[0])) sig = [sig]\n\n        this.feePayerSignatures = this.feePayerSignatures.concat(sig)\n    }\n\n    /**\n     * Combines RLP-encoded transactions (rawTransaction) to the transaction from RLP-encoded transaction strings and returns a single transaction with all signatures combined.\n     * When combining the signatures into a transaction instance,\n     * an error is thrown if the decoded transaction contains different value except signatures.\n     *\n     * @param {Array.<string>} rlpEncodedTxs - An array of RLP-encoded transaction strings.\n     * @return {string}\n     */\n    combineSignedRawTransactions(rlpEncodedTxs) {\n        if (!_.isArray(rlpEncodedTxs)) throw new Error(`The parameter must be an array of RLP encoded transaction strings.`)\n\n        // If the signatures are empty, there may be an undefined member variable.\n        // In this case, the empty information is filled with the decoded result.\n        let fillVariables = false\n        if (utils.isEmptySig(this.signatures) || utils.isEmptySig(this.feePayerSignatures)) fillVariables = true\n\n        for (const encoded of rlpEncodedTxs) {\n            const type = typeDetectionFromRLPEncoding(encoded)\n            if (this.type !== type) throw new Error(`Transaction type mismatch: Signatures from different transactions cannot be combined.`)\n\n            const decoded = this.constructor.decode(encoded)\n\n            // Signatures can only be combined for the same transaction.\n            // Therefore, compare whether the decoded transaction is the same as this.\n            for (const k in decoded) {\n                if (k === '_signatures' || k === '_feePayerSignatures') continue\n                if (k === '_feePayer') {\n                    if ((decoded[k] !== '0x' || this[k] === '0x') && fillVariables) this[k] = decoded[k]\n                    if (decoded[k] === '0x') continue\n                }\n\n                if (this[k] === undefined && fillVariables) this[k] = decoded[k]\n\n                const differentTxError = `Transactions containing different information cannot be combined.`\n\n                // Compare with the RLP-encoded accountKey string, because 'account' is an object.\n                if (k === '_account') {\n                    if (this[k].getRLPEncodingAccountKey() !== decoded[k].getRLPEncodingAccountKey()) throw new Error(differentTxError)\n                    continue\n                }\n\n                if (this[k] !== decoded[k]) throw new Error(differentTxError)\n            }\n\n            this.appendSignatures(decoded.signatures)\n            this.appendFeePayerSignatures(decoded.feePayerSignatures)\n        }\n\n        return this.getRLPEncoding()\n    }\n\n    /**\n     * Returns a senderTxHash of transaction\n     *\n     * @return {string}\n     */\n    getSenderTxHash() {\n        const rlpEncoded = this.getRLPEncoding()\n        const type = rlpEncoded.slice(0, 4)\n        const typeDetached = `0x${rlpEncoded.slice(4)}`\n\n        const data = RLP.decode(typeDetached)\n\n        return Hash.keccak256(type + RLP.encode(data.slice(0, data.length - 2)).slice(2))\n    }\n\n    /**\n     * Returns an RLP-encoded transaction string for making signature as a fee payer\n     *\n     * @return {string}\n     */\n    getRLPEncodingForFeePayerSignature() {\n        return RLP.encode([this.getCommonRLPEncodingForSignature(), this.feePayer, Bytes.fromNat(this.chainId), '0x', '0x'])\n    }\n}\n\nmodule.exports = AbstractFeeDelegatedTransaction\n"]},"metadata":{},"sourceType":"script"}