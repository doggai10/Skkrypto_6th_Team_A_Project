{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nvar _ = require('lodash');\n\nvar Keyring = require('./keyring/keyringFactory');\n\nvar AbstractKeyring = require('./keyring/abstractKeyring');\n\nvar utils = require('../../caver-utils/src');\n/**\n * representing a Keyring container which manages keyrings.\n * @class\n */\n\n\nvar KeyringContainer = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * creates a keyringContainer.\n   * @param {Array.<Keyring>} keyrings - The keyrings to be managed in KeyringContainer.\n   */\n  function KeyringContainer(keyrings) {\n    _classCallCheck(this, KeyringContainer);\n\n    keyrings = keyrings || [];\n    this._addressKeyringMap = new Map(); // add keyrings to keyringContainer\n\n    var _iterator = _createForOfIteratorHelper(keyrings),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var keyring = _step.value;\n        this.add(keyring);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  /**\n   * @type {number}\n   */\n\n\n  _createClass(KeyringContainer, [{\n    key: \"generate\",\n\n    /**\n     * generates keyrings in the keyringContainer with randomly generated key pairs.\n     *\n     * @param {number} numberOfKeyrings The number of keyrings to create.\n     * @param {string} [entropy] A random string to increase entropy. If undefined, a random string will be generated using randomHex.\n     * @return {Array.<string>}\n     */\n    value: function generate(numberOfKeyrings, entropy) {\n      var addresses = [];\n\n      for (var i = 0; i < numberOfKeyrings; ++i) {\n        addresses.push(this.add(Keyring.generate(entropy)).address);\n      }\n\n      return addresses;\n    }\n    /**\n     * creates a keyring instance with given parameters and adds it to the keyringContainer.\n     * KeyringContainer manages Keyring instance using Map <string:Keyring> which has address as key value.\n     *\n     * @param {string} address The address of the keyring.\n     * @param {string|Array.<string>|Array.<Array.<string>>} key Private key string(s) to use in keyring. If different keys are used for each role, key must be defined as a two-dimensional array.\n     * @return {Keyring}\n     */\n\n  }, {\n    key: \"newKeyring\",\n    value: function newKeyring(address, key) {\n      // The format of key parameter can be\n      // 1. single private key string   => `0x{private key}`\n      // 2. multiple private key string =>[`0x{private key}`, `0x{private key}`, ...]\n      // 3. role based private keys     => [[`0x{private key}`, `0x{private key}`, ...], [], [`0x{private key}`]]\n      var keyring;\n      if (_.isString(key)) keyring = Keyring.createWithSingleKey(address, key);\n\n      if (_.isArray(key)) {\n        if (key.length === 0) throw new Error(\"Insufficient private key information: Empty array\");\n\n        if (_.isArray(key[0])) {\n          keyring = Keyring.createWithRoleBasedKey(address, key);\n        } else {\n          keyring = Keyring.createWithMultipleKey(address, key);\n        }\n      }\n\n      if (!(keyring instanceof AbstractKeyring)) throw new Error(\"Unsupported type value: \".concat(key, \" (type:\").concat(typeof key, \")\"));\n      return this.add(keyring);\n    }\n    /**\n     * updates the keyring inside the keyringContainer.\n     * Query the keyring to be updated from keyringContainer with the keyring's address,\n     * and an error occurs when the keyring is not found in the keyringContainer.\n     *\n     * @param {Keyring} keyring The keyring with new key.\n     * @return {Keyring}\n     */\n\n  }, {\n    key: \"updateKeyring\",\n    value: function updateKeyring(keyring) {\n      var founded = this._addressKeyringMap.get(keyring.address.toLowerCase());\n\n      if (founded === undefined) throw new Error(\"Failed to find keyring to update\");\n      this.remove(founded.address);\n      this.add(keyring);\n      return keyring;\n    }\n    /**\n     * Get the keyring in container corresponding to the address\n     *\n     * @param {string} address The address of keyring to query.\n     * @return {Keyring}\n     */\n\n  }, {\n    key: \"getKeyring\",\n    value: function getKeyring(address) {\n      if (!utils.isAddress(address)) throw new Error(\"Invalid address \".concat(address, \". To get keyring from wallet, you need to pass a valid address string as a parameter.\"));\n\n      var founded = this._addressKeyringMap.get(address.toLowerCase());\n\n      return founded;\n    }\n    /**\n     * adds a keyring to the keyringContainer.\n     *\n     * @param {Keyring} keyring A keyring instance to add to keyringContainer.\n     * @return {Keyring}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(keyring) {\n      if (this._addressKeyringMap.get(keyring.address.toLowerCase()) !== undefined) throw new Error(\"Duplicate Account \".concat(keyring.address, \". Please use updateKeyring() instead.\"));\n      var keyringToAdd = keyring.copy();\n\n      this._addressKeyringMap.set(keyringToAdd.address.toLowerCase(), keyringToAdd);\n\n      return keyringToAdd;\n    }\n    /**\n     * deletes the keyring that associates with the given address from keyringContainer.\n     *\n     * @param {string} address An address of the keyring to be deleted in keyringContainer.\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(address) {\n      var keyringToRemove;\n\n      if (utils.isAddress(address)) {\n        keyringToRemove = this.getKeyring(address);\n      } else {\n        throw new Error(\"To remove the keyring, the first parameter should be an address string.\");\n      }\n\n      if (keyringToRemove === undefined) return false; // deallocate keyring object created for keyringContainer\n\n      keyringToRemove.keys = null;\n\n      this._addressKeyringMap.delete(keyringToRemove.address.toLowerCase());\n\n      return true;\n    }\n    /**\n     * signs with data and returns the result object that includes `signature`, `message` and `messageHash`\n     *\n     * @param {string} address An address of keyring in keyringContainer.\n     * @param {string} data The data string to sign.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] An index of key to use for signing.\n     * @return {object}\n     */\n\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(address, data, role, index) {\n      var keyring = this.getKeyring(address);\n      if (keyring === undefined) throw new Error(\"Failed to find keyring from wallet with \".concat(address));\n      return keyring.signMessage(data, role, index);\n    }\n    /**\n     * signs the transaction using one key and return the transactionHash\n     *\n     * @param {string} address An address of keyring in keyringContainer.\n     * @param {Transaction} transaction A transaction object.\n     * @param {number} [index] An index of key to use for signing. If index is undefined, all private keys in keyring will be used.\n     * @param {function} [hasher] A function to return hash of transaction.\n     * @return {Transaction}\n     */\n\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address, transaction, index, hasher) {\n        var keyring, signed;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                keyring = this.getKeyring(address);\n\n                if (!(keyring === undefined)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Failed to find keyring from wallet with \".concat(address));\n\n              case 3:\n                _context.next = 5;\n                return transaction.sign(keyring, index, hasher);\n\n              case 5:\n                signed = _context.sent;\n                return _context.abrupt(\"return\", signed);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sign(_x, _x2, _x3, _x4) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n    /**\n     * signs the transaction as a fee payer using one key and return the transactionHash\n     *\n     * @param {string} address An address of keyring in keyringContainer.\n     * @param {Transaction} transaction A transaction object. This should be `FEE_DELEGATED` type.\n     * @param {number} [index] An index of key to use for signing. If index is undefined, all private keys in keyring will be used.\n     * @param {function} [hasher] A function to return hash of transaction.\n     * @return {Transaction}\n     */\n\n  }, {\n    key: \"signAsFeePayer\",\n    value: function () {\n      var _signAsFeePayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(address, transaction, index, hasher) {\n        var keyring, signed;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                keyring = this.getKeyring(address);\n\n                if (!(keyring === undefined)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Failed to find keyring from wallet with \".concat(address));\n\n              case 3:\n                _context2.next = 5;\n                return transaction.signAsFeePayer(keyring, index, hasher);\n\n              case 5:\n                signed = _context2.sent;\n                return _context2.abrupt(\"return\", signed);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function signAsFeePayer(_x5, _x6, _x7, _x8) {\n        return _signAsFeePayer.apply(this, arguments);\n      }\n\n      return signAsFeePayer;\n    }()\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._addressKeyringMap.size;\n    }\n  }]);\n\n  return KeyringContainer;\n}();\n\nmodule.exports = KeyringContainer;","map":{"version":3,"sources":["/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/caver-js/packages/caver-wallet/src/index.js"],"names":["_","require","Keyring","AbstractKeyring","utils","KeyringContainer","keyrings","_addressKeyringMap","Map","keyring","add","numberOfKeyrings","entropy","addresses","i","push","generate","address","key","isString","createWithSingleKey","isArray","length","Error","createWithRoleBasedKey","createWithMultipleKey","founded","get","toLowerCase","undefined","remove","isAddress","keyringToAdd","copy","set","keyringToRemove","getKeyring","keys","delete","data","role","index","signMessage","transaction","hasher","sign","signed","signAsFeePayer","size","module","exports"],"mappings":"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","sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst _ = require('lodash')\nconst Keyring = require('./keyring/keyringFactory')\nconst AbstractKeyring = require('./keyring/abstractKeyring')\nconst utils = require('../../caver-utils/src')\n\n/**\n * representing a Keyring container which manages keyrings.\n * @class\n */\nclass KeyringContainer {\n    /**\n     * creates a keyringContainer.\n     * @param {Array.<Keyring>} keyrings - The keyrings to be managed in KeyringContainer.\n     */\n    constructor(keyrings) {\n        keyrings = keyrings || []\n        this._addressKeyringMap = new Map()\n\n        // add keyrings to keyringContainer\n        for (const keyring of keyrings) {\n            this.add(keyring)\n        }\n    }\n\n    /**\n     * @type {number}\n     */\n    get length() {\n        return this._addressKeyringMap.size\n    }\n\n    /**\n     * generates keyrings in the keyringContainer with randomly generated key pairs.\n     *\n     * @param {number} numberOfKeyrings The number of keyrings to create.\n     * @param {string} [entropy] A random string to increase entropy. If undefined, a random string will be generated using randomHex.\n     * @return {Array.<string>}\n     */\n    generate(numberOfKeyrings, entropy) {\n        const addresses = []\n        for (let i = 0; i < numberOfKeyrings; ++i) {\n            addresses.push(this.add(Keyring.generate(entropy)).address)\n        }\n        return addresses\n    }\n\n    /**\n     * creates a keyring instance with given parameters and adds it to the keyringContainer.\n     * KeyringContainer manages Keyring instance using Map <string:Keyring> which has address as key value.\n     *\n     * @param {string} address The address of the keyring.\n     * @param {string|Array.<string>|Array.<Array.<string>>} key Private key string(s) to use in keyring. If different keys are used for each role, key must be defined as a two-dimensional array.\n     * @return {Keyring}\n     */\n    newKeyring(address, key) {\n        // The format of key parameter can be\n        // 1. single private key string   => `0x{private key}`\n        // 2. multiple private key string =>[`0x{private key}`, `0x{private key}`, ...]\n        // 3. role based private keys     => [[`0x{private key}`, `0x{private key}`, ...], [], [`0x{private key}`]]\n\n        let keyring\n\n        if (_.isString(key)) keyring = Keyring.createWithSingleKey(address, key)\n\n        if (_.isArray(key)) {\n            if (key.length === 0) throw new Error(`Insufficient private key information: Empty array`)\n            if (_.isArray(key[0])) {\n                keyring = Keyring.createWithRoleBasedKey(address, key)\n            } else {\n                keyring = Keyring.createWithMultipleKey(address, key)\n            }\n        }\n\n        if (!(keyring instanceof AbstractKeyring)) throw new Error(`Unsupported type value: ${key} (type:${typeof key})`)\n\n        return this.add(keyring)\n    }\n\n    /**\n     * updates the keyring inside the keyringContainer.\n     * Query the keyring to be updated from keyringContainer with the keyring's address,\n     * and an error occurs when the keyring is not found in the keyringContainer.\n     *\n     * @param {Keyring} keyring The keyring with new key.\n     * @return {Keyring}\n     */\n    updateKeyring(keyring) {\n        const founded = this._addressKeyringMap.get(keyring.address.toLowerCase())\n        if (founded === undefined) throw new Error(`Failed to find keyring to update`)\n\n        this.remove(founded.address)\n        this.add(keyring)\n\n        return keyring\n    }\n\n    /**\n     * Get the keyring in container corresponding to the address\n     *\n     * @param {string} address The address of keyring to query.\n     * @return {Keyring}\n     */\n    getKeyring(address) {\n        if (!utils.isAddress(address))\n            throw new Error(\n                `Invalid address ${address}. To get keyring from wallet, you need to pass a valid address string as a parameter.`\n            )\n\n        const founded = this._addressKeyringMap.get(address.toLowerCase())\n\n        return founded\n    }\n\n    /**\n     * adds a keyring to the keyringContainer.\n     *\n     * @param {Keyring} keyring A keyring instance to add to keyringContainer.\n     * @return {Keyring}\n     */\n    add(keyring) {\n        if (this._addressKeyringMap.get(keyring.address.toLowerCase()) !== undefined)\n            throw new Error(`Duplicate Account ${keyring.address}. Please use updateKeyring() instead.`)\n\n        const keyringToAdd = keyring.copy()\n\n        this._addressKeyringMap.set(keyringToAdd.address.toLowerCase(), keyringToAdd)\n\n        return keyringToAdd\n    }\n\n    /**\n     * deletes the keyring that associates with the given address from keyringContainer.\n     *\n     * @param {string} address An address of the keyring to be deleted in keyringContainer.\n     * @return {boolean}\n     */\n    remove(address) {\n        let keyringToRemove\n        if (utils.isAddress(address)) {\n            keyringToRemove = this.getKeyring(address)\n        } else {\n            throw new Error(`To remove the keyring, the first parameter should be an address string.`)\n        }\n\n        if (keyringToRemove === undefined) return false\n\n        // deallocate keyring object created for keyringContainer\n        keyringToRemove.keys = null\n        this._addressKeyringMap.delete(keyringToRemove.address.toLowerCase())\n\n        return true\n    }\n\n    /**\n     * signs with data and returns the result object that includes `signature`, `message` and `messageHash`\n     *\n     * @param {string} address An address of keyring in keyringContainer.\n     * @param {string} data The data string to sign.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] An index of key to use for signing.\n     * @return {object}\n     */\n    signMessage(address, data, role, index) {\n        const keyring = this.getKeyring(address)\n        if (keyring === undefined) throw new Error(`Failed to find keyring from wallet with ${address}`)\n        return keyring.signMessage(data, role, index)\n    }\n\n    /**\n     * signs the transaction using one key and return the transactionHash\n     *\n     * @param {string} address An address of keyring in keyringContainer.\n     * @param {Transaction} transaction A transaction object.\n     * @param {number} [index] An index of key to use for signing. If index is undefined, all private keys in keyring will be used.\n     * @param {function} [hasher] A function to return hash of transaction.\n     * @return {Transaction}\n     */\n    async sign(address, transaction, index, hasher) {\n        const keyring = this.getKeyring(address)\n        if (keyring === undefined) throw new Error(`Failed to find keyring from wallet with ${address}`)\n        const signed = await transaction.sign(keyring, index, hasher)\n\n        return signed\n    }\n\n    /**\n     * signs the transaction as a fee payer using one key and return the transactionHash\n     *\n     * @param {string} address An address of keyring in keyringContainer.\n     * @param {Transaction} transaction A transaction object. This should be `FEE_DELEGATED` type.\n     * @param {number} [index] An index of key to use for signing. If index is undefined, all private keys in keyring will be used.\n     * @param {function} [hasher] A function to return hash of transaction.\n     * @return {Transaction}\n     */\n    async signAsFeePayer(address, transaction, index, hasher) {\n        const keyring = this.getKeyring(address)\n        if (keyring === undefined) throw new Error(`Failed to find keyring from wallet with ${address}`)\n        const signed = await transaction.signAsFeePayer(keyring, index, hasher)\n\n        return signed\n    }\n}\n\nmodule.exports = KeyringContainer\n"]},"metadata":{},"sourceType":"script"}