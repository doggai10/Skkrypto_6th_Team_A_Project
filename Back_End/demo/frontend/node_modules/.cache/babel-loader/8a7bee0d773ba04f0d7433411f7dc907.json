{"ast":null,"code":"var _slicedToArray = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nvar _ = require('lodash');\n\nvar utils = require('../../../caver-utils');\n\nvar emptySigArray = ['0x01', '0x', '0x'];\n/**\n * Representing a SignatureData class that includes ECDSA signature data string.\n * @class\n */\n\nvar SignatureData = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * creates a SignatureData.\n   * @param {Array.<string>|SignatureData} key - The ECDSA signatureData\n   */\n  function SignatureData(signature) {\n    _classCallCheck(this, SignatureData);\n\n    if (!signature) signature = emptySigArray;\n\n    if (signature instanceof SignatureData) {\n      this.v = signature.v;\n      this.r = signature.r;\n      this.s = signature.s;\n    }\n\n    if (!_.isArray(signature)) signature = utils.resolveSignature(signature);\n\n    var _signature = signature,\n        _signature2 = _slicedToArray(_signature, 3),\n        v = _signature2[0],\n        r = _signature2[1],\n        s = _signature2[2];\n\n    this.v = v;\n    this.r = r;\n    this.s = s;\n  }\n  /**\n   * @type {string}\n   */\n\n\n  _createClass(SignatureData, [{\n    key: \"isEmpty\",\n\n    /**\n     * Return `true` if signature is same with emptySig.\n     *\n     * @return {boolean}\n     */\n    value: function isEmpty() {\n      if (this.v === '0x01' && this.r === '0x' && this.s === '0x') return true;\n      return false;\n    }\n    /**\n     * Convert to array and return\n     *\n     * @return {Array.<string>}\n     */\n\n  }, {\n    key: \"encode\",\n    value: function encode() {\n      return [this.v, this.r, this.s];\n    }\n    /**\n     * Convert to string\n     *\n     * @return {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.v + this.r + this.s;\n    }\n  }, {\n    key: \"v\",\n    get: function get() {\n      return this._v;\n    },\n    set: function set(v) {\n      this._v = utils.makeEven(v);\n    }\n    /**\n     * @type {string}\n     */\n\n  }, {\n    key: \"V\",\n    get: function get() {\n      return this.v;\n    },\n    set: function set(v) {\n      this.v = v;\n    }\n    /**\n     * @type {string}\n     */\n\n  }, {\n    key: \"r\",\n    get: function get() {\n      return this._r;\n    },\n    set: function set(r) {\n      this._r = utils.makeEven(r);\n    }\n    /**\n     * @type {string}\n     */\n\n  }, {\n    key: \"R\",\n    get: function get() {\n      return this.r;\n    },\n    set: function set(r) {\n      this.r = r;\n    }\n    /**\n     * @type {string}\n     */\n\n  }, {\n    key: \"s\",\n    get: function get() {\n      return this._s;\n    },\n    set: function set(s) {\n      this._s = utils.makeEven(s);\n    }\n    /**\n     * @type {string}\n     */\n\n  }, {\n    key: \"S\",\n    get: function get() {\n      return this.s;\n    },\n    set: function set(s) {\n      this.s = s;\n    }\n  }]);\n\n  return SignatureData;\n}();\n\nSignatureData.emtpySig = new SignatureData(emptySigArray);\nmodule.exports = SignatureData;","map":{"version":3,"sources":["/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/caver-js/packages/caver-wallet/src/keyring/signatureData.js"],"names":["_","require","utils","emptySigArray","SignatureData","signature","v","r","s","isArray","resolveSignature","_v","makeEven","_r","_s","emtpySig","module","exports"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,IAAMC,KAAK,GAAGD,OAAO,CAAC,sBAAD,CAArB;;AAEA,IAAME,aAAa,GAAG,CAAC,MAAD,EAAS,IAAT,EAAe,IAAf,CAAtB;AAEA;AACA;AACA;AACA;;IACMC,a;;;AACF;AACJ;AACA;AACA;AACI,yBAAYC,SAAZ,EAAuB;AAAA;;AACnB,QAAI,CAACA,SAAL,EAAgBA,SAAS,GAAGF,aAAZ;;AAChB,QAAIE,SAAS,YAAYD,aAAzB,EAAwC;AACpC,WAAKE,CAAL,GAASD,SAAS,CAACC,CAAnB;AACA,WAAKC,CAAL,GAASF,SAAS,CAACE,CAAnB;AACA,WAAKC,CAAL,GAASH,SAAS,CAACG,CAAnB;AACH;;AACD,QAAI,CAACR,CAAC,CAACS,OAAF,CAAUJ,SAAV,CAAL,EAA2BA,SAAS,GAAGH,KAAK,CAACQ,gBAAN,CAAuBL,SAAvB,CAAZ;;AAPR,qBASDA,SATC;AAAA;AAAA,QASZC,CATY;AAAA,QASTC,CATS;AAAA,QASNC,CATM;;AAUnB,SAAKF,CAAL,GAASA,CAAT;AACA,SAAKC,CAAL,GAASA,CAAT;AACA,SAAKC,CAAL,GAASA,CAAT;AACH;AAED;AACJ;AACA;;;;;;AAgEI;AACJ;AACA;AACA;AACA;8BACc;AACN,UAAI,KAAKF,CAAL,KAAW,MAAX,IAAqB,KAAKC,CAAL,KAAW,IAAhC,IAAwC,KAAKC,CAAL,KAAW,IAAvD,EAA6D,OAAO,IAAP;AAC7D,aAAO,KAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;;6BACa;AACL,aAAO,CAAC,KAAKF,CAAN,EAAS,KAAKC,CAAd,EAAiB,KAAKC,CAAtB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;;+BACe;AACP,aAAO,KAAKF,CAAL,GAAS,KAAKC,CAAd,GAAkB,KAAKC,CAA9B;AACH;;;wBAzFO;AACJ,aAAO,KAAKG,EAAZ;AACH,K;sBAEKL,C,EAAG;AACL,WAAKK,EAAL,GAAUT,KAAK,CAACU,QAAN,CAAeN,CAAf,CAAV;AACH;AAED;AACJ;AACA;;;;wBACY;AACJ,aAAO,KAAKA,CAAZ;AACH,K;sBAEKA,C,EAAG;AACL,WAAKA,CAAL,GAASA,CAAT;AACH;AAED;AACJ;AACA;;;;wBACY;AACJ,aAAO,KAAKO,EAAZ;AACH,K;sBAEKN,C,EAAG;AACL,WAAKM,EAAL,GAAUX,KAAK,CAACU,QAAN,CAAeL,CAAf,CAAV;AACH;AAED;AACJ;AACA;;;;wBACY;AACJ,aAAO,KAAKA,CAAZ;AACH,K;sBAEKA,C,EAAG;AACL,WAAKA,CAAL,GAASA,CAAT;AACH;AAED;AACJ;AACA;;;;wBACY;AACJ,aAAO,KAAKO,EAAZ;AACH,K;sBAEKN,C,EAAG;AACL,WAAKM,EAAL,GAAUZ,KAAK,CAACU,QAAN,CAAeJ,CAAf,CAAV;AACH;AAED;AACJ;AACA;;;;wBACY;AACJ,aAAO,KAAKA,CAAZ;AACH,K;sBAEKA,C,EAAG;AACL,WAAKA,CAAL,GAASA,CAAT;AACH;;;;;;AA+BLJ,aAAa,CAACW,QAAd,GAAyB,IAAIX,aAAJ,CAAkBD,aAAlB,CAAzB;AAEAa,MAAM,CAACC,OAAP,GAAiBb,aAAjB","sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst _ = require('lodash')\nconst utils = require('../../../caver-utils')\n\nconst emptySigArray = ['0x01', '0x', '0x']\n\n/**\n * Representing a SignatureData class that includes ECDSA signature data string.\n * @class\n */\nclass SignatureData {\n    /**\n     * creates a SignatureData.\n     * @param {Array.<string>|SignatureData} key - The ECDSA signatureData\n     */\n    constructor(signature) {\n        if (!signature) signature = emptySigArray\n        if (signature instanceof SignatureData) {\n            this.v = signature.v\n            this.r = signature.r\n            this.s = signature.s\n        }\n        if (!_.isArray(signature)) signature = utils.resolveSignature(signature)\n\n        const [v, r, s] = signature\n        this.v = v\n        this.r = r\n        this.s = s\n    }\n\n    /**\n     * @type {string}\n     */\n    get v() {\n        return this._v\n    }\n\n    set v(v) {\n        this._v = utils.makeEven(v)\n    }\n\n    /**\n     * @type {string}\n     */\n    get V() {\n        return this.v\n    }\n\n    set V(v) {\n        this.v = v\n    }\n\n    /**\n     * @type {string}\n     */\n    get r() {\n        return this._r\n    }\n\n    set r(r) {\n        this._r = utils.makeEven(r)\n    }\n\n    /**\n     * @type {string}\n     */\n    get R() {\n        return this.r\n    }\n\n    set R(r) {\n        this.r = r\n    }\n\n    /**\n     * @type {string}\n     */\n    get s() {\n        return this._s\n    }\n\n    set s(s) {\n        this._s = utils.makeEven(s)\n    }\n\n    /**\n     * @type {string}\n     */\n    get S() {\n        return this.s\n    }\n\n    set S(s) {\n        this.s = s\n    }\n\n    /**\n     * Return `true` if signature is same with emptySig.\n     *\n     * @return {boolean}\n     */\n    isEmpty() {\n        if (this.v === '0x01' && this.r === '0x' && this.s === '0x') return true\n        return false\n    }\n\n    /**\n     * Convert to array and return\n     *\n     * @return {Array.<string>}\n     */\n    encode() {\n        return [this.v, this.r, this.s]\n    }\n\n    /**\n     * Convert to string\n     *\n     * @return {string}\n     */\n    toString() {\n        return this.v + this.r + this.s\n    }\n}\n\nSignatureData.emtpySig = new SignatureData(emptySigArray)\n\nmodule.exports = SignatureData\n"]},"metadata":{},"sourceType":"script"}