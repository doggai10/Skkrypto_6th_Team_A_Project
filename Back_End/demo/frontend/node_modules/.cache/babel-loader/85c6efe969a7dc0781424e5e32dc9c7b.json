{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nvar _ = require('lodash');\n\nvar Keyring = require('./keyring/keyringFactory');\n\nvar AbstractKeyring = require('./keyring/abstractKeyring');\n\nvar utils = require('../../caver-utils/src');\n/**\n * representing a Keyring container which manages keyrings.\n * @class\n */\n\n\nvar KeyringContainer =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  /**\n   * creates a keyringContainer.\n   * @param {Array.<Keyring>} keyrings - The keyrings to be managed in KeyringContainer.\n   */\n  function KeyringContainer(keyrings) {\n    _classCallCheck(this, KeyringContainer);\n\n    keyrings = keyrings || [];\n    this._addressKeyringMap = new Map(); // add keyrings to keyringContainer\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = keyrings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var keyring = _step.value;\n        this.add(keyring);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n  /**\n   * @type {number}\n   */\n\n\n  _createClass(KeyringContainer, [{\n    key: \"generate\",\n\n    /**\n     * generates keyrings in the keyringContainer with randomly generated key pairs.\n     *\n     * @param {number} numberOfKeyrings The number of keyrings to create.\n     * @param {string} [entropy] A random string to increase entropy. If undefined, a random string will be generated using randomHex.\n     * @return {Array.<string>}\n     */\n    value: function generate(numberOfKeyrings, entropy) {\n      var addresses = [];\n\n      for (var i = 0; i < numberOfKeyrings; ++i) {\n        addresses.push(this.add(Keyring.generate(entropy)).address);\n      }\n\n      return addresses;\n    }\n    /**\n     * creates a keyring instance with given parameters and adds it to the keyringContainer.\n     * KeyringContainer manages Keyring instance using Map <string:Keyring> which has address as key value.\n     *\n     * @param {string} address The address of the keyring.\n     * @param {string|Array.<string>|Array.<Array.<string>>} key Private key string(s) to use in keyring. If different keys are used for each role, key must be defined as a two-dimensional array.\n     * @return {Keyring}\n     */\n\n  }, {\n    key: \"newKeyring\",\n    value: function newKeyring(address, key) {\n      // The format of key parameter can be\n      // 1. single private key string   => `0x{private key}`\n      // 2. multiple private key string =>[`0x{private key}`, `0x{private key}`, ...]\n      // 3. role based private keys     => [[`0x{private key}`, `0x{private key}`, ...], [], [`0x{private key}`]]\n      var keyring;\n      if (_.isString(key)) keyring = Keyring.createWithSingleKey(address, key);\n\n      if (_.isArray(key)) {\n        if (key.length === 0) throw new Error(\"Insufficient private key information: Empty array\");\n\n        if (_.isArray(key[0])) {\n          keyring = Keyring.createWithRoleBasedKey(address, key);\n        } else {\n          keyring = Keyring.createWithMultipleKey(address, key);\n        }\n      }\n\n      if (!(keyring instanceof AbstractKeyring)) throw new Error(\"Unsupported type value: \".concat(key, \" (type:\").concat(typeof key, \")\"));\n      return this.add(keyring);\n    }\n    /**\n     * updates the keyring inside the keyringContainer.\n     * Query the keyring to be updated from keyringContainer with the keyring's address,\n     * and an error occurs when the keyring is not found in the keyringContainer.\n     *\n     * @param {Keyring} keyring The keyring with new key.\n     * @return {Keyring}\n     */\n\n  }, {\n    key: \"updateKeyring\",\n    value: function updateKeyring(keyring) {\n      var founded = this._addressKeyringMap.get(keyring.address.toLowerCase());\n\n      if (founded === undefined) throw new Error(\"Failed to find keyring to update\");\n      this.remove(founded.address);\n      this.add(keyring);\n      return keyring;\n    }\n    /**\n     * Get the keyring in container corresponding to the address\n     *\n     * @param {string} address The address of keyring to query.\n     * @return {Keyring}\n     */\n\n  }, {\n    key: \"getKeyring\",\n    value: function getKeyring(address) {\n      if (!utils.isAddress(address)) throw new Error(\"Invalid address \".concat(address, \". To get keyring from wallet, you need to pass a valid address string as a parameter.\"));\n\n      var founded = this._addressKeyringMap.get(address.toLowerCase());\n\n      return founded;\n    }\n    /**\n     * adds a keyring to the keyringContainer.\n     *\n     * @param {Keyring} keyring A keyring instance to add to keyringContainer.\n     * @return {Keyring}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(keyring) {\n      if (this._addressKeyringMap.get(keyring.address.toLowerCase()) !== undefined) throw new Error(\"Duplicate Account \".concat(keyring.address, \". Please use updateKeyring() instead.\"));\n      var keyringToAdd = keyring.copy();\n\n      this._addressKeyringMap.set(keyringToAdd.address.toLowerCase(), keyringToAdd);\n\n      return keyringToAdd;\n    }\n    /**\n     * deletes the keyring that associates with the given address from keyringContainer.\n     *\n     * @param {string} address An address of the keyring to be deleted in keyringContainer.\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(address) {\n      var keyringToRemove;\n\n      if (utils.isAddress(address)) {\n        keyringToRemove = this.getKeyring(address);\n      } else {\n        throw new Error(\"To remove the keyring, the first parameter should be an address string.\");\n      }\n\n      if (keyringToRemove === undefined) return false; // deallocate keyring object created for keyringContainer\n\n      keyringToRemove.keys = null;\n\n      this._addressKeyringMap.delete(keyringToRemove.address.toLowerCase());\n\n      return true;\n    }\n    /**\n     * signs with data and returns the result object that includes `signature`, `message` and `messageHash`\n     *\n     * @param {string} address An address of keyring in keyringContainer.\n     * @param {string} data The data string to sign.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] An index of key to use for signing.\n     * @return {object}\n     */\n\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(address, data, role, index) {\n      var keyring = this.getKeyring(address);\n      if (keyring === undefined) throw new Error(\"Failed to find keyring from wallet with \".concat(address));\n      return keyring.signMessage(data, role, index);\n    }\n    /**\n     * signs the transaction using one key and return the transactionHash\n     *\n     * @param {string} address An address of keyring in keyringContainer.\n     * @param {Transaction} transaction A transaction object.\n     * @param {number} [index] An index of key to use for signing. If index is undefined, all private keys in keyring will be used.\n     * @param {function} [hasher] A function to return hash of transaction.\n     * @return {Transaction}\n     */\n\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(address, transaction, index, hasher) {\n        var keyring, signed;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                keyring = this.getKeyring(address);\n\n                if (!(keyring === undefined)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Failed to find keyring from wallet with \".concat(address));\n\n              case 3:\n                _context.next = 5;\n                return transaction.sign(keyring, index, hasher);\n\n              case 5:\n                signed = _context.sent;\n                return _context.abrupt(\"return\", signed);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sign(_x, _x2, _x3, _x4) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n    /**\n     * signs the transaction as a fee payer using one key and return the transactionHash\n     *\n     * @param {string} address An address of keyring in keyringContainer.\n     * @param {Transaction} transaction A transaction object. This should be `FEE_DELEGATED` type.\n     * @param {number} [index] An index of key to use for signing. If index is undefined, all private keys in keyring will be used.\n     * @param {function} [hasher] A function to return hash of transaction.\n     * @return {Transaction}\n     */\n\n  }, {\n    key: \"signAsFeePayer\",\n    value: function () {\n      var _signAsFeePayer = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(address, transaction, index, hasher) {\n        var keyring, signed;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                keyring = this.getKeyring(address);\n\n                if (!(keyring === undefined)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Failed to find keyring from wallet with \".concat(address));\n\n              case 3:\n                _context2.next = 5;\n                return transaction.signAsFeePayer(keyring, index, hasher);\n\n              case 5:\n                signed = _context2.sent;\n                return _context2.abrupt(\"return\", signed);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function signAsFeePayer(_x5, _x6, _x7, _x8) {\n        return _signAsFeePayer.apply(this, arguments);\n      }\n\n      return signAsFeePayer;\n    }()\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._addressKeyringMap.size;\n    }\n  }]);\n\n  return KeyringContainer;\n}();\n\nmodule.exports = KeyringContainer;","map":null,"metadata":{},"sourceType":"script"}