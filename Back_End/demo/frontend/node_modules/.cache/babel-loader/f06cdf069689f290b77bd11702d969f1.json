{"ast":null,"code":"var _slicedToArray = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nvar _ = require('lodash');\n\nvar Bytes = require('eth-lib/lib/bytes');\n\nvar RLP = require('eth-lib/lib/rlp');\n\nvar Hash = require('eth-lib/lib/hash');\n\nvar TransactionHasher = require('../transactionHasher/transactionHasher');\n\nvar utils = require('../../../caver-utils');\n\nvar Keyring = require('../../../caver-wallet/src/keyring/keyringFactory');\n\nvar AbstractKeyring = require('../../../caver-wallet/src/keyring/abstractKeyring');\n\nvar _require = require('../transactionHelper/transactionHelper'),\n    TX_TYPE_STRING = _require.TX_TYPE_STRING,\n    refineSignatures = _require.refineSignatures,\n    typeDetectionFromRLPEncoding = _require.typeDetectionFromRLPEncoding;\n\nvar _require2 = require('../../../caver-wallet/src/keyring/keyringHelper'),\n    KEY_ROLE = _require2.KEY_ROLE;\n\nvar _require3 = require('../../../caver-core-helpers/src/validateFunction'),\n    validateParams = _require3.validateParams;\n\nvar SignatureData = require('../../../caver-wallet/src/keyring/signatureData');\n/**\n * Abstract class that implements common logic for each transaction type.\n * @class\n */\n\n\nvar AbstractTransaction = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * Abstract class that implements common logic for each transaction type.\n   * In this constructor, type, tag, nonce, gasPrice, chainId, gas and signatures are set as transaction member variables.\n   *\n   * @constructor\n   * @param {string} typeString - The type string of transaction.\n   * @param {object} createTxObj - The parameters to create a transaction instance.\n   */\n  function AbstractTransaction(typeString, createTxObj) {\n    _classCallCheck(this, AbstractTransaction);\n\n    this._type = typeString;\n    createTxObj.type = typeString;\n    var err = validateParams(createTxObj);\n    if (err) throw err;\n    this.from = createTxObj.from;\n    this.gas = createTxObj.gas; // The variables below are values that the user does not need to pass to the parameter.\n\n    if (createTxObj.nonce !== undefined) this.nonce = createTxObj.nonce;\n    if (createTxObj.gasPrice !== undefined) this.gasPrice = createTxObj.gasPrice;\n    if (createTxObj.chainId !== undefined) this.chainId = createTxObj.chainId;\n    this.signatures = createTxObj.signatures || [];\n  }\n  /**\n   * @type {string}\n   */\n\n\n  _createClass(AbstractTransaction, [{\n    key: \"getRLPEncoding\",\n\n    /**\n     * Returns the RLP-encoded string of this transaction (i.e., rawTransaction).\n     * This method has to be overrided in classes which extends AbstractTransaction.\n     *\n     * @return {string}\n     */\n    value: function getRLPEncoding() {\n      throw new Error(\"Not implemented.\");\n    }\n    /**\n     * Returns the RLP-encoded string to make the signature of this transaction.\n     * This method has to be overrided in classes which extends AbstractTransaction.\n     * getCommonRLPEncodingForSignature is used in getRLPEncodingForSignature.\n     *\n     * @return {string}\n     */\n\n  }, {\n    key: \"getCommonRLPEncodingForSignature\",\n    value: function getCommonRLPEncodingForSignature() {\n      throw new Error(\"Not implemented.\");\n    }\n    /**\n     * Signs to the transaction with private key(s) in the `key`.\n     * @async\n     * @param {Keyring|string} key - The instance of Keyring, private key string or KlaytnWalletKey string.\n     * @param {number} [index] - The index of private key to use. If index is undefined, all private keys in keyring will be used.\n     * @param {function} [hasher] - The function to get hash of transaction. In order to use a custom hasher, the index must be defined.\n     * @return {Transaction}\n     */\n\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(key, index) {\n        var hasher,\n            keyring,\n            hash,\n            role,\n            sig,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                hasher = _args.length > 2 && _args[2] !== undefined ? _args[2] : TransactionHasher.getHashForSignature;\n\n                // User parameter input cases\n                // (key) / (key index) / (key hasher) / (key index hasher)\n                if (_.isFunction(index)) {\n                  hasher = index;\n                  index = undefined;\n                }\n\n                keyring = key;\n\n                if (_.isString(key)) {\n                  keyring = Keyring.createFromPrivateKey(key);\n                }\n\n                if (keyring instanceof AbstractKeyring) {\n                  _context.next = 6;\n                  break;\n                }\n\n                throw new Error(\"Unsupported key type. The key must be a single private key string, KlaytnWalletKey string, or Keyring instance.\");\n\n              case 6:\n                if (!(this.type === TX_TYPE_STRING.TxTypeLegacyTransaction && keyring.isDecoupled())) {\n                  _context.next = 8;\n                  break;\n                }\n\n                throw new Error(\"A legacy transaction cannot be signed with a decoupled keyring.\");\n\n              case 8:\n                if (!this.from || this.from === '0x') this.from = keyring.address;\n\n                if (!(this.from.toLowerCase() !== keyring.address.toLowerCase())) {\n                  _context.next = 11;\n                  break;\n                }\n\n                throw new Error(\"The from address of the transaction is different with the address of the keyring to use.\");\n\n              case 11:\n                _context.next = 13;\n                return this.fillTransaction();\n\n              case 13:\n                hash = hasher(this);\n                role = this.type.includes('AccountUpdate') ? KEY_ROLE.roleAccountUpdateKey : KEY_ROLE.roleTransactionKey;\n                sig = keyring.sign(hash, this.chainId, role, index);\n                this.appendSignatures(sig);\n                return _context.abrupt(\"return\", this);\n\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sign(_x, _x2) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n    /**\n     * Appends signatures to the transaction.\n     *\n     * @param {SignatureData|Array.<SignatureData>|Array.<string>|Array.<Array.<string>>} signatures - An array of signatures to append to the transaction.\n     *                                                      One signature can be defined in the form of a one-dimensional array or two-dimensional array,\n     *                                                      and more than one signatures should be defined in the form of a two-dimensional array.\n     */\n\n  }, {\n    key: \"appendSignatures\",\n    value: function appendSignatures(signatures) {\n      var sig = signatures;\n      if (_.isString(sig)) sig = utils.resolveSignature(sig);\n      if (sig instanceof SignatureData) sig = [sig];\n      if (!_.isArray(sig)) throw new Error(\"Failed to append signatures: invalid signatures format \".concat(sig));\n      if (_.isString(sig[0])) sig = [sig];\n      this.signatures = this.signatures.concat(sig);\n    }\n    /**\n     * Combines RLP-encoded transactions (rawTransaction) to the transaction from RLP-encoded transaction strings and returns a single transaction with all signatures combined.\n     * When combining the signatures into a transaction instance,\n     * an error is thrown if the decoded transaction contains different value except signatures.\n     *\n     * @param {Array.<string>} rlpEncodedTxs - An array of RLP-encoded transaction strings.\n     * @return {string}\n     */\n\n  }, {\n    key: \"combineSignedRawTransactions\",\n    value: function combineSignedRawTransactions(rlpEncodedTxs) {\n      if (!_.isArray(rlpEncodedTxs)) throw new Error(\"The parameter must be an array of RLP-encoded transaction strings.\"); // If the signatures are empty, there may be an undefined member variable.\n      // In this case, the empty information is filled with the decoded result.\n\n      var fillVariables = false;\n      if (utils.isEmptySig(this.signatures)) fillVariables = true;\n\n      var _iterator = _createForOfIteratorHelper(rlpEncodedTxs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var encoded = _step.value;\n          var type = typeDetectionFromRLPEncoding(encoded);\n          if (this.type !== type) throw new Error(\"Transaction type mismatch: Signatures from different transactions cannot be combined.\");\n          var decoded = this.constructor.decode(encoded); // Signatures can only be combined for the same transaction.\n          // Therefore, compare whether the decoded transaction is the same as this.\n\n          for (var k in decoded) {\n            if (k === '_signatures' || k === '_feePayerSignatures') continue;\n            if (this[k] === undefined && fillVariables) this[k] = decoded[k];\n            var differentTxError = \"Transactions containing different information cannot be combined.\"; // Compare with the RLP-encoded accountKey string, because 'account' is an object.\n\n            if (k === '_account') {\n              if (this[k].getRLPEncodingAccountKey() !== decoded[k].getRLPEncodingAccountKey()) throw new Error(differentTxError);\n              continue;\n            }\n\n            if (this[k] !== decoded[k]) throw new Error(differentTxError);\n          }\n\n          this.appendSignatures(decoded.signatures);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return this.getRLPEncoding();\n    }\n    /**\n     * Returns RawTransaction(RLP-encoded transaction string)\n     *\n     * @return {string}\n     */\n\n  }, {\n    key: \"getRawTransaction\",\n    value: function getRawTransaction() {\n      return this.getRLPEncoding();\n    }\n    /**\n     * Returns a hash string of transaction\n     *\n     * @return {string}\n     */\n\n  }, {\n    key: \"getTransactionHash\",\n    value: function getTransactionHash() {\n      return Hash.keccak256(this.getRLPEncoding());\n    }\n    /**\n     * Returns a senderTxHash of transaction\n     *\n     * @return {string}\n     */\n\n  }, {\n    key: \"getSenderTxHash\",\n    value: function getSenderTxHash() {\n      return this.getTransactionHash();\n    }\n    /**\n     * Returns an RLP-encoded transaction string for making signature\n     *\n     * @return {string}\n     */\n\n  }, {\n    key: \"getRLPEncodingForSignature\",\n    value: function getRLPEncodingForSignature() {\n      this.validateOptionalValues();\n      if (this.chainId === undefined) throw new Error(\"chainId is undefined. Define chainId in transaction or use 'transaction.fillTransaction' to fill values.\");\n      return RLP.encode([this.getCommonRLPEncodingForSignature(), Bytes.fromNat(this.chainId), '0x', '0x']);\n    }\n    /**\n     * Fills empty optional transaction properties(gasPrice, nonce, chainId).\n     */\n\n  }, {\n    key: \"fillTransaction\",\n    value: function () {\n      var _fillTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _yield$Promise$all, _yield$Promise$all2, chainId, gasPrice, nonce;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return Promise.all([isNot(this.chainId) ? AbstractTransaction._klaytnCall.getChainId() : this.chainId, isNot(this.gasPrice) ? AbstractTransaction._klaytnCall.getGasPrice() : this.gasPrice, isNot(this.nonce) ? AbstractTransaction._klaytnCall.getTransactionCount(this.from, 'pending') : this.nonce]);\n\n              case 2:\n                _yield$Promise$all = _context2.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 3);\n                chainId = _yield$Promise$all2[0];\n                gasPrice = _yield$Promise$all2[1];\n                nonce = _yield$Promise$all2[2];\n                this.chainId = chainId;\n                this.gasPrice = gasPrice;\n                this.nonce = nonce;\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function fillTransaction() {\n        return _fillTransaction.apply(this, arguments);\n      }\n\n      return fillTransaction;\n    }()\n    /**\n     * Checks that member variables that can be defined by the user are defined.\n     * If there is an undefined variable, an error occurs.\n     */\n\n  }, {\n    key: \"validateOptionalValues\",\n    value: function validateOptionalValues() {\n      if (this.gasPrice === undefined) throw new Error(\"gasPrice is undefined. Define gasPrice in transaction or use 'transaction.fillTransaction' to fill values.\");\n      if (this.nonce === undefined) throw new Error(\"nonce is undefined. Define nonce in transaction or use 'transaction.fillTransaction' to fill values.\");\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n    /**\n     * @type {string}\n     */\n\n  }, {\n    key: \"from\",\n    get: function get() {\n      return this._from;\n    },\n    set: function set(address) {\n      if (this.type === TX_TYPE_STRING.TxTypeLegacyTransaction && address === '0x') {\n        this._from = address.toLowerCase();\n      } else {\n        if (!utils.isAddress(address)) throw new Error(\"Invalid address \".concat(address));\n        this._from = address.toLowerCase();\n      }\n    }\n    /**\n     * @type {string}\n     */\n\n  }, {\n    key: \"nonce\",\n    get: function get() {\n      return this._nonce;\n    },\n    set: function set(n) {\n      this._nonce = utils.numberToHex(n);\n    }\n    /**\n     * @type {string}\n     */\n\n  }, {\n    key: \"gas\",\n    get: function get() {\n      return this._gas;\n    },\n    set: function set(g) {\n      this._gas = utils.numberToHex(g);\n    }\n    /**\n     * @type {string}\n     */\n\n  }, {\n    key: \"gasPrice\",\n    get: function get() {\n      return this._gasPrice;\n    },\n    set: function set(g) {\n      this._gasPrice = utils.numberToHex(g);\n    }\n    /**\n     * @type {string}\n     */\n\n  }, {\n    key: \"chainId\",\n    get: function get() {\n      return this._chainId;\n    },\n    set: function set(ch) {\n      this._chainId = utils.toHex(ch);\n    }\n    /**\n     * @type {Array<string>|Array.<Array<string>>}\n     */\n\n  }, {\n    key: \"signatures\",\n    get: function get() {\n      return this._signatures;\n    },\n    set: function set(sigs) {\n      this._signatures = refineSignatures(sigs, this.type === TX_TYPE_STRING.TxTypeLegacyTransaction);\n    }\n  }]);\n\n  return AbstractTransaction;\n}();\n\nvar isNot = function isNot(value) {\n  return _.isUndefined(value) || _.isNull(value);\n};\n\nmodule.exports = AbstractTransaction;","map":{"version":3,"sources":["/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/caver-js/packages/caver-transaction/src/transactionTypes/abstractTransaction.js"],"names":["_","require","Bytes","RLP","Hash","TransactionHasher","utils","Keyring","AbstractKeyring","TX_TYPE_STRING","refineSignatures","typeDetectionFromRLPEncoding","KEY_ROLE","validateParams","SignatureData","AbstractTransaction","typeString","createTxObj","_type","type","err","from","gas","nonce","undefined","gasPrice","chainId","signatures","Error","key","index","hasher","getHashForSignature","isFunction","keyring","isString","createFromPrivateKey","TxTypeLegacyTransaction","isDecoupled","address","toLowerCase","fillTransaction","hash","role","includes","roleAccountUpdateKey","roleTransactionKey","sig","sign","appendSignatures","resolveSignature","isArray","concat","rlpEncodedTxs","fillVariables","isEmptySig","encoded","decoded","constructor","decode","k","differentTxError","getRLPEncodingAccountKey","getRLPEncoding","keccak256","getTransactionHash","validateOptionalValues","encode","getCommonRLPEncodingForSignature","fromNat","Promise","all","isNot","_klaytnCall","getChainId","getGasPrice","getTransactionCount","_from","isAddress","_nonce","n","numberToHex","_gas","g","_gasPrice","_chainId","ch","toHex","_signatures","sigs","value","isUndefined","isNull","module","exports"],"mappings":"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","sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst _ = require('lodash')\nconst Bytes = require('eth-lib/lib/bytes')\nconst RLP = require('eth-lib/lib/rlp')\nconst Hash = require('eth-lib/lib/hash')\nconst TransactionHasher = require('../transactionHasher/transactionHasher')\nconst utils = require('../../../caver-utils')\nconst Keyring = require('../../../caver-wallet/src/keyring/keyringFactory')\nconst AbstractKeyring = require('../../../caver-wallet/src/keyring/abstractKeyring')\nconst { TX_TYPE_STRING, refineSignatures, typeDetectionFromRLPEncoding } = require('../transactionHelper/transactionHelper')\nconst { KEY_ROLE } = require('../../../caver-wallet/src/keyring/keyringHelper')\nconst { validateParams } = require('../../../caver-core-helpers/src/validateFunction')\nconst SignatureData = require('../../../caver-wallet/src/keyring/signatureData')\n\n/**\n * Abstract class that implements common logic for each transaction type.\n * @class\n */\nclass AbstractTransaction {\n    /**\n     * Abstract class that implements common logic for each transaction type.\n     * In this constructor, type, tag, nonce, gasPrice, chainId, gas and signatures are set as transaction member variables.\n     *\n     * @constructor\n     * @param {string} typeString - The type string of transaction.\n     * @param {object} createTxObj - The parameters to create a transaction instance.\n     */\n    constructor(typeString, createTxObj) {\n        this._type = typeString\n\n        createTxObj.type = typeString\n\n        const err = validateParams(createTxObj)\n        if (err) throw err\n\n        this.from = createTxObj.from\n\n        this.gas = createTxObj.gas\n\n        // The variables below are values that the user does not need to pass to the parameter.\n        if (createTxObj.nonce !== undefined) this.nonce = createTxObj.nonce\n        if (createTxObj.gasPrice !== undefined) this.gasPrice = createTxObj.gasPrice\n        if (createTxObj.chainId !== undefined) this.chainId = createTxObj.chainId\n\n        this.signatures = createTxObj.signatures || []\n    }\n\n    /**\n     * @type {string}\n     */\n    get type() {\n        return this._type\n    }\n\n    /**\n     * @type {string}\n     */\n    get from() {\n        return this._from\n    }\n\n    set from(address) {\n        if (this.type === TX_TYPE_STRING.TxTypeLegacyTransaction && address === '0x') {\n            this._from = address.toLowerCase()\n        } else {\n            if (!utils.isAddress(address)) throw new Error(`Invalid address ${address}`)\n            this._from = address.toLowerCase()\n        }\n    }\n\n    /**\n     * @type {string}\n     */\n    get nonce() {\n        return this._nonce\n    }\n\n    set nonce(n) {\n        this._nonce = utils.numberToHex(n)\n    }\n\n    /**\n     * @type {string}\n     */\n    get gas() {\n        return this._gas\n    }\n\n    set gas(g) {\n        this._gas = utils.numberToHex(g)\n    }\n\n    /**\n     * @type {string}\n     */\n    get gasPrice() {\n        return this._gasPrice\n    }\n\n    set gasPrice(g) {\n        this._gasPrice = utils.numberToHex(g)\n    }\n\n    /**\n     * @type {string}\n     */\n    get chainId() {\n        return this._chainId\n    }\n\n    set chainId(ch) {\n        this._chainId = utils.toHex(ch)\n    }\n\n    /**\n     * @type {Array<string>|Array.<Array<string>>}\n     */\n    get signatures() {\n        return this._signatures\n    }\n\n    set signatures(sigs) {\n        this._signatures = refineSignatures(sigs, this.type === TX_TYPE_STRING.TxTypeLegacyTransaction)\n    }\n\n    /**\n     * Returns the RLP-encoded string of this transaction (i.e., rawTransaction).\n     * This method has to be overrided in classes which extends AbstractTransaction.\n     *\n     * @return {string}\n     */\n    getRLPEncoding() {\n        throw new Error(`Not implemented.`)\n    }\n\n    /**\n     * Returns the RLP-encoded string to make the signature of this transaction.\n     * This method has to be overrided in classes which extends AbstractTransaction.\n     * getCommonRLPEncodingForSignature is used in getRLPEncodingForSignature.\n     *\n     * @return {string}\n     */\n    getCommonRLPEncodingForSignature() {\n        throw new Error(`Not implemented.`)\n    }\n\n    /**\n     * Signs to the transaction with private key(s) in the `key`.\n     * @async\n     * @param {Keyring|string} key - The instance of Keyring, private key string or KlaytnWalletKey string.\n     * @param {number} [index] - The index of private key to use. If index is undefined, all private keys in keyring will be used.\n     * @param {function} [hasher] - The function to get hash of transaction. In order to use a custom hasher, the index must be defined.\n     * @return {Transaction}\n     */\n    async sign(key, index, hasher = TransactionHasher.getHashForSignature) {\n        // User parameter input cases\n        // (key) / (key index) / (key hasher) / (key index hasher)\n        if (_.isFunction(index)) {\n            hasher = index\n            index = undefined\n        }\n\n        let keyring = key\n        if (_.isString(key)) {\n            keyring = Keyring.createFromPrivateKey(key)\n        }\n        if (!(keyring instanceof AbstractKeyring))\n            throw new Error(\n                `Unsupported key type. The key must be a single private key string, KlaytnWalletKey string, or Keyring instance.`\n            )\n\n        // When user attempt to sign with a updated keyring into a TxTypeLegacyTransaction error should be thrown.\n        if (this.type === TX_TYPE_STRING.TxTypeLegacyTransaction && keyring.isDecoupled())\n            throw new Error(`A legacy transaction cannot be signed with a decoupled keyring.`)\n\n        if (!this.from || this.from === '0x') this.from = keyring.address\n        if (this.from.toLowerCase() !== keyring.address.toLowerCase())\n            throw new Error(`The from address of the transaction is different with the address of the keyring to use.`)\n\n        await this.fillTransaction()\n        const hash = hasher(this)\n        const role = this.type.includes('AccountUpdate') ? KEY_ROLE.roleAccountUpdateKey : KEY_ROLE.roleTransactionKey\n\n        const sig = keyring.sign(hash, this.chainId, role, index)\n\n        this.appendSignatures(sig)\n\n        return this\n    }\n\n    /**\n     * Appends signatures to the transaction.\n     *\n     * @param {SignatureData|Array.<SignatureData>|Array.<string>|Array.<Array.<string>>} signatures - An array of signatures to append to the transaction.\n     *                                                      One signature can be defined in the form of a one-dimensional array or two-dimensional array,\n     *                                                      and more than one signatures should be defined in the form of a two-dimensional array.\n     */\n    appendSignatures(signatures) {\n        let sig = signatures\n        if (_.isString(sig)) sig = utils.resolveSignature(sig)\n        if (sig instanceof SignatureData) sig = [sig]\n\n        if (!_.isArray(sig)) throw new Error(`Failed to append signatures: invalid signatures format ${sig}`)\n\n        if (_.isString(sig[0])) sig = [sig]\n\n        this.signatures = this.signatures.concat(sig)\n    }\n\n    /**\n     * Combines RLP-encoded transactions (rawTransaction) to the transaction from RLP-encoded transaction strings and returns a single transaction with all signatures combined.\n     * When combining the signatures into a transaction instance,\n     * an error is thrown if the decoded transaction contains different value except signatures.\n     *\n     * @param {Array.<string>} rlpEncodedTxs - An array of RLP-encoded transaction strings.\n     * @return {string}\n     */\n    combineSignedRawTransactions(rlpEncodedTxs) {\n        if (!_.isArray(rlpEncodedTxs)) throw new Error(`The parameter must be an array of RLP-encoded transaction strings.`)\n\n        // If the signatures are empty, there may be an undefined member variable.\n        // In this case, the empty information is filled with the decoded result.\n        let fillVariables = false\n        if (utils.isEmptySig(this.signatures)) fillVariables = true\n\n        for (const encoded of rlpEncodedTxs) {\n            const type = typeDetectionFromRLPEncoding(encoded)\n            if (this.type !== type) throw new Error(`Transaction type mismatch: Signatures from different transactions cannot be combined.`)\n\n            const decoded = this.constructor.decode(encoded)\n\n            // Signatures can only be combined for the same transaction.\n            // Therefore, compare whether the decoded transaction is the same as this.\n            for (const k in decoded) {\n                if (k === '_signatures' || k === '_feePayerSignatures') continue\n                if (this[k] === undefined && fillVariables) this[k] = decoded[k]\n\n                const differentTxError = `Transactions containing different information cannot be combined.`\n\n                // Compare with the RLP-encoded accountKey string, because 'account' is an object.\n                if (k === '_account') {\n                    if (this[k].getRLPEncodingAccountKey() !== decoded[k].getRLPEncodingAccountKey()) throw new Error(differentTxError)\n                    continue\n                }\n\n                if (this[k] !== decoded[k]) throw new Error(differentTxError)\n            }\n\n            this.appendSignatures(decoded.signatures)\n        }\n\n        return this.getRLPEncoding()\n    }\n\n    /**\n     * Returns RawTransaction(RLP-encoded transaction string)\n     *\n     * @return {string}\n     */\n    getRawTransaction() {\n        return this.getRLPEncoding()\n    }\n\n    /**\n     * Returns a hash string of transaction\n     *\n     * @return {string}\n     */\n    getTransactionHash() {\n        return Hash.keccak256(this.getRLPEncoding())\n    }\n\n    /**\n     * Returns a senderTxHash of transaction\n     *\n     * @return {string}\n     */\n    getSenderTxHash() {\n        return this.getTransactionHash()\n    }\n\n    /**\n     * Returns an RLP-encoded transaction string for making signature\n     *\n     * @return {string}\n     */\n    getRLPEncodingForSignature() {\n        this.validateOptionalValues()\n        if (this.chainId === undefined)\n            throw new Error(`chainId is undefined. Define chainId in transaction or use 'transaction.fillTransaction' to fill values.`)\n\n        return RLP.encode([this.getCommonRLPEncodingForSignature(), Bytes.fromNat(this.chainId), '0x', '0x'])\n    }\n\n    /**\n     * Fills empty optional transaction properties(gasPrice, nonce, chainId).\n     */\n    async fillTransaction() {\n        const [chainId, gasPrice, nonce] = await Promise.all([\n            isNot(this.chainId) ? AbstractTransaction._klaytnCall.getChainId() : this.chainId,\n            isNot(this.gasPrice) ? AbstractTransaction._klaytnCall.getGasPrice() : this.gasPrice,\n            isNot(this.nonce) ? AbstractTransaction._klaytnCall.getTransactionCount(this.from, 'pending') : this.nonce,\n        ])\n\n        this.chainId = chainId\n        this.gasPrice = gasPrice\n        this.nonce = nonce\n    }\n\n    /**\n     * Checks that member variables that can be defined by the user are defined.\n     * If there is an undefined variable, an error occurs.\n     */\n    validateOptionalValues() {\n        if (this.gasPrice === undefined)\n            throw new Error(`gasPrice is undefined. Define gasPrice in transaction or use 'transaction.fillTransaction' to fill values.`)\n        if (this.nonce === undefined)\n            throw new Error(`nonce is undefined. Define nonce in transaction or use 'transaction.fillTransaction' to fill values.`)\n    }\n}\n\nconst isNot = function(value) {\n    return _.isUndefined(value) || _.isNull(value)\n}\n\nmodule.exports = AbstractTransaction\n"]},"metadata":{},"sourceType":"script"}