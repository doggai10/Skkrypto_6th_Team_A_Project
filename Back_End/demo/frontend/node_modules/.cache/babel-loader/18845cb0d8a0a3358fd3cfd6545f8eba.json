{"ast":null,"code":"var _slicedToArray = require(\"/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\n/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-core-method/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\nvar _ = require('lodash');\n\nvar errors = require('../../caver-core-helpers').errors;\n\nvar formatters = require('../../caver-core-helpers').formatters;\n\nvar utils = require('../../caver-utils');\n\nvar Subscriptions = require('../../caver-core-subscriptions').subscriptions;\n\nvar validateParams = require('../../caver-core-helpers').validateFunction.validateParams;\n\nvar TIMEOUTBLOCK = 50;\nvar AVERAGE_BLOCK_TIME = 1; // 1s\n\nvar POLLINGTIMEOUT = AVERAGE_BLOCK_TIME * TIMEOUTBLOCK; // ~average block time (seconds) * TIMEOUTBLOCK\n\nvar TransactionDecoder = require('../../caver-transaction/src/transactionDecoder/transactionDecoder');\n\nfunction Method(options) {\n  // call, name should be existed to create a method.\n  if (!options.call || !options.name) throw errors.needNameCallPropertyToCreateMethod;\n  this.name = options.name;\n  this.call = options.call;\n  this.hexCall = options.hexCall;\n  this.params = options.params || 0;\n  this.inputFormatter = options.inputFormatter || [];\n  this.outputFormatter = options.outputFormatter;\n  this.transformPayload = options.transformPayload;\n  this.extraFormatters = options.extraFormatters;\n  this.requestManager = options.requestManager; // reference to klay.accounts\n\n  this.accounts = options.accounts;\n  this.defaultBlock = options.defaultBlock || 'latest';\n  this.defaultAccount = options.defaultAccount || null;\n  this.outputFormatterDisable = options.outputFormatterDisable;\n}\n\nMethod.prototype.setRequestManager = setRequestManager;\nMethod.prototype.createFunction = createFunction;\nMethod.prototype.attachToObject = attachToObject;\nMethod.prototype.getCall = getCall;\nMethod.prototype.extractCallback = extractCallback;\nMethod.prototype.validateArgs = validateArgs;\nMethod.prototype.formatInput = formatInput;\nMethod.prototype.formatOutput = formatOutput;\nMethod.prototype.toPayload = toPayload;\nMethod.prototype.buildCall = buildCall;\nMethod.prototype._confirmTransaction = _confirmTransaction;\nMethod.prototype.request = request;\n/**\n * Set requestManager for rpc calling.\n * If it has accounts parameter also, set it.\n * @method setRequestManager\n * @param  {Object} requestManager\n * @param  {Object} accounts\n */\n\nfunction setRequestManager(requestManager, accounts) {\n  this.requestManager = requestManager; // reference to klay.accounts\n\n  if (accounts) this.accounts = accounts;\n}\n/**\n * createFunction through 'this' context (= instance by created through new Method(...))\n * @method createFunction\n * @param  {Object} requestManager\n * @param  {Object} accounts\n * @return {Function} it will be used for sending RPC call.\n */\n\n\nfunction createFunction(requestManager, accounts) {\n  // set requestManager for method individulally.\n  this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts); // this.buildCall() returns function `send = function() { ... }`\n\n  var func = this.buildCall(); // call is directly used for rpc calling,\n  // ex) 'klay_sendTransaction'\n\n  func.call = this.call;\n  return func;\n}\n/**\n * attach buildCalled method to 'obj' object,\n * by adding a property name through this.name\n * @method attachToObject\n * @param  {Object} obj\n */\n\n\nfunction attachToObject(obj) {\n  var func = this.buildCall();\n  func.call = this.call;\n\n  var _this$name$split = this.name.split('.'),\n      _this$name$split2 = _slicedToArray(_this$name$split, 2),\n      callName = _this$name$split2[0],\n      optionalName = _this$name$split2[1];\n\n  if (optionalName) {\n    obj[callName] = obj[callName] || {};\n    obj[callName][optionalName] = func;\n  } else {\n    obj[callName] = func;\n  }\n}\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\n\n\nfunction getCall(args) {\n  // If hexCall is defined, args[0] type is truly hexParameter, return this.hexCall\n  // If not, return this.call\n  // 'this.call', 'this.hexCall' are defined in rpc.json\n  return this.hexCall && utils.isHexParameter(args[0]) ? this.hexCall : this.call;\n}\n/**\n * Should be used to extract callback from array of arguments.\n * (caution) It modifies input param.\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\n\nfunction extractCallback(args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // 'pop' method modifies the original args array!\n  }\n}\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\n\nfunction validateArgs(args) {\n  if (args.length !== this.params) {\n    throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n  }\n}\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\n\nfunction formatInput(args) {\n  var _this = this; // If inputFormatter is not defined, or empty just return original args.\n\n\n  if (!this.inputFormatter || _.isEmpty(this.inputFormatter)) {\n    return args;\n  } // If inputFormatter is defined, map original args by calling formatter.\n\n\n  return this.inputFormatter.map(function (formatter, index) {\n    // bind this for defaultBlock, and defaultAccount\n    return formatter && formatter.call(_this, args[index]) || args[index];\n  });\n}\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\n\n\nfunction formatOutput(result) {\n  var _this = this; // If outputFormatter is defined, calling outputFormatter,\n  // If not, just return original res.\n\n\n  var _formatOutput = function _formatOutput(res) {\n    return typeof _this.outputFormatter === 'function' ? _this.outputFormatter(res) : res;\n  }; // If result is array, map it through calling _formatOuput\n  // If result is single, just calling _formatOutput.\n\n\n  return _.isArray(result) ? result.map(_formatOutput) : _formatOutput(result);\n}\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\n\n\nfunction toPayload(args) {\n  var call = this.getCall(args);\n  var callback = this.extractCallback(args);\n  var inputParams = this.formatInput(args);\n  this.validateArgs(inputParams);\n  var payload = {\n    method: call,\n    params: inputParams,\n    callback: callback\n  }; // If payload transform option is existing, apply it.\n  // If not, just return payload.\n\n  return this.transformPayload && this.transformPayload(payload) || payload;\n}\n\nvar buildSendTxCallbackFunc = function buildSendTxCallbackFunc(defer, method, payload, isSendTx) {\n  return function (err, result) {\n    try {\n      result = method.formatOutput(result);\n    } catch (e) {\n      if (!err) err = e;\n    }\n\n    err = result instanceof Error && result || err; // If err exists, fireError\n\n    if (err) {\n      return utils._fireError(err.error || err, // sometimes, err.error property exists, in case, fire it instead 'err'\n      defer.eventEmitter, defer.reject, payload.callback);\n    } // fire callback\n\n\n    if (payload.callback) payload.callback(null, result); // return PROMISE\n\n    if (!isSendTx) {\n      defer.resolve(result);\n    } else {\n      defer.eventEmitter.emit('transactionHash', result);\n\n      method._confirmTransaction(defer, result, payload);\n    }\n  };\n};\n\nvar buildSendSignedTxFunc = function buildSendSignedTxFunc(method, payload, sendTxCallback) {\n  return function (signed) {\n    var rawTransaction = signed.rawTransaction ? signed.rawTransaction : signed;\n\n    var signedPayload = _.extend({}, payload, {\n      method: 'klay_sendRawTransaction',\n      params: [rawTransaction]\n    });\n\n    method.requestManager.send(signedPayload, sendTxCallback);\n  };\n};\n\nvar buildSendRequestFunc = function buildSendRequestFunc(defer, sendSignedTx, sendTxCallback) {\n  return function (payload, method) {\n    var methodName = payload.method; // Logic for handling multiple cases of parameters in sendSignedTransaction.\n    // 1. Object containing rawTransaction\n    //    : call 'klay_sendRawTransaction' with RLP encoded transaction(rawTransaction) in object\n    // 2. A transaction object containing signatures or feePayerSignatures\n    //    : call 'getRawTransactionWithSignatures', then call 'klay_sendRawTransaction' with result of getRawTransactionWithSignatures\n\n    if (method && methodName === 'klay_sendRawTransaction') {\n      // The existence of accounts in the method means the implementation before the common architecture.\n      if (method.accounts) {\n        var transaction = payload.params[0];\n\n        if (typeof transaction !== 'string' && _.isObject(transaction)) {\n          if (transaction.rawTransaction) {\n            return sendSignedTx(transaction);\n          }\n\n          return method.accounts.getRawTransactionWithSignatures(transaction).then(sendSignedTx).catch(function (e) {\n            sendTxCallback(e);\n          });\n        }\n      } else {\n        var _transaction = payload.params[0];\n\n        if (!_.isString(_transaction) && _.isObject(_transaction) && _.isFunction(_transaction.getRLPEncoding)) {\n          return sendSignedTx(_transaction.getRLPEncoding());\n        }\n      }\n    } // In the previous implementation of common architecture,\n    // if there was an account in the in-memory wallet before requesting to send or sign a transaction to the node,\n    // it was handled by using it.\n\n\n    if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n      switch (methodName) {\n        case 'klay_sendTransaction':\n          {\n            var tx = payload.params[0];\n            var error;\n\n            if (!_.isObject(tx)) {\n              sendTxCallback(new Error('The transaction must be defined as an object.'));\n              return;\n            }\n\n            var addressToUse = tx.from;\n\n            if (tx.senderRawTransaction && tx.feePayer) {\n              addressToUse = tx.feePayer;\n\n              if (tx.from) {\n                console.log('\"from\" is ignored for a fee-delegated transaction.');\n                delete tx.from;\n              }\n            }\n\n            var wallet;\n\n            try {\n              wallet = method.accounts.wallet.getAccount(addressToUse);\n            } catch (e) {\n              sendTxCallback(e);\n              return;\n            }\n\n            if (wallet && wallet.privateKey) {\n              var privateKey = method.accounts._getRoleKey(tx, wallet); // If wallet was found, sign tx, and send using sendRawTransaction\n\n\n              return method.accounts.signTransaction(tx, privateKey).then(sendSignedTx).catch(function (e) {\n                sendTxCallback(e);\n              });\n            }\n\n            if (tx.signatures) {\n              // If signatures is defined inside of the transaction object,\n              // get rawTransaction string from signed transaction object and send to network\n              return method.accounts.getRawTransactionWithSignatures(tx).then(sendSignedTx).catch(function (e) {\n                sendTxCallback(e);\n              });\n            } // If wallet was not found in caver-js wallet, then it has to use wallet in Node.\n            // Signing to transaction using wallet in Node supports only LEGACY transaction, so if transaction is not LEGACY, return error.\n\n\n            if (tx.feePayer !== undefined || tx.type !== undefined && tx.type !== 'LEGACY') {\n              error = new Error(\"No private key found in the caver-js wallet. Trying to use the Klaytn node's wallet, but it only supports legacy transactions. Please add private key of \".concat(addressToUse, \" to the caver-js wallet.\"));\n              sendTxCallback(error);\n              return;\n            }\n\n            error = validateParams(tx);\n\n            if (error) {\n              sendTxCallback(error);\n              return;\n            }\n\n            break;\n          }\n\n        case 'klay_sign':\n          {\n            var data = payload.params[1];\n\n            var _wallet = method.accounts.wallet.getAccount(payload.params[0]);\n\n            if (_wallet && _wallet.privateKey) {\n              // If wallet was found, sign tx, and send using sendRawTransaction\n              var sign = method.accounts.sign(data, _wallet.privateKey);\n              if (payload.callback) payload.callback(null, sign.signature);\n              defer.resolve(sign.signature);\n              return;\n            }\n\n            break;\n          }\n      }\n    } // When sending a request to send or sign a transaction using a key stored in a Klaytn node,\n    // the variable names inside the transaction must be properly formatted.\n    // { _from: '0x..', _signatures: ['0x..', '0x..', '0x..'] } -> { from: '0x..', signatures: { V: '0x..', R: '0x..', S: '0x..'} }\n\n\n    if (methodName === 'klay_sendTransaction' || methodName === 'klay_sendTransactionAsFeePayer' || methodName === 'klay_signTransaction' || methodName === 'klay_signTransactionAsFeePayer') {\n      var _tx = {};\n      Object.keys(payload.params[0]).map(function (k) {\n        var key = k;\n        if (key.startsWith('_')) key = key.slice(1);\n\n        if (key === 'signatures' || key === 'feePayerSignatures') {\n          if (!utils.isEmptySig(payload.params[0][key])) {\n            _tx[key] = utils.transformSignaturesToObject(payload.params[0][key]);\n\n            if (key === 'signatures' && (methodName === 'klay_signTransaction' || methodName === 'klay_sendTransaction')) {\n              console.warn(\"When sign/send a transaction using the Node API, existing 'signatures' can be initialized.\");\n            }\n\n            if (key === 'feePayerSignatures' && (methodName === 'klay_signTransactionAsFeePayer' || methodName === 'klay_sendTransactionAsFeePayer')) {\n              console.warn(\"When sign/send a transaction using the Node API, existing 'feePayerSignatures' can be initialized.\");\n            }\n          }\n        } else if (key === 'codeFormat') {\n          _tx[key] = utils.hexToNumber(payload.params[0][key]);\n        } else if (key === 'account') {\n          _tx.key = payload.params[0][key].getRLPEncodingAccountKey();\n        } else if (payload.params[0][key] !== '0x') {\n          _tx[key] = payload.params[0][key];\n        }\n      });\n      payload.params[0] = _tx;\n    }\n\n    return method.requestManager.send(payload, sendTxCallback);\n  };\n};\n\nvar buildSendFunc = function buildSendFunc(method, isSendTx) {\n  return function () {\n    var defer = utils.promiEvent(!isSendTx);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var payload = method.toPayload(args);\n    var sendTxCallback = buildSendTxCallbackFunc(defer, method, payload, isSendTx);\n    var sendSignedTx = buildSendSignedTxFunc(method, payload, sendTxCallback);\n    var sendRequest = buildSendRequestFunc(defer, sendSignedTx, sendTxCallback);\n    var isGasPriceInputMissing = isSendTx && _.isObject(payload.params[0]) && payload.params[0].gasPrice === undefined; // If gasPrice input is missing, call getGasPrice rpc\n\n    if (!isGasPriceInputMissing) {\n      sendRequest(payload, method);\n      return defer.eventEmitter;\n    }\n\n    var getGasPrice = new Method({\n      name: 'getGasPrice',\n      call: 'klay_gasPrice',\n      params: 0\n    }).createFunction(method.requestManager);\n    getGasPrice(function (err, gasPrice) {\n      payload.params[0].gasPrice = gasPrice || payload.params[0].gasPrice;\n      sendRequest(payload, method);\n    });\n    /**\n     * attaching `.on('receipt')` is possible by returning defer.eventEmitter\n     */\n\n    return defer.eventEmitter;\n  };\n};\n\nfunction buildCall() {\n  var method = this;\n  var isSendTx = method.call === 'klay_sendTransaction' || method.call === 'klay_sendTransactionAsFeePayer' || method.call === 'klay_sendRawTransaction' || method.call === 'personal_sendTransaction' || method.call === 'personal_sendValueTransfer' || method.call === 'personal_sendAccountUpdate';\n  var send = buildSendFunc(method, isSendTx); // necessary to attach things to the method\n\n  send.method = method; // necessary for batch requests\n\n  send.request = this.request.bind(this);\n  return send;\n}\n\nfunction _confirmTransaction(defer, result, payload) {\n  var payloadTxObject = payload.params && _.isObject(payload.params[0]) && payload.params[0] || {}; // If payload.params[0] is RLP-encoded string, decode RLP-encoded string to Transaction instance.\n\n  if (_.isString(payload.params[0])) payloadTxObject = TransactionDecoder.decode(payload.params[0]); // mutableConfirmationPack will be used in\n  // 1) checkConfirmation,\n  // 2) startWatching functions\n  // It is * mutable *, both functions can affect properties mutably.\n\n  var mutableConfirmationPack = {\n    method: this,\n    promiseResolved: false,\n    canUnsubscribe: true,\n    timeoutCount: 0,\n    intervalId: null,\n    gasProvided: payloadTxObject.gas || null,\n    isContractDeployment: utils.isContractDeployment(payloadTxObject),\n    defer: defer,\n    result: result,\n    _klaytnCall: {}\n  };\n  addCustomSendMethod(mutableConfirmationPack);\n  kickoffConfirmation(mutableConfirmationPack);\n}\n\nvar addCustomSendMethod = function addCustomSendMethod(mutableConfirmationPack) {\n  var customSendMethods = [new Method({\n    name: 'getTransactionReceipt',\n    call: 'klay_getTransactionReceipt',\n    params: 1,\n    outputFormatter: !mutableConfirmationPack.method.outputFormatterDisable ? formatters.outputTransactionReceiptFormatter : undefined\n  }), new Method({\n    name: 'getCode',\n    call: 'klay_getCode',\n    params: 2,\n    inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n  }), new Subscriptions({\n    name: 'subscribe',\n    type: 'klay',\n    subscriptions: {\n      newBlockHeaders: {\n        subscriptionName: 'newHeads',\n        // replace subscription with this name\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      }\n    }\n  })]; // add custom send Methods\n\n  _.each(customSendMethods, function (mthd) {\n    // attach methods to _klaytnCall\n    mthd.attachToObject(mutableConfirmationPack._klaytnCall); // assign rather than call setRequestManager()\n\n    mthd.requestManager = mutableConfirmationPack.method.requestManager;\n  });\n};\n\nvar kickoffConfirmation = function kickoffConfirmation(mutableConfirmationPack) {\n  // eslint-disable-next-line no-unused-vars\n  var defer = mutableConfirmationPack.defer,\n      promiseResolved = mutableConfirmationPack.promiseResolved,\n      result = mutableConfirmationPack.result,\n      _klaytnCall = mutableConfirmationPack._klaytnCall; // first check if we already have a confirmed transaction\n\n  _klaytnCall.getTransactionReceipt(result).then(function (receipt) {\n    if (receipt && receipt.blockHash) {\n      // `isPolling` is false in default.\n      checkConfirmation(mutableConfirmationPack, receipt, false);\n    } else if (!promiseResolved) startWatching(mutableConfirmationPack, receipt);\n  }).catch(function () {\n    if (!promiseResolved) startWatching(mutableConfirmationPack);\n  });\n}; // start watching for confirmation depending on the support features of the provider\n\n\nvar startWatching = function startWatching(mutableConfirmationPack, existingReceipt) {\n  // eslint-disable-next-line no-unused-vars\n  var _klaytnCall = mutableConfirmationPack._klaytnCall,\n      intervalId = mutableConfirmationPack.intervalId,\n      method = mutableConfirmationPack.method; // if provider allows PUB/SUB\n\n  if (method.requestManager.provider.supportsSubscriptions()) {\n    _klaytnCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, mutableConfirmationPack, existingReceipt, false));\n  } else {\n    mutableConfirmationPack.intervalId = setInterval(checkConfirmation.bind(null, mutableConfirmationPack, existingReceipt, true), 1000);\n  }\n}; // fire \"receipt\" and confirmation events and resolve after\n\n\nvar checkConfirmation = function checkConfirmation(mutableConfirmationPack, existingReceipt, isPolling, err, blockHeader, sub) {\n  var intervalId = mutableConfirmationPack.intervalId,\n      defer = mutableConfirmationPack.defer,\n      method = mutableConfirmationPack.method,\n      canUnsubscribe = mutableConfirmationPack.canUnsubscribe,\n      _klaytnCall = mutableConfirmationPack._klaytnCall,\n      isContractDeployment = mutableConfirmationPack.isContractDeployment,\n      promiseResolved = mutableConfirmationPack.promiseResolved,\n      timeoutCount = mutableConfirmationPack.timeoutCount,\n      result = mutableConfirmationPack.result;\n\n  if (err) {\n    sub.unsubscribe();\n    mutableConfirmationPack.promiseResolved = true;\n\n    utils._fireError({\n      message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n      data: err\n    }, defer.eventEmitter, defer.reject);\n\n    return;\n  } // create fake unsubscribe\n\n\n  sub = sub || {\n    unsubscribe: function unsubscribe() {\n      return clearInterval(mutableConfirmationPack.intervalId);\n    }\n  }; // if we have a valid receipt we don't need to send a request\n\n  return (existingReceipt && utils.promiEvent.resolve(existingReceipt) || _klaytnCall.getTransactionReceipt(result)). // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n  then(function (receipt) {\n    checkIsReceiptInBlock(receipt);\n    var formattedReceipt = formatReceipt(receipt, method);\n    if (mutableConfirmationPack.promiseResolved) return;\n    return isContractDeployment ? checkForContractDeployment(mutableConfirmationPack, formattedReceipt, sub) : checkForNormalTx(mutableConfirmationPack, formattedReceipt, sub);\n  }).catch(countTimeout);\n};\n\nvar checkIsReceiptInBlock = function checkIsReceiptInBlock(receipt) {\n  if (receipt && !receipt.blockHash) throw errors.blockHashNull;\n};\n\nvar formatReceipt = function formatReceipt(receipt, method) {\n  if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n    receipt = method.extraFormatters.receiptFormatter(receipt);\n  }\n\n  return receipt;\n};\n\nvar countTimeout = function countTimeout(mutableConfirmationPack, isPolling, sub) {\n  // eslint-disable-next-line no-unused-vars\n  var defer = mutableConfirmationPack.defer,\n      timeoutCount = mutableConfirmationPack.timeoutCount,\n      promiseResolved = mutableConfirmationPack.promiseResolved; // time out the transaction if not mined after 50 blocks\n\n  mutableConfirmationPack.timeoutCount++; // check to see if we are http polling\n\n  if (isPolling) {\n    // polling timeout is different than TIMEOUTBLOCK blocks since we are triggering every second\n    if (mutableConfirmationPack.timeoutCount - 1 >= POLLINGTIMEOUT) {\n      sub.unsubscribe();\n      mutableConfirmationPack.promiseResolved = true;\n\n      utils._fireError(new Error(\"Transaction was not mined within\".concat(POLLINGTIMEOUT, \" seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!\")), defer.eventEmitter, defer.reject);\n    }\n  } else if (mutableConfirmationPack.timeoutCount - 1 >= TIMEOUTBLOCK) {\n    sub.unsubscribe();\n    mutableConfirmationPack.promiseResolved = true;\n\n    utils._fireError(new Error('Transaction was not mined within 50 blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n  }\n};\n\nvar checkForContractDeployment = function checkForContractDeployment(mutableConfirmationPack, receipt, sub) {\n  // eslint-disable-next-line no-unused-vars\n  var defer = mutableConfirmationPack.defer,\n      method = mutableConfirmationPack.method,\n      canUnsubscribe = mutableConfirmationPack.canUnsubscribe,\n      _klaytnCall = mutableConfirmationPack._klaytnCall,\n      promiseResolved = mutableConfirmationPack.promiseResolved; // If contract address doesn't exist, fire error.\n\n  if (!receipt.contractAddress) {\n    if (canUnsubscribe) {\n      sub.unsubscribe();\n      mutableConfirmationPack.promiseResolved = true;\n    }\n\n    utils._fireError(errors.receiptDidntContainContractAddress, defer.eventEmitter, defer.reject);\n\n    return;\n  }\n\n  if (!receipt.status && receipt.txError) {\n    var receiptJSON = JSON.stringify(receipt, null, 2);\n\n    utils._fireError(new Error(\"\".concat(errors.txErrorTable[receipt.txError], \"\\n \").concat(receiptJSON)), defer.eventEmitter, defer.reject);\n  }\n\n  _klaytnCall.getCode(receipt.contractAddress, function (e, code) {\n    if (!code) return;\n    defer.eventEmitter.emit('receipt', receipt); // if contract, return instance instead of receipt\n\n    defer.resolve(method.extraFormatters && method.extraFormatters.contractDeployFormatter && method.extraFormatters.contractDeployFormatter(receipt) || receipt); // need to remove listeners, as they aren't removed automatically when succesfull\n\n    if (canUnsubscribe) defer.eventEmitter.removeAllListeners();\n    if (canUnsubscribe) sub.unsubscribe();\n    mutableConfirmationPack.promiseResolved = true;\n  });\n\n  return receipt;\n};\n\nvar checkForNormalTx = function checkForNormalTx(mutableConfirmationPack, receipt, sub) {\n  // eslint-disable-next-line no-unused-vars\n  var defer = mutableConfirmationPack.defer,\n      canUnsubscribe = mutableConfirmationPack.canUnsubscribe,\n      promiseResolved = mutableConfirmationPack.promiseResolved,\n      gasProvided = mutableConfirmationPack.gasProvided;\n\n  if (receipt && !receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n    // Happy case: transaction is processed well. A.K.A 'well-done receipt'.\n    try {\n      mutableConfirmationPack.defer.eventEmitter.emit('receipt', receipt);\n      mutableConfirmationPack.defer.resolve(receipt);\n    } catch (e) {\n      console.log('receipt error', e);\n    } // need to remove listeners, as they aren't removed automatically when succesfull\n\n\n    if (canUnsubscribe) {\n      mutableConfirmationPack.defer.eventEmitter.removeAllListeners();\n    }\n  } else {\n    // Unhappy case: trasaction has error. A.K.A 'bad receipt'.\n    if (!receipt) return;\n    var receiptJSON = JSON.stringify(receipt, null, 2);\n    var txError = receipt.txError;\n\n    if (txError && errors.txErrorTable[txError]) {\n      utils._fireError(new Error(\"\".concat(errors.txErrorTable[txError], \"\\n \").concat(receiptJSON)), mutableConfirmationPack.defer.eventEmitter, mutableConfirmationPack.defer.reject);\n    } else if (receipt.status === false || receipt.status === '0x0') {\n      utils._fireError(errors.transactionReverted(receiptJSON), mutableConfirmationPack.defer.eventEmitter, mutableConfirmationPack.defer.reject);\n    } else if (receipt.gasUsed >= gasProvided) {\n      utils._fireError(errors.transactionRanOutOfGas(receiptJSON), mutableConfirmationPack.defer.eventEmitter, mutableConfirmationPack.defer.reject);\n    } else {\n      utils._fireError(errors.transactionRanOutOfGas(receiptJSON), mutableConfirmationPack.defer.eventEmitter, mutableConfirmationPack.defer.reject);\n    }\n  }\n\n  if (canUnsubscribe) sub.unsubscribe();\n  mutableConfirmationPack.promiseResolved = true;\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\n\n\nfunction request() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  var payload = this.toPayload(args);\n  payload.format = this.formatOutput.bind(this);\n  return payload;\n}\n\nmodule.exports = Method;","map":{"version":3,"sources":["/Users/kimdoheon/IdeaProjects/skkrypto/Back_End/demo/frontend/node_modules/caver-js/packages/caver-core-method/src/index.js"],"names":["_","require","errors","formatters","utils","Subscriptions","subscriptions","validateParams","validateFunction","TIMEOUTBLOCK","AVERAGE_BLOCK_TIME","POLLINGTIMEOUT","TransactionDecoder","Method","options","call","name","needNameCallPropertyToCreateMethod","hexCall","params","inputFormatter","outputFormatter","transformPayload","extraFormatters","requestManager","accounts","defaultBlock","defaultAccount","outputFormatterDisable","prototype","setRequestManager","createFunction","attachToObject","getCall","extractCallback","validateArgs","formatInput","formatOutput","toPayload","buildCall","_confirmTransaction","request","func","obj","split","callName","optionalName","args","isHexParameter","isFunction","length","pop","InvalidNumberOfParams","_this","isEmpty","map","formatter","index","result","_formatOutput","res","isArray","callback","inputParams","payload","method","buildSendTxCallbackFunc","defer","isSendTx","err","e","Error","_fireError","error","eventEmitter","reject","resolve","emit","buildSendSignedTxFunc","sendTxCallback","signed","rawTransaction","signedPayload","extend","send","buildSendRequestFunc","sendSignedTx","methodName","transaction","isObject","getRawTransactionWithSignatures","then","catch","isString","getRLPEncoding","wallet","tx","addressToUse","from","senderRawTransaction","feePayer","console","log","getAccount","privateKey","_getRoleKey","signTransaction","signatures","undefined","type","data","sign","signature","Object","keys","k","key","startsWith","slice","isEmptySig","transformSignaturesToObject","warn","hexToNumber","getRLPEncodingAccountKey","buildSendFunc","promiEvent","sendRequest","isGasPriceInputMissing","gasPrice","getGasPrice","bind","payloadTxObject","decode","mutableConfirmationPack","promiseResolved","canUnsubscribe","timeoutCount","intervalId","gasProvided","gas","isContractDeployment","_klaytnCall","addCustomSendMethod","kickoffConfirmation","customSendMethods","outputTransactionReceiptFormatter","inputAddressFormatter","inputDefaultBlockNumberFormatter","newBlockHeaders","subscriptionName","outputBlockFormatter","each","mthd","getTransactionReceipt","receipt","blockHash","checkConfirmation","startWatching","existingReceipt","provider","supportsSubscriptions","subscribe","setInterval","isPolling","blockHeader","sub","unsubscribe","message","clearInterval","checkIsReceiptInBlock","formattedReceipt","formatReceipt","checkForContractDeployment","checkForNormalTx","countTimeout","blockHashNull","receiptFormatter","contractAddress","receiptDidntContainContractAddress","status","txError","receiptJSON","JSON","stringify","txErrorTable","getCode","code","contractDeployFormatter","removeAllListeners","outOfGas","gasUsed","transactionReverted","transactionRanOutOfGas","format","module","exports"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,0BAAD,CAAP,CAAoCC,MAAnD;;AACA,IAAMC,UAAU,GAAGF,OAAO,CAAC,0BAAD,CAAP,CAAoCE,UAAvD;;AACA,IAAMC,KAAK,GAAGH,OAAO,CAAC,mBAAD,CAArB;;AACA,IAAMI,aAAa,GAAGJ,OAAO,CAAC,gCAAD,CAAP,CAA0CK,aAAhE;;AACA,IAAMC,cAAc,GAAGN,OAAO,CAAC,0BAAD,CAAP,CAAoCO,gBAApC,CAAqDD,cAA5E;;AAEA,IAAME,YAAY,GAAG,EAArB;AACA,IAAMC,kBAAkB,GAAG,CAA3B,C,CAA6B;;AAC7B,IAAMC,cAAc,GAAGD,kBAAkB,GAAGD,YAA5C,C,CAAyD;;AAEzD,IAAMG,kBAAkB,GAAGX,OAAO,CAAC,mEAAD,CAAlC;;AAEA,SAASY,MAAT,CAAgBC,OAAhB,EAAyB;AACrB;AACA,MAAI,CAACA,OAAO,CAACC,IAAT,IAAiB,CAACD,OAAO,CAACE,IAA9B,EAAoC,MAAMd,MAAM,CAACe,kCAAb;AAEpC,OAAKD,IAAL,GAAYF,OAAO,CAACE,IAApB;AACA,OAAKD,IAAL,GAAYD,OAAO,CAACC,IAApB;AACA,OAAKG,OAAL,GAAeJ,OAAO,CAACI,OAAvB;AACA,OAAKC,MAAL,GAAcL,OAAO,CAACK,MAAR,IAAkB,CAAhC;AACA,OAAKC,cAAL,GAAsBN,OAAO,CAACM,cAAR,IAA0B,EAAhD;AACA,OAAKC,eAAL,GAAuBP,OAAO,CAACO,eAA/B;AACA,OAAKC,gBAAL,GAAwBR,OAAO,CAACQ,gBAAhC;AACA,OAAKC,eAAL,GAAuBT,OAAO,CAACS,eAA/B;AAEA,OAAKC,cAAL,GAAsBV,OAAO,CAACU,cAA9B,CAbqB,CAerB;;AACA,OAAKC,QAAL,GAAgBX,OAAO,CAACW,QAAxB;AAEA,OAAKC,YAAL,GAAoBZ,OAAO,CAACY,YAAR,IAAwB,QAA5C;AACA,OAAKC,cAAL,GAAsBb,OAAO,CAACa,cAAR,IAA0B,IAAhD;AAEA,OAAKC,sBAAL,GAA8Bd,OAAO,CAACc,sBAAtC;AACH;;AAEDf,MAAM,CAACgB,SAAP,CAAiBC,iBAAjB,GAAqCA,iBAArC;AACAjB,MAAM,CAACgB,SAAP,CAAiBE,cAAjB,GAAkCA,cAAlC;AACAlB,MAAM,CAACgB,SAAP,CAAiBG,cAAjB,GAAkCA,cAAlC;AACAnB,MAAM,CAACgB,SAAP,CAAiBI,OAAjB,GAA2BA,OAA3B;AACApB,MAAM,CAACgB,SAAP,CAAiBK,eAAjB,GAAmCA,eAAnC;AACArB,MAAM,CAACgB,SAAP,CAAiBM,YAAjB,GAAgCA,YAAhC;AACAtB,MAAM,CAACgB,SAAP,CAAiBO,WAAjB,GAA+BA,WAA/B;AACAvB,MAAM,CAACgB,SAAP,CAAiBQ,YAAjB,GAAgCA,YAAhC;AACAxB,MAAM,CAACgB,SAAP,CAAiBS,SAAjB,GAA6BA,SAA7B;AACAzB,MAAM,CAACgB,SAAP,CAAiBU,SAAjB,GAA6BA,SAA7B;AACA1B,MAAM,CAACgB,SAAP,CAAiBW,mBAAjB,GAAuCA,mBAAvC;AACA3B,MAAM,CAACgB,SAAP,CAAiBY,OAAjB,GAA2BA,OAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASX,iBAAT,CAA2BN,cAA3B,EAA2CC,QAA3C,EAAqD;AACjD,OAAKD,cAAL,GAAsBA,cAAtB,CADiD,CAGjD;;AACA,MAAIC,QAAJ,EAAc,KAAKA,QAAL,GAAgBA,QAAhB;AACjB;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,cAAT,CAAwBP,cAAxB,EAAwCC,QAAxC,EAAkD;AAC9C;AACA,OAAKK,iBAAL,CAAuBN,cAAc,IAAI,KAAKA,cAA9C,EAA8DC,QAAQ,IAAI,KAAKA,QAA/E,EAF8C,CAI9C;;AACA,MAAMiB,IAAI,GAAG,KAAKH,SAAL,EAAb,CAL8C,CAO9C;AACA;;AACAG,EAAAA,IAAI,CAAC3B,IAAL,GAAY,KAAKA,IAAjB;AAEA,SAAO2B,IAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASV,cAAT,CAAwBW,GAAxB,EAA6B;AACzB,MAAMD,IAAI,GAAG,KAAKH,SAAL,EAAb;AACAG,EAAAA,IAAI,CAAC3B,IAAL,GAAY,KAAKA,IAAjB;;AAFyB,yBAGQ,KAAKC,IAAL,CAAU4B,KAAV,CAAgB,GAAhB,CAHR;AAAA;AAAA,MAGlBC,QAHkB;AAAA,MAGRC,YAHQ;;AAKzB,MAAIA,YAAJ,EAAkB;AACdH,IAAAA,GAAG,CAACE,QAAD,CAAH,GAAgBF,GAAG,CAACE,QAAD,CAAH,IAAiB,EAAjC;AACAF,IAAAA,GAAG,CAACE,QAAD,CAAH,CAAcC,YAAd,IAA8BJ,IAA9B;AACH,GAHD,MAGO;AACHC,IAAAA,GAAG,CAACE,QAAD,CAAH,GAAgBH,IAAhB;AACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAST,OAAT,CAAiBc,IAAjB,EAAuB;AACnB;AACA;AACA;AACA,SAAO,KAAK7B,OAAL,IAAgBd,KAAK,CAAC4C,cAAN,CAAqBD,IAAI,CAAC,CAAD,CAAzB,CAAhB,GAAgD,KAAK7B,OAArD,GAA+D,KAAKH,IAA3E;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASmB,eAAT,CAAyBa,IAAzB,EAA+B;AAC3B,MAAI/C,CAAC,CAACiD,UAAF,CAAaF,IAAI,CAACA,IAAI,CAACG,MAAL,GAAc,CAAf,CAAjB,CAAJ,EAAyC;AACrC,WAAOH,IAAI,CAACI,GAAL,EAAP,CADqC,CACnB;AACrB;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAShB,YAAT,CAAsBY,IAAtB,EAA4B;AACxB,MAAIA,IAAI,CAACG,MAAL,KAAgB,KAAK/B,MAAzB,EAAiC;AAC7B,UAAMjB,MAAM,CAACkD,qBAAP,CAA6BL,IAAI,CAACG,MAAlC,EAA0C,KAAK/B,MAA/C,EAAuD,KAAKH,IAA5D,CAAN;AACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASoB,WAAT,CAAqBW,IAArB,EAA2B;AACvB,MAAMM,KAAK,GAAG,IAAd,CADuB,CAGvB;;;AACA,MAAI,CAAC,KAAKjC,cAAN,IAAwBpB,CAAC,CAACsD,OAAF,CAAU,KAAKlC,cAAf,CAA5B,EAA4D;AACxD,WAAO2B,IAAP;AACH,GANsB,CAQvB;;;AACA,SAAO,KAAK3B,cAAL,CAAoBmC,GAApB,CAAwB,UAACC,SAAD,EAAYC,KAAZ,EAAsB;AACjD;AACA,WAAQD,SAAS,IAAIA,SAAS,CAACzC,IAAV,CAAesC,KAAf,EAAsBN,IAAI,CAACU,KAAD,CAA1B,CAAd,IAAqDV,IAAI,CAACU,KAAD,CAAhE;AACH,GAHM,CAAP;AAIH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASpB,YAAT,CAAsBqB,MAAtB,EAA8B;AAC1B,MAAML,KAAK,GAAG,IAAd,CAD0B,CAG1B;AACA;;;AACA,MAAMM,aAAa,GAAG,SAAhBA,aAAgB,CAAAC,GAAG;AAAA,WAAK,OAAOP,KAAK,CAAChC,eAAb,KAAiC,UAAjC,GAA8CgC,KAAK,CAAChC,eAAN,CAAsBuC,GAAtB,CAA9C,GAA2EA,GAAhF;AAAA,GAAzB,CAL0B,CAO1B;AACA;;;AACA,SAAO5D,CAAC,CAAC6D,OAAF,CAAUH,MAAV,IAAoBA,MAAM,CAACH,GAAP,CAAWI,aAAX,CAApB,GAAgDA,aAAa,CAACD,MAAD,CAApE;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASpB,SAAT,CAAmBS,IAAnB,EAAyB;AACrB,MAAMhC,IAAI,GAAG,KAAKkB,OAAL,CAAac,IAAb,CAAb;AACA,MAAMe,QAAQ,GAAG,KAAK5B,eAAL,CAAqBa,IAArB,CAAjB;AACA,MAAMgB,WAAW,GAAG,KAAK3B,WAAL,CAAiBW,IAAjB,CAApB;AACA,OAAKZ,YAAL,CAAkB4B,WAAlB;AAEA,MAAMC,OAAO,GAAG;AACZC,IAAAA,MAAM,EAAElD,IADI;AAEZI,IAAAA,MAAM,EAAE4C,WAFI;AAGZD,IAAAA,QAAQ,EAARA;AAHY,GAAhB,CANqB,CAYrB;AACA;;AACA,SAAQ,KAAKxC,gBAAL,IAAyB,KAAKA,gBAAL,CAAsB0C,OAAtB,CAA1B,IAA6DA,OAApE;AACH;;AAED,IAAME,uBAAuB,GAAG,SAA1BA,uBAA0B,CAACC,KAAD,EAAQF,MAAR,EAAgBD,OAAhB,EAAyBI,QAAzB;AAAA,SAAsC,UAACC,GAAD,EAAMX,MAAN,EAAiB;AACnF,QAAI;AACAA,MAAAA,MAAM,GAAGO,MAAM,CAAC5B,YAAP,CAAoBqB,MAApB,CAAT;AACH,KAFD,CAEE,OAAOY,CAAP,EAAU;AACR,UAAI,CAACD,GAAL,EAAUA,GAAG,GAAGC,CAAN;AACb;;AAEDD,IAAAA,GAAG,GAAIX,MAAM,YAAYa,KAAlB,IAA2Bb,MAA5B,IAAuCW,GAA7C,CAPmF,CASnF;;AACA,QAAIA,GAAJ,EAAS;AACL,aAAOjE,KAAK,CAACoE,UAAN,CACHH,GAAG,CAACI,KAAJ,IAAaJ,GADV,EACe;AAClBF,MAAAA,KAAK,CAACO,YAFH,EAGHP,KAAK,CAACQ,MAHH,EAIHX,OAAO,CAACF,QAJL,CAAP;AAMH,KAjBkF,CAmBnF;;;AACA,QAAIE,OAAO,CAACF,QAAZ,EAAsBE,OAAO,CAACF,QAAR,CAAiB,IAAjB,EAAuBJ,MAAvB,EApB6D,CAsBnF;;AACA,QAAI,CAACU,QAAL,EAAe;AACXD,MAAAA,KAAK,CAACS,OAAN,CAAclB,MAAd;AACH,KAFD,MAEO;AACHS,MAAAA,KAAK,CAACO,YAAN,CAAmBG,IAAnB,CAAwB,iBAAxB,EAA2CnB,MAA3C;;AACAO,MAAAA,MAAM,CAACzB,mBAAP,CAA2B2B,KAA3B,EAAkCT,MAAlC,EAA0CM,OAA1C;AACH;AACJ,GA7B+B;AAAA,CAAhC;;AA+BA,IAAMc,qBAAqB,GAAG,SAAxBA,qBAAwB,CAACb,MAAD,EAASD,OAAT,EAAkBe,cAAlB;AAAA,SAAqC,UAAAC,MAAM,EAAI;AACzE,QAAMC,cAAc,GAAGD,MAAM,CAACC,cAAP,GAAwBD,MAAM,CAACC,cAA/B,GAAgDD,MAAvE;;AACA,QAAME,aAAa,GAAGlF,CAAC,CAACmF,MAAF,CAAS,EAAT,EAAanB,OAAb,EAAsB;AACxCC,MAAAA,MAAM,EAAE,yBADgC;AAExC9C,MAAAA,MAAM,EAAE,CAAC8D,cAAD;AAFgC,KAAtB,CAAtB;;AAKAhB,IAAAA,MAAM,CAACzC,cAAP,CAAsB4D,IAAtB,CAA2BF,aAA3B,EAA0CH,cAA1C;AACH,GAR6B;AAAA,CAA9B;;AAUA,IAAMM,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAClB,KAAD,EAAQmB,YAAR,EAAsBP,cAAtB;AAAA,SAAyC,UAACf,OAAD,EAAUC,MAAV,EAAqB;AACvF,QAAMsB,UAAU,GAAGvB,OAAO,CAACC,MAA3B,CADuF,CAEvF;AACA;AACA;AACA;AACA;;AACA,QAAIA,MAAM,IAAIsB,UAAU,KAAK,yBAA7B,EAAwD;AACpD;AACA,UAAItB,MAAM,CAACxC,QAAX,EAAqB;AACjB,YAAM+D,WAAW,GAAGxB,OAAO,CAAC7C,MAAR,CAAe,CAAf,CAApB;;AACA,YAAI,OAAOqE,WAAP,KAAuB,QAAvB,IAAmCxF,CAAC,CAACyF,QAAF,CAAWD,WAAX,CAAvC,EAAgE;AAC5D,cAAIA,WAAW,CAACP,cAAhB,EAAgC;AAC5B,mBAAOK,YAAY,CAACE,WAAD,CAAnB;AACH;;AACD,iBAAOvB,MAAM,CAACxC,QAAP,CACFiE,+BADE,CAC8BF,WAD9B,EAEFG,IAFE,CAEGL,YAFH,EAGFM,KAHE,CAGI,UAAAtB,CAAC,EAAI;AACRS,YAAAA,cAAc,CAACT,CAAD,CAAd;AACH,WALE,CAAP;AAMH;AACJ,OAbD,MAaO;AACH,YAAMkB,YAAW,GAAGxB,OAAO,CAAC7C,MAAR,CAAe,CAAf,CAApB;;AACA,YAAI,CAACnB,CAAC,CAAC6F,QAAF,CAAWL,YAAX,CAAD,IAA4BxF,CAAC,CAACyF,QAAF,CAAWD,YAAX,CAA5B,IAAuDxF,CAAC,CAACiD,UAAF,CAAauC,YAAW,CAACM,cAAzB,CAA3D,EAAqG;AACjG,iBAAOR,YAAY,CAACE,YAAW,CAACM,cAAZ,EAAD,CAAnB;AACH;AACJ;AACJ,KA5BsF,CA8BvF;AACA;AACA;;;AACA,QAAI7B,MAAM,IAAIA,MAAM,CAACxC,QAAjB,IAA6BwC,MAAM,CAACxC,QAAP,CAAgBsE,MAA7C,IAAuD9B,MAAM,CAACxC,QAAP,CAAgBsE,MAAhB,CAAuB7C,MAAlF,EAA0F;AACtF,cAAQqC,UAAR;AACI,aAAK,sBAAL;AAA6B;AACzB,gBAAMS,EAAE,GAAGhC,OAAO,CAAC7C,MAAR,CAAe,CAAf,CAAX;AAEA,gBAAIsD,KAAJ;;AACA,gBAAI,CAACzE,CAAC,CAACyF,QAAF,CAAWO,EAAX,CAAL,EAAqB;AACjBjB,cAAAA,cAAc,CAAC,IAAIR,KAAJ,CAAU,+CAAV,CAAD,CAAd;AACA;AACH;;AAED,gBAAI0B,YAAY,GAAGD,EAAE,CAACE,IAAtB;;AAEA,gBAAIF,EAAE,CAACG,oBAAH,IAA2BH,EAAE,CAACI,QAAlC,EAA4C;AACxCH,cAAAA,YAAY,GAAGD,EAAE,CAACI,QAAlB;;AACA,kBAAIJ,EAAE,CAACE,IAAP,EAAa;AACTG,gBAAAA,OAAO,CAACC,GAAR,CAAY,oDAAZ;AACA,uBAAON,EAAE,CAACE,IAAV;AACH;AACJ;;AAED,gBAAIH,MAAJ;;AAEA,gBAAI;AACAA,cAAAA,MAAM,GAAG9B,MAAM,CAACxC,QAAP,CAAgBsE,MAAhB,CAAuBQ,UAAvB,CAAkCN,YAAlC,CAAT;AACH,aAFD,CAEE,OAAO3B,CAAP,EAAU;AACRS,cAAAA,cAAc,CAACT,CAAD,CAAd;AACA;AACH;;AAED,gBAAIyB,MAAM,IAAIA,MAAM,CAACS,UAArB,EAAiC;AAC7B,kBAAMA,UAAU,GAAGvC,MAAM,CAACxC,QAAP,CAAgBgF,WAAhB,CAA4BT,EAA5B,EAAgCD,MAAhC,CAAnB,CAD6B,CAE7B;;;AACA,qBAAO9B,MAAM,CAACxC,QAAP,CACFiF,eADE,CACcV,EADd,EACkBQ,UADlB,EAEFb,IAFE,CAEGL,YAFH,EAGFM,KAHE,CAGI,UAAAtB,CAAC,EAAI;AACRS,gBAAAA,cAAc,CAACT,CAAD,CAAd;AACH,eALE,CAAP;AAMH;;AACD,gBAAI0B,EAAE,CAACW,UAAP,EAAmB;AACf;AACA;AACA,qBAAO1C,MAAM,CAACxC,QAAP,CACFiE,+BADE,CAC8BM,EAD9B,EAEFL,IAFE,CAEGL,YAFH,EAGFM,KAHE,CAGI,UAAAtB,CAAC,EAAI;AACRS,gBAAAA,cAAc,CAACT,CAAD,CAAd;AACH,eALE,CAAP;AAMH,aA/CwB,CAiDzB;AACA;;;AACA,gBAAI0B,EAAE,CAACI,QAAH,KAAgBQ,SAAhB,IAA8BZ,EAAE,CAACa,IAAH,KAAYD,SAAZ,IAAyBZ,EAAE,CAACa,IAAH,KAAY,QAAvE,EAAkF;AAC9EpC,cAAAA,KAAK,GAAG,IAAIF,KAAJ,oKACwJ0B,YADxJ,8BAAR;AAGAlB,cAAAA,cAAc,CAACN,KAAD,CAAd;AACA;AACH;;AAEDA,YAAAA,KAAK,GAAGlE,cAAc,CAACyF,EAAD,CAAtB;;AACA,gBAAIvB,KAAJ,EAAW;AACPM,cAAAA,cAAc,CAACN,KAAD,CAAd;AACA;AACH;;AACD;AACH;;AACD,aAAK,WAAL;AAAkB;AACd,gBAAMqC,IAAI,GAAG9C,OAAO,CAAC7C,MAAR,CAAe,CAAf,CAAb;;AACA,gBAAM4E,OAAM,GAAG9B,MAAM,CAACxC,QAAP,CAAgBsE,MAAhB,CAAuBQ,UAAvB,CAAkCvC,OAAO,CAAC7C,MAAR,CAAe,CAAf,CAAlC,CAAf;;AAEA,gBAAI4E,OAAM,IAAIA,OAAM,CAACS,UAArB,EAAiC;AAC7B;AACA,kBAAMO,IAAI,GAAG9C,MAAM,CAACxC,QAAP,CAAgBsF,IAAhB,CAAqBD,IAArB,EAA2Bf,OAAM,CAACS,UAAlC,CAAb;AAEA,kBAAIxC,OAAO,CAACF,QAAZ,EAAsBE,OAAO,CAACF,QAAR,CAAiB,IAAjB,EAAuBiD,IAAI,CAACC,SAA5B;AAEtB7C,cAAAA,KAAK,CAACS,OAAN,CAAcmC,IAAI,CAACC,SAAnB;AACA;AACH;;AACD;AACH;AAjFL;AAmFH,KArHsF,CAuHvF;AACA;AACA;;;AACA,QACIzB,UAAU,KAAK,sBAAf,IACAA,UAAU,KAAK,gCADf,IAEAA,UAAU,KAAK,sBAFf,IAGAA,UAAU,KAAK,gCAJnB,EAKE;AACE,UAAMS,GAAE,GAAG,EAAX;AACAiB,MAAAA,MAAM,CAACC,IAAP,CAAYlD,OAAO,CAAC7C,MAAR,CAAe,CAAf,CAAZ,EAA+BoC,GAA/B,CAAmC,UAAA4D,CAAC,EAAI;AACpC,YAAIC,GAAG,GAAGD,CAAV;AACA,YAAIC,GAAG,CAACC,UAAJ,CAAe,GAAf,CAAJ,EAAyBD,GAAG,GAAGA,GAAG,CAACE,KAAJ,CAAU,CAAV,CAAN;;AACzB,YAAIF,GAAG,KAAK,YAAR,IAAwBA,GAAG,KAAK,oBAApC,EAA0D;AACtD,cAAI,CAAChH,KAAK,CAACmH,UAAN,CAAiBvD,OAAO,CAAC7C,MAAR,CAAe,CAAf,EAAkBiG,GAAlB,CAAjB,CAAL,EAA+C;AAC3CpB,YAAAA,GAAE,CAACoB,GAAD,CAAF,GAAUhH,KAAK,CAACoH,2BAAN,CAAkCxD,OAAO,CAAC7C,MAAR,CAAe,CAAf,EAAkBiG,GAAlB,CAAlC,CAAV;;AAEA,gBAAIA,GAAG,KAAK,YAAR,KAAyB7B,UAAU,KAAK,sBAAf,IAAyCA,UAAU,KAAK,sBAAjF,CAAJ,EAA8G;AAC1Gc,cAAAA,OAAO,CAACoB,IAAR;AACH;;AAED,gBACIL,GAAG,KAAK,oBAAR,KACC7B,UAAU,KAAK,gCAAf,IAAmDA,UAAU,KAAK,gCADnE,CADJ,EAGE;AACEc,cAAAA,OAAO,CAACoB,IAAR;AACH;AACJ;AACJ,SAfD,MAeO,IAAIL,GAAG,KAAK,YAAZ,EAA0B;AAC7BpB,UAAAA,GAAE,CAACoB,GAAD,CAAF,GAAUhH,KAAK,CAACsH,WAAN,CAAkB1D,OAAO,CAAC7C,MAAR,CAAe,CAAf,EAAkBiG,GAAlB,CAAlB,CAAV;AACH,SAFM,MAEA,IAAIA,GAAG,KAAK,SAAZ,EAAuB;AAC1BpB,UAAAA,GAAE,CAACoB,GAAH,GAASpD,OAAO,CAAC7C,MAAR,CAAe,CAAf,EAAkBiG,GAAlB,EAAuBO,wBAAvB,EAAT;AACH,SAFM,MAEA,IAAI3D,OAAO,CAAC7C,MAAR,CAAe,CAAf,EAAkBiG,GAAlB,MAA2B,IAA/B,EAAqC;AACxCpB,UAAAA,GAAE,CAACoB,GAAD,CAAF,GAAUpD,OAAO,CAAC7C,MAAR,CAAe,CAAf,EAAkBiG,GAAlB,CAAV;AACH;AACJ,OAzBD;AA0BApD,MAAAA,OAAO,CAAC7C,MAAR,CAAe,CAAf,IAAoB6E,GAApB;AACH;;AAED,WAAO/B,MAAM,CAACzC,cAAP,CAAsB4D,IAAtB,CAA2BpB,OAA3B,EAAoCe,cAApC,CAAP;AACH,GA/J4B;AAAA,CAA7B;;AAiKA,IAAM6C,aAAa,GAAG,SAAhBA,aAAgB,CAAC3D,MAAD,EAASG,QAAT;AAAA,SAAsB,YAAa;AACrD,QAAMD,KAAK,GAAG/D,KAAK,CAACyH,UAAN,CAAiB,CAACzD,QAAlB,CAAd;;AADqD,sCAATrB,IAAS;AAATA,MAAAA,IAAS;AAAA;;AAErD,QAAMiB,OAAO,GAAGC,MAAM,CAAC3B,SAAP,CAAiBS,IAAjB,CAAhB;AAEA,QAAMgC,cAAc,GAAGb,uBAAuB,CAACC,KAAD,EAAQF,MAAR,EAAgBD,OAAhB,EAAyBI,QAAzB,CAA9C;AACA,QAAMkB,YAAY,GAAGR,qBAAqB,CAACb,MAAD,EAASD,OAAT,EAAkBe,cAAlB,CAA1C;AACA,QAAM+C,WAAW,GAAGzC,oBAAoB,CAAClB,KAAD,EAAQmB,YAAR,EAAsBP,cAAtB,CAAxC;AAEA,QAAMgD,sBAAsB,GAAG3D,QAAQ,IAAIpE,CAAC,CAACyF,QAAF,CAAWzB,OAAO,CAAC7C,MAAR,CAAe,CAAf,CAAX,CAAZ,IAA6C6C,OAAO,CAAC7C,MAAR,CAAe,CAAf,EAAkB6G,QAAlB,KAA+BpB,SAA3G,CARqD,CAUrD;;AACA,QAAI,CAACmB,sBAAL,EAA6B;AACzBD,MAAAA,WAAW,CAAC9D,OAAD,EAAUC,MAAV,CAAX;AACA,aAAOE,KAAK,CAACO,YAAb;AACH;;AAED,QAAMuD,WAAW,GAAG,IAAIpH,MAAJ,CAAW;AAC3BG,MAAAA,IAAI,EAAE,aADqB;AAE3BD,MAAAA,IAAI,EAAE,eAFqB;AAG3BI,MAAAA,MAAM,EAAE;AAHmB,KAAX,EAIjBY,cAJiB,CAIFkC,MAAM,CAACzC,cAJL,CAApB;AAMAyG,IAAAA,WAAW,CAAC,UAAC5D,GAAD,EAAM2D,QAAN,EAAmB;AAC3BhE,MAAAA,OAAO,CAAC7C,MAAR,CAAe,CAAf,EAAkB6G,QAAlB,GAA6BA,QAAQ,IAAIhE,OAAO,CAAC7C,MAAR,CAAe,CAAf,EAAkB6G,QAA3D;AACAF,MAAAA,WAAW,CAAC9D,OAAD,EAAUC,MAAV,CAAX;AACH,KAHU,CAAX;AAKA;AACJ;AACA;;AACI,WAAOE,KAAK,CAACO,YAAb;AACH,GA/BqB;AAAA,CAAtB;;AAiCA,SAASnC,SAAT,GAAqB;AACjB,MAAM0B,MAAM,GAAG,IAAf;AACA,MAAMG,QAAQ,GACVH,MAAM,CAAClD,IAAP,KAAgB,sBAAhB,IACAkD,MAAM,CAAClD,IAAP,KAAgB,gCADhB,IAEAkD,MAAM,CAAClD,IAAP,KAAgB,yBAFhB,IAGAkD,MAAM,CAAClD,IAAP,KAAgB,0BAHhB,IAIAkD,MAAM,CAAClD,IAAP,KAAgB,4BAJhB,IAKAkD,MAAM,CAAClD,IAAP,KAAgB,4BANpB;AAQA,MAAMqE,IAAI,GAAGwC,aAAa,CAAC3D,MAAD,EAASG,QAAT,CAA1B,CAViB,CAWjB;;AACAgB,EAAAA,IAAI,CAACnB,MAAL,GAAcA,MAAd,CAZiB,CAajB;;AACAmB,EAAAA,IAAI,CAAC3C,OAAL,GAAe,KAAKA,OAAL,CAAayF,IAAb,CAAkB,IAAlB,CAAf;AACA,SAAO9C,IAAP;AACH;;AAED,SAAS5C,mBAAT,CAA6B2B,KAA7B,EAAoCT,MAApC,EAA4CM,OAA5C,EAAqD;AACjD,MAAImE,eAAe,GAAInE,OAAO,CAAC7C,MAAR,IAAkBnB,CAAC,CAACyF,QAAF,CAAWzB,OAAO,CAAC7C,MAAR,CAAe,CAAf,CAAX,CAAlB,IAAmD6C,OAAO,CAAC7C,MAAR,CAAe,CAAf,CAApD,IAA0E,EAAhG,CADiD,CAGjD;;AACA,MAAInB,CAAC,CAAC6F,QAAF,CAAW7B,OAAO,CAAC7C,MAAR,CAAe,CAAf,CAAX,CAAJ,EAAmCgH,eAAe,GAAGvH,kBAAkB,CAACwH,MAAnB,CAA0BpE,OAAO,CAAC7C,MAAR,CAAe,CAAf,CAA1B,CAAlB,CAJc,CAMjD;AACA;AACA;AACA;;AACA,MAAMkH,uBAAuB,GAAG;AAC5BpE,IAAAA,MAAM,EAAE,IADoB;AAE5BqE,IAAAA,eAAe,EAAE,KAFW;AAG5BC,IAAAA,cAAc,EAAE,IAHY;AAI5BC,IAAAA,YAAY,EAAE,CAJc;AAK5BC,IAAAA,UAAU,EAAE,IALgB;AAM5BC,IAAAA,WAAW,EAAEP,eAAe,CAACQ,GAAhB,IAAuB,IANR;AAO5BC,IAAAA,oBAAoB,EAAExI,KAAK,CAACwI,oBAAN,CAA2BT,eAA3B,CAPM;AAQ5BhE,IAAAA,KAAK,EAALA,KAR4B;AAS5BT,IAAAA,MAAM,EAANA,MAT4B;AAU5BmF,IAAAA,WAAW,EAAE;AAVe,GAAhC;AAaAC,EAAAA,mBAAmB,CAACT,uBAAD,CAAnB;AAEAU,EAAAA,mBAAmB,CAACV,uBAAD,CAAnB;AACH;;AAED,IAAMS,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAAT,uBAAuB,EAAI;AACnD,MAAMW,iBAAiB,GAAG,CACtB,IAAInI,MAAJ,CAAW;AACPG,IAAAA,IAAI,EAAE,uBADC;AAEPD,IAAAA,IAAI,EAAE,4BAFC;AAGPI,IAAAA,MAAM,EAAE,CAHD;AAIPE,IAAAA,eAAe,EAAE,CAACgH,uBAAuB,CAACpE,MAAxB,CAA+BrC,sBAAhC,GACXzB,UAAU,CAAC8I,iCADA,GAEXrC;AANC,GAAX,CADsB,EAStB,IAAI/F,MAAJ,CAAW;AACPG,IAAAA,IAAI,EAAE,SADC;AAEPD,IAAAA,IAAI,EAAE,cAFC;AAGPI,IAAAA,MAAM,EAAE,CAHD;AAIPC,IAAAA,cAAc,EAAE,CAACjB,UAAU,CAAC+I,qBAAZ,EAAmC/I,UAAU,CAACgJ,gCAA9C;AAJT,GAAX,CATsB,EAetB,IAAI9I,aAAJ,CAAkB;AACdW,IAAAA,IAAI,EAAE,WADQ;AAEd6F,IAAAA,IAAI,EAAE,MAFQ;AAGdvG,IAAAA,aAAa,EAAE;AACX8I,MAAAA,eAAe,EAAE;AACbC,QAAAA,gBAAgB,EAAE,UADL;AACiB;AAC9BlI,QAAAA,MAAM,EAAE,CAFK;AAGbE,QAAAA,eAAe,EAAElB,UAAU,CAACmJ;AAHf;AADN;AAHD,GAAlB,CAfsB,CAA1B,CADmD,CA6BnD;;AACAtJ,EAAAA,CAAC,CAACuJ,IAAF,CAAOP,iBAAP,EAA0B,UAAAQ,IAAI,EAAI;AAC9B;AACAA,IAAAA,IAAI,CAACxH,cAAL,CAAoBqG,uBAAuB,CAACQ,WAA5C,EAF8B,CAG9B;;AACAW,IAAAA,IAAI,CAAChI,cAAL,GAAsB6G,uBAAuB,CAACpE,MAAxB,CAA+BzC,cAArD;AACH,GALD;AAMH,CApCD;;AAsCA,IAAMuH,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAAV,uBAAuB,EAAI;AACnD;AADmD,MAE3ClE,KAF2C,GAEKkE,uBAFL,CAE3ClE,KAF2C;AAAA,MAEpCmE,eAFoC,GAEKD,uBAFL,CAEpCC,eAFoC;AAAA,MAEnB5E,MAFmB,GAEK2E,uBAFL,CAEnB3E,MAFmB;AAAA,MAEXmF,WAFW,GAEKR,uBAFL,CAEXQ,WAFW,EAGnD;;AAEAA,EAAAA,WAAW,CACNY,qBADL,CAC2B/F,MAD3B,EAEKiC,IAFL,CAEU,UAAA+D,OAAO,EAAI;AACb,QAAIA,OAAO,IAAIA,OAAO,CAACC,SAAvB,EAAkC;AAC9B;AACAC,MAAAA,iBAAiB,CAACvB,uBAAD,EAA0BqB,OAA1B,EAAmC,KAAnC,CAAjB;AACH,KAHD,MAGO,IAAI,CAACpB,eAAL,EAAsBuB,aAAa,CAACxB,uBAAD,EAA0BqB,OAA1B,CAAb;AAChC,GAPL,EAQK9D,KARL,CAQW,YAAM;AACT,QAAI,CAAC0C,eAAL,EAAsBuB,aAAa,CAACxB,uBAAD,CAAb;AACzB,GAVL;AAWH,CAhBD,C,CAkBA;;;AACA,IAAMwB,aAAa,GAAG,SAAhBA,aAAgB,CAASxB,uBAAT,EAAkCyB,eAAlC,EAAmD;AACrE;AADqE,MAE7DjB,WAF6D,GAEzBR,uBAFyB,CAE7DQ,WAF6D;AAAA,MAEhDJ,UAFgD,GAEzBJ,uBAFyB,CAEhDI,UAFgD;AAAA,MAEpCxE,MAFoC,GAEzBoE,uBAFyB,CAEpCpE,MAFoC,EAGrE;;AACA,MAAIA,MAAM,CAACzC,cAAP,CAAsBuI,QAAtB,CAA+BC,qBAA/B,EAAJ,EAA4D;AACxDnB,IAAAA,WAAW,CAACoB,SAAZ,CAAsB,iBAAtB,EAAyCL,iBAAiB,CAAC1B,IAAlB,CAAuB,IAAvB,EAA6BG,uBAA7B,EAAsDyB,eAAtD,EAAuE,KAAvE,CAAzC;AACH,GAFD,MAEO;AACHzB,IAAAA,uBAAuB,CAACI,UAAxB,GAAqCyB,WAAW,CAACN,iBAAiB,CAAC1B,IAAlB,CAAuB,IAAvB,EAA6BG,uBAA7B,EAAsDyB,eAAtD,EAAuE,IAAvE,CAAD,EAA+E,IAA/E,CAAhD;AACH;AACJ,CATD,C,CAWA;;;AAEA,IAAMF,iBAAiB,GAAG,SAApBA,iBAAoB,CAASvB,uBAAT,EAAkCyB,eAAlC,EAAmDK,SAAnD,EAA8D9F,GAA9D,EAAmE+F,WAAnE,EAAgFC,GAAhF,EAAqF;AAAA,MAGvG5B,UAHuG,GAavGJ,uBAbuG,CAGvGI,UAHuG;AAAA,MAIvGtE,KAJuG,GAavGkE,uBAbuG,CAIvGlE,KAJuG;AAAA,MAKvGF,MALuG,GAavGoE,uBAbuG,CAKvGpE,MALuG;AAAA,MAMvGsE,cANuG,GAavGF,uBAbuG,CAMvGE,cANuG;AAAA,MAOvGM,WAPuG,GAavGR,uBAbuG,CAOvGQ,WAPuG;AAAA,MASvGD,oBATuG,GAavGP,uBAbuG,CASvGO,oBATuG;AAAA,MAUvGN,eAVuG,GAavGD,uBAbuG,CAUvGC,eAVuG;AAAA,MAWvGE,YAXuG,GAavGH,uBAbuG,CAWvGG,YAXuG;AAAA,MAYvG9E,MAZuG,GAavG2E,uBAbuG,CAYvG3E,MAZuG;;AAe3G,MAAIW,GAAJ,EAAS;AACLgG,IAAAA,GAAG,CAACC,WAAJ;AACAjC,IAAAA,uBAAuB,CAACC,eAAxB,GAA0C,IAA1C;;AACAlI,IAAAA,KAAK,CAACoE,UAAN,CACI;AACI+F,MAAAA,OAAO,EAAE,iFADb;AAEIzD,MAAAA,IAAI,EAAEzC;AAFV,KADJ,EAKIF,KAAK,CAACO,YALV,EAMIP,KAAK,CAACQ,MANV;;AAQA;AACH,GA3B0G,CA6B3G;;;AACA0F,EAAAA,GAAG,GAAGA,GAAG,IAAI;AACTC,IAAAA,WAAW,EAAE;AAAA,aAAME,aAAa,CAACnC,uBAAuB,CAACI,UAAzB,CAAnB;AAAA;AADJ,GAAb,CA9B2G,CAkC3G;;AACA,SACI,CAAEqB,eAAe,IAAI1J,KAAK,CAACyH,UAAN,CAAiBjD,OAAjB,CAAyBkF,eAAzB,CAApB,IAAkEjB,WAAW,CAACY,qBAAZ,CAAkC/F,MAAlC,CAAnE,GACI;AACCiC,EAAAA,IAFL,CAEU,UAAA+D,OAAO,EAAI;AACbe,IAAAA,qBAAqB,CAACf,OAAD,CAArB;AAEA,QAAMgB,gBAAgB,GAAGC,aAAa,CAACjB,OAAD,EAAUzF,MAAV,CAAtC;AAEA,QAAIoE,uBAAuB,CAACC,eAA5B,EAA6C;AAE7C,WAAOM,oBAAoB,GACrBgC,0BAA0B,CAACvC,uBAAD,EAA0BqC,gBAA1B,EAA4CL,GAA5C,CADL,GAErBQ,gBAAgB,CAACxC,uBAAD,EAA0BqC,gBAA1B,EAA4CL,GAA5C,CAFtB;AAGH,GAZL,EAaKzE,KAbL,CAaWkF,YAbX,CADJ;AAgBH,CAnDD;;AAqDA,IAAML,qBAAqB,GAAG,SAAxBA,qBAAwB,CAAAf,OAAO,EAAI;AACrC,MAAIA,OAAO,IAAI,CAACA,OAAO,CAACC,SAAxB,EAAmC,MAAMzJ,MAAM,CAAC6K,aAAb;AACtC,CAFD;;AAIA,IAAMJ,aAAa,GAAG,SAAhBA,aAAgB,CAACjB,OAAD,EAAUzF,MAAV,EAAqB;AACvC,MAAIA,MAAM,CAAC1C,eAAP,IAA0B0C,MAAM,CAAC1C,eAAP,CAAuByJ,gBAArD,EAAuE;AACnEtB,IAAAA,OAAO,GAAGzF,MAAM,CAAC1C,eAAP,CAAuByJ,gBAAvB,CAAwCtB,OAAxC,CAAV;AACH;;AACD,SAAOA,OAAP;AACH,CALD;;AAOA,IAAMoB,YAAY,GAAG,SAAfA,YAAe,CAACzC,uBAAD,EAA0B8B,SAA1B,EAAqCE,GAArC,EAA6C;AAC9D;AAD8D,MAEtDlG,KAFsD,GAEbkE,uBAFa,CAEtDlE,KAFsD;AAAA,MAE/CqE,YAF+C,GAEbH,uBAFa,CAE/CG,YAF+C;AAAA,MAEjCF,eAFiC,GAEbD,uBAFa,CAEjCC,eAFiC,EAG9D;;AACAD,EAAAA,uBAAuB,CAACG,YAAxB,GAJ8D,CAM9D;;AACA,MAAI2B,SAAJ,EAAe;AACX;AACA,QAAI9B,uBAAuB,CAACG,YAAxB,GAAuC,CAAvC,IAA4C7H,cAAhD,EAAgE;AAC5D0J,MAAAA,GAAG,CAACC,WAAJ;AACAjC,MAAAA,uBAAuB,CAACC,eAAxB,GAA0C,IAA1C;;AACAlI,MAAAA,KAAK,CAACoE,UAAN,CACI,IAAID,KAAJ,2CACuC5D,cADvC,2GADJ,EAIIwD,KAAK,CAACO,YAJV,EAKIP,KAAK,CAACQ,MALV;AAOH;AACJ,GAbD,MAaO,IAAI0D,uBAAuB,CAACG,YAAxB,GAAuC,CAAvC,IAA4C/H,YAAhD,EAA8D;AACjE4J,IAAAA,GAAG,CAACC,WAAJ;AACAjC,IAAAA,uBAAuB,CAACC,eAAxB,GAA0C,IAA1C;;AACAlI,IAAAA,KAAK,CAACoE,UAAN,CACI,IAAID,KAAJ,CACI,yIADJ,CADJ,EAIIJ,KAAK,CAACO,YAJV,EAKIP,KAAK,CAACQ,MALV;AAOH;AACJ,CA/BD;;AAiCA,IAAMiG,0BAA0B,GAAG,SAA7BA,0BAA6B,CAACvC,uBAAD,EAA0BqB,OAA1B,EAAmCW,GAAnC,EAA2C;AAC1E;AAD0E,MAElElG,KAFkE,GAEFkE,uBAFE,CAElElE,KAFkE;AAAA,MAE3DF,MAF2D,GAEFoE,uBAFE,CAE3DpE,MAF2D;AAAA,MAEnDsE,cAFmD,GAEFF,uBAFE,CAEnDE,cAFmD;AAAA,MAEnCM,WAFmC,GAEFR,uBAFE,CAEnCQ,WAFmC;AAAA,MAEtBP,eAFsB,GAEFD,uBAFE,CAEtBC,eAFsB,EAI1E;;AACA,MAAI,CAACoB,OAAO,CAACuB,eAAb,EAA8B;AAC1B,QAAI1C,cAAJ,EAAoB;AAChB8B,MAAAA,GAAG,CAACC,WAAJ;AACAjC,MAAAA,uBAAuB,CAACC,eAAxB,GAA0C,IAA1C;AACH;;AAEDlI,IAAAA,KAAK,CAACoE,UAAN,CAAiBtE,MAAM,CAACgL,kCAAxB,EAA4D/G,KAAK,CAACO,YAAlE,EAAgFP,KAAK,CAACQ,MAAtF;;AACA;AACH;;AAED,MAAI,CAAC+E,OAAO,CAACyB,MAAT,IAAmBzB,OAAO,CAAC0B,OAA/B,EAAwC;AACpC,QAAMC,WAAW,GAAGC,IAAI,CAACC,SAAL,CAAe7B,OAAf,EAAwB,IAAxB,EAA8B,CAA9B,CAApB;;AACAtJ,IAAAA,KAAK,CAACoE,UAAN,CAAiB,IAAID,KAAJ,WAAarE,MAAM,CAACsL,YAAP,CAAoB9B,OAAO,CAAC0B,OAA5B,CAAb,gBAAuDC,WAAvD,EAAjB,EAAwFlH,KAAK,CAACO,YAA9F,EAA4GP,KAAK,CAACQ,MAAlH;AACH;;AAEDkE,EAAAA,WAAW,CAAC4C,OAAZ,CAAoB/B,OAAO,CAACuB,eAA5B,EAA6C,UAAC3G,CAAD,EAAIoH,IAAJ,EAAa;AACtD,QAAI,CAACA,IAAL,EAAW;AAEXvH,IAAAA,KAAK,CAACO,YAAN,CAAmBG,IAAnB,CAAwB,SAAxB,EAAmC6E,OAAnC,EAHsD,CAKtD;;AACAvF,IAAAA,KAAK,CAACS,OAAN,CACKX,MAAM,CAAC1C,eAAP,IACG0C,MAAM,CAAC1C,eAAP,CAAuBoK,uBAD1B,IAEG1H,MAAM,CAAC1C,eAAP,CAAuBoK,uBAAvB,CAA+CjC,OAA/C,CAFJ,IAGIA,OAJR,EANsD,CAatD;;AACA,QAAInB,cAAJ,EAAoBpE,KAAK,CAACO,YAAN,CAAmBkH,kBAAnB;AAEpB,QAAIrD,cAAJ,EAAoB8B,GAAG,CAACC,WAAJ;AACpBjC,IAAAA,uBAAuB,CAACC,eAAxB,GAA0C,IAA1C;AACH,GAlBD;;AAoBA,SAAOoB,OAAP;AACH,CAzCD;;AA2CA,IAAMmB,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACxC,uBAAD,EAA0BqB,OAA1B,EAAmCW,GAAnC,EAA2C;AAChE;AADgE,MAExDlG,KAFwD,GAEAkE,uBAFA,CAExDlE,KAFwD;AAAA,MAEjDoE,cAFiD,GAEAF,uBAFA,CAEjDE,cAFiD;AAAA,MAEjCD,eAFiC,GAEAD,uBAFA,CAEjCC,eAFiC;AAAA,MAEhBI,WAFgB,GAEAL,uBAFA,CAEhBK,WAFgB;;AAIhE,MACIgB,OAAO,IACP,CAACA,OAAO,CAACmC,QADT,KAEC,CAACnD,WAAD,IAAgBA,WAAW,KAAKgB,OAAO,CAACoC,OAFzC,MAGCpC,OAAO,CAACyB,MAAR,KAAmB,IAAnB,IAA2BzB,OAAO,CAACyB,MAAR,KAAmB,KAA9C,IAAuD,OAAOzB,OAAO,CAACyB,MAAf,KAA0B,WAHlF,CADJ,EAKE;AACE;AACA,QAAI;AACA9C,MAAAA,uBAAuB,CAAClE,KAAxB,CAA8BO,YAA9B,CAA2CG,IAA3C,CAAgD,SAAhD,EAA2D6E,OAA3D;AACArB,MAAAA,uBAAuB,CAAClE,KAAxB,CAA8BS,OAA9B,CAAsC8E,OAAtC;AACH,KAHD,CAGE,OAAOpF,CAAP,EAAU;AACR+B,MAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6BhC,CAA7B;AACH,KAPH,CASE;;;AACA,QAAIiE,cAAJ,EAAoB;AAChBF,MAAAA,uBAAuB,CAAClE,KAAxB,CAA8BO,YAA9B,CAA2CkH,kBAA3C;AACH;AACJ,GAlBD,MAkBO;AACH;AACA,QAAI,CAAClC,OAAL,EAAc;AACd,QAAM2B,WAAW,GAAGC,IAAI,CAACC,SAAL,CAAe7B,OAAf,EAAwB,IAAxB,EAA8B,CAA9B,CAApB;AAHG,QAKK0B,OALL,GAKiB1B,OALjB,CAKK0B,OALL;;AAMH,QAAIA,OAAO,IAAIlL,MAAM,CAACsL,YAAP,CAAoBJ,OAApB,CAAf,EAA6C;AACzChL,MAAAA,KAAK,CAACoE,UAAN,CACI,IAAID,KAAJ,WAAarE,MAAM,CAACsL,YAAP,CAAoBJ,OAApB,CAAb,gBAA+CC,WAA/C,EADJ,EAEIhD,uBAAuB,CAAClE,KAAxB,CAA8BO,YAFlC,EAGI2D,uBAAuB,CAAClE,KAAxB,CAA8BQ,MAHlC;AAKH,KAND,MAMO,IAAI+E,OAAO,CAACyB,MAAR,KAAmB,KAAnB,IAA4BzB,OAAO,CAACyB,MAAR,KAAmB,KAAnD,EAA0D;AAC7D/K,MAAAA,KAAK,CAACoE,UAAN,CACItE,MAAM,CAAC6L,mBAAP,CAA2BV,WAA3B,CADJ,EAEIhD,uBAAuB,CAAClE,KAAxB,CAA8BO,YAFlC,EAGI2D,uBAAuB,CAAClE,KAAxB,CAA8BQ,MAHlC;AAKH,KANM,MAMA,IAAI+E,OAAO,CAACoC,OAAR,IAAmBpD,WAAvB,EAAoC;AACvCtI,MAAAA,KAAK,CAACoE,UAAN,CACItE,MAAM,CAAC8L,sBAAP,CAA8BX,WAA9B,CADJ,EAEIhD,uBAAuB,CAAClE,KAAxB,CAA8BO,YAFlC,EAGI2D,uBAAuB,CAAClE,KAAxB,CAA8BQ,MAHlC;AAKH,KANM,MAMA;AACHvE,MAAAA,KAAK,CAACoE,UAAN,CACItE,MAAM,CAAC8L,sBAAP,CAA8BX,WAA9B,CADJ,EAEIhD,uBAAuB,CAAClE,KAAxB,CAA8BO,YAFlC,EAGI2D,uBAAuB,CAAClE,KAAxB,CAA8BQ,MAHlC;AAKH;AACJ;;AAED,MAAI4D,cAAJ,EAAoB8B,GAAG,CAACC,WAAJ;AACpBjC,EAAAA,uBAAuB,CAACC,eAAxB,GAA0C,IAA1C;AACH,CAzDD;AA2DA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS7F,OAAT,GAA0B;AAAA,qCAANM,IAAM;AAANA,IAAAA,IAAM;AAAA;;AACtB,MAAMiB,OAAO,GAAG,KAAK1B,SAAL,CAAeS,IAAf,CAAhB;AACAiB,EAAAA,OAAO,CAACiI,MAAR,GAAiB,KAAK5J,YAAL,CAAkB6F,IAAlB,CAAuB,IAAvB,CAAjB;AACA,SAAOlE,OAAP;AACH;;AAEDkI,MAAM,CAACC,OAAP,GAAiBtL,MAAjB","sourcesContent":["/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-core-method/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\nconst _ = require('lodash')\nconst errors = require('../../caver-core-helpers').errors\nconst formatters = require('../../caver-core-helpers').formatters\nconst utils = require('../../caver-utils')\nconst Subscriptions = require('../../caver-core-subscriptions').subscriptions\nconst validateParams = require('../../caver-core-helpers').validateFunction.validateParams\n\nconst TIMEOUTBLOCK = 50\nconst AVERAGE_BLOCK_TIME = 1 // 1s\nconst POLLINGTIMEOUT = AVERAGE_BLOCK_TIME * TIMEOUTBLOCK // ~average block time (seconds) * TIMEOUTBLOCK\n\nconst TransactionDecoder = require('../../caver-transaction/src/transactionDecoder/transactionDecoder')\n\nfunction Method(options) {\n    // call, name should be existed to create a method.\n    if (!options.call || !options.name) throw errors.needNameCallPropertyToCreateMethod\n\n    this.name = options.name\n    this.call = options.call\n    this.hexCall = options.hexCall\n    this.params = options.params || 0\n    this.inputFormatter = options.inputFormatter || []\n    this.outputFormatter = options.outputFormatter\n    this.transformPayload = options.transformPayload\n    this.extraFormatters = options.extraFormatters\n\n    this.requestManager = options.requestManager\n\n    // reference to klay.accounts\n    this.accounts = options.accounts\n\n    this.defaultBlock = options.defaultBlock || 'latest'\n    this.defaultAccount = options.defaultAccount || null\n\n    this.outputFormatterDisable = options.outputFormatterDisable\n}\n\nMethod.prototype.setRequestManager = setRequestManager\nMethod.prototype.createFunction = createFunction\nMethod.prototype.attachToObject = attachToObject\nMethod.prototype.getCall = getCall\nMethod.prototype.extractCallback = extractCallback\nMethod.prototype.validateArgs = validateArgs\nMethod.prototype.formatInput = formatInput\nMethod.prototype.formatOutput = formatOutput\nMethod.prototype.toPayload = toPayload\nMethod.prototype.buildCall = buildCall\nMethod.prototype._confirmTransaction = _confirmTransaction\nMethod.prototype.request = request\n\n/**\n * Set requestManager for rpc calling.\n * If it has accounts parameter also, set it.\n * @method setRequestManager\n * @param  {Object} requestManager\n * @param  {Object} accounts\n */\nfunction setRequestManager(requestManager, accounts) {\n    this.requestManager = requestManager\n\n    // reference to klay.accounts\n    if (accounts) this.accounts = accounts\n}\n\n/**\n * createFunction through 'this' context (= instance by created through new Method(...))\n * @method createFunction\n * @param  {Object} requestManager\n * @param  {Object} accounts\n * @return {Function} it will be used for sending RPC call.\n */\nfunction createFunction(requestManager, accounts) {\n    // set requestManager for method individulally.\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts)\n\n    // this.buildCall() returns function `send = function() { ... }`\n    const func = this.buildCall()\n\n    // call is directly used for rpc calling,\n    // ex) 'klay_sendTransaction'\n    func.call = this.call\n\n    return func\n}\n\n/**\n * attach buildCalled method to 'obj' object,\n * by adding a property name through this.name\n * @method attachToObject\n * @param  {Object} obj\n */\nfunction attachToObject(obj) {\n    const func = this.buildCall()\n    func.call = this.call\n    const [callName, optionalName] = this.name.split('.')\n\n    if (optionalName) {\n        obj[callName] = obj[callName] || {}\n        obj[callName][optionalName] = func\n    } else {\n        obj[callName] = func\n    }\n}\n\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nfunction getCall(args) {\n    // If hexCall is defined, args[0] type is truly hexParameter, return this.hexCall\n    // If not, return this.call\n    // 'this.call', 'this.hexCall' are defined in rpc.json\n    return this.hexCall && utils.isHexParameter(args[0]) ? this.hexCall : this.call\n}\n\n/**\n * Should be used to extract callback from array of arguments.\n * (caution) It modifies input param.\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nfunction extractCallback(args) {\n    if (_.isFunction(args[args.length - 1])) {\n        return args.pop() // 'pop' method modifies the original args array!\n    }\n}\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nfunction validateArgs(args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name)\n    }\n}\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nfunction formatInput(args) {\n    const _this = this\n\n    // If inputFormatter is not defined, or empty just return original args.\n    if (!this.inputFormatter || _.isEmpty(this.inputFormatter)) {\n        return args\n    }\n\n    // If inputFormatter is defined, map original args by calling formatter.\n    return this.inputFormatter.map((formatter, index) => {\n        // bind this for defaultBlock, and defaultAccount\n        return (formatter && formatter.call(_this, args[index])) || args[index]\n    })\n}\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nfunction formatOutput(result) {\n    const _this = this\n\n    // If outputFormatter is defined, calling outputFormatter,\n    // If not, just return original res.\n    const _formatOutput = res => (typeof _this.outputFormatter === 'function' ? _this.outputFormatter(res) : res)\n\n    // If result is array, map it through calling _formatOuput\n    // If result is single, just calling _formatOutput.\n    return _.isArray(result) ? result.map(_formatOutput) : _formatOutput(result)\n}\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nfunction toPayload(args) {\n    const call = this.getCall(args)\n    const callback = this.extractCallback(args)\n    const inputParams = this.formatInput(args)\n    this.validateArgs(inputParams)\n\n    const payload = {\n        method: call,\n        params: inputParams,\n        callback,\n    }\n\n    // If payload transform option is existing, apply it.\n    // If not, just return payload.\n    return (this.transformPayload && this.transformPayload(payload)) || payload\n}\n\nconst buildSendTxCallbackFunc = (defer, method, payload, isSendTx) => (err, result) => {\n    try {\n        result = method.formatOutput(result)\n    } catch (e) {\n        if (!err) err = e\n    }\n\n    err = (result instanceof Error && result) || err\n\n    // If err exists, fireError\n    if (err) {\n        return utils._fireError(\n            err.error || err, // sometimes, err.error property exists, in case, fire it instead 'err'\n            defer.eventEmitter,\n            defer.reject,\n            payload.callback\n        )\n    }\n\n    // fire callback\n    if (payload.callback) payload.callback(null, result)\n\n    // return PROMISE\n    if (!isSendTx) {\n        defer.resolve(result)\n    } else {\n        defer.eventEmitter.emit('transactionHash', result)\n        method._confirmTransaction(defer, result, payload)\n    }\n}\n\nconst buildSendSignedTxFunc = (method, payload, sendTxCallback) => signed => {\n    const rawTransaction = signed.rawTransaction ? signed.rawTransaction : signed\n    const signedPayload = _.extend({}, payload, {\n        method: 'klay_sendRawTransaction',\n        params: [rawTransaction],\n    })\n\n    method.requestManager.send(signedPayload, sendTxCallback)\n}\n\nconst buildSendRequestFunc = (defer, sendSignedTx, sendTxCallback) => (payload, method) => {\n    const methodName = payload.method\n    // Logic for handling multiple cases of parameters in sendSignedTransaction.\n    // 1. Object containing rawTransaction\n    //    : call 'klay_sendRawTransaction' with RLP encoded transaction(rawTransaction) in object\n    // 2. A transaction object containing signatures or feePayerSignatures\n    //    : call 'getRawTransactionWithSignatures', then call 'klay_sendRawTransaction' with result of getRawTransactionWithSignatures\n    if (method && methodName === 'klay_sendRawTransaction') {\n        // The existence of accounts in the method means the implementation before the common architecture.\n        if (method.accounts) {\n            const transaction = payload.params[0]\n            if (typeof transaction !== 'string' && _.isObject(transaction)) {\n                if (transaction.rawTransaction) {\n                    return sendSignedTx(transaction)\n                }\n                return method.accounts\n                    .getRawTransactionWithSignatures(transaction)\n                    .then(sendSignedTx)\n                    .catch(e => {\n                        sendTxCallback(e)\n                    })\n            }\n        } else {\n            const transaction = payload.params[0]\n            if (!_.isString(transaction) && _.isObject(transaction) && _.isFunction(transaction.getRLPEncoding)) {\n                return sendSignedTx(transaction.getRLPEncoding())\n            }\n        }\n    }\n\n    // In the previous implementation of common architecture,\n    // if there was an account in the in-memory wallet before requesting to send or sign a transaction to the node,\n    // it was handled by using it.\n    if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n        switch (methodName) {\n            case 'klay_sendTransaction': {\n                const tx = payload.params[0]\n\n                let error\n                if (!_.isObject(tx)) {\n                    sendTxCallback(new Error('The transaction must be defined as an object.'))\n                    return\n                }\n\n                let addressToUse = tx.from\n\n                if (tx.senderRawTransaction && tx.feePayer) {\n                    addressToUse = tx.feePayer\n                    if (tx.from) {\n                        console.log('\"from\" is ignored for a fee-delegated transaction.')\n                        delete tx.from\n                    }\n                }\n\n                let wallet\n\n                try {\n                    wallet = method.accounts.wallet.getAccount(addressToUse)\n                } catch (e) {\n                    sendTxCallback(e)\n                    return\n                }\n\n                if (wallet && wallet.privateKey) {\n                    const privateKey = method.accounts._getRoleKey(tx, wallet)\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    return method.accounts\n                        .signTransaction(tx, privateKey)\n                        .then(sendSignedTx)\n                        .catch(e => {\n                            sendTxCallback(e)\n                        })\n                }\n                if (tx.signatures) {\n                    // If signatures is defined inside of the transaction object,\n                    // get rawTransaction string from signed transaction object and send to network\n                    return method.accounts\n                        .getRawTransactionWithSignatures(tx)\n                        .then(sendSignedTx)\n                        .catch(e => {\n                            sendTxCallback(e)\n                        })\n                }\n\n                // If wallet was not found in caver-js wallet, then it has to use wallet in Node.\n                // Signing to transaction using wallet in Node supports only LEGACY transaction, so if transaction is not LEGACY, return error.\n                if (tx.feePayer !== undefined || (tx.type !== undefined && tx.type !== 'LEGACY')) {\n                    error = new Error(\n                        `No private key found in the caver-js wallet. Trying to use the Klaytn node's wallet, but it only supports legacy transactions. Please add private key of ${addressToUse} to the caver-js wallet.`\n                    )\n                    sendTxCallback(error)\n                    return\n                }\n\n                error = validateParams(tx)\n                if (error) {\n                    sendTxCallback(error)\n                    return\n                }\n                break\n            }\n            case 'klay_sign': {\n                const data = payload.params[1]\n                const wallet = method.accounts.wallet.getAccount(payload.params[0])\n\n                if (wallet && wallet.privateKey) {\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    const sign = method.accounts.sign(data, wallet.privateKey)\n\n                    if (payload.callback) payload.callback(null, sign.signature)\n\n                    defer.resolve(sign.signature)\n                    return\n                }\n                break\n            }\n        }\n    }\n\n    // When sending a request to send or sign a transaction using a key stored in a Klaytn node,\n    // the variable names inside the transaction must be properly formatted.\n    // { _from: '0x..', _signatures: ['0x..', '0x..', '0x..'] } -> { from: '0x..', signatures: { V: '0x..', R: '0x..', S: '0x..'} }\n    if (\n        methodName === 'klay_sendTransaction' ||\n        methodName === 'klay_sendTransactionAsFeePayer' ||\n        methodName === 'klay_signTransaction' ||\n        methodName === 'klay_signTransactionAsFeePayer'\n    ) {\n        const tx = {}\n        Object.keys(payload.params[0]).map(k => {\n            let key = k\n            if (key.startsWith('_')) key = key.slice(1)\n            if (key === 'signatures' || key === 'feePayerSignatures') {\n                if (!utils.isEmptySig(payload.params[0][key])) {\n                    tx[key] = utils.transformSignaturesToObject(payload.params[0][key])\n\n                    if (key === 'signatures' && (methodName === 'klay_signTransaction' || methodName === 'klay_sendTransaction')) {\n                        console.warn(`When sign/send a transaction using the Node API, existing 'signatures' can be initialized.`)\n                    }\n\n                    if (\n                        key === 'feePayerSignatures' &&\n                        (methodName === 'klay_signTransactionAsFeePayer' || methodName === 'klay_sendTransactionAsFeePayer')\n                    ) {\n                        console.warn(`When sign/send a transaction using the Node API, existing 'feePayerSignatures' can be initialized.`)\n                    }\n                }\n            } else if (key === 'codeFormat') {\n                tx[key] = utils.hexToNumber(payload.params[0][key])\n            } else if (key === 'account') {\n                tx.key = payload.params[0][key].getRLPEncodingAccountKey()\n            } else if (payload.params[0][key] !== '0x') {\n                tx[key] = payload.params[0][key]\n            }\n        })\n        payload.params[0] = tx\n    }\n\n    return method.requestManager.send(payload, sendTxCallback)\n}\n\nconst buildSendFunc = (method, isSendTx) => (...args) => {\n    const defer = utils.promiEvent(!isSendTx)\n    const payload = method.toPayload(args)\n\n    const sendTxCallback = buildSendTxCallbackFunc(defer, method, payload, isSendTx)\n    const sendSignedTx = buildSendSignedTxFunc(method, payload, sendTxCallback)\n    const sendRequest = buildSendRequestFunc(defer, sendSignedTx, sendTxCallback)\n\n    const isGasPriceInputMissing = isSendTx && _.isObject(payload.params[0]) && payload.params[0].gasPrice === undefined\n\n    // If gasPrice input is missing, call getGasPrice rpc\n    if (!isGasPriceInputMissing) {\n        sendRequest(payload, method)\n        return defer.eventEmitter\n    }\n\n    const getGasPrice = new Method({\n        name: 'getGasPrice',\n        call: 'klay_gasPrice',\n        params: 0,\n    }).createFunction(method.requestManager)\n\n    getGasPrice((err, gasPrice) => {\n        payload.params[0].gasPrice = gasPrice || payload.params[0].gasPrice\n        sendRequest(payload, method)\n    })\n\n    /**\n     * attaching `.on('receipt')` is possible by returning defer.eventEmitter\n     */\n    return defer.eventEmitter\n}\n\nfunction buildCall() {\n    const method = this\n    const isSendTx =\n        method.call === 'klay_sendTransaction' ||\n        method.call === 'klay_sendTransactionAsFeePayer' ||\n        method.call === 'klay_sendRawTransaction' ||\n        method.call === 'personal_sendTransaction' ||\n        method.call === 'personal_sendValueTransfer' ||\n        method.call === 'personal_sendAccountUpdate'\n\n    const send = buildSendFunc(method, isSendTx)\n    // necessary to attach things to the method\n    send.method = method\n    // necessary for batch requests\n    send.request = this.request.bind(this)\n    return send\n}\n\nfunction _confirmTransaction(defer, result, payload) {\n    let payloadTxObject = (payload.params && _.isObject(payload.params[0]) && payload.params[0]) || {}\n\n    // If payload.params[0] is RLP-encoded string, decode RLP-encoded string to Transaction instance.\n    if (_.isString(payload.params[0])) payloadTxObject = TransactionDecoder.decode(payload.params[0])\n\n    // mutableConfirmationPack will be used in\n    // 1) checkConfirmation,\n    // 2) startWatching functions\n    // It is * mutable *, both functions can affect properties mutably.\n    const mutableConfirmationPack = {\n        method: this,\n        promiseResolved: false,\n        canUnsubscribe: true,\n        timeoutCount: 0,\n        intervalId: null,\n        gasProvided: payloadTxObject.gas || null,\n        isContractDeployment: utils.isContractDeployment(payloadTxObject),\n        defer,\n        result,\n        _klaytnCall: {},\n    }\n\n    addCustomSendMethod(mutableConfirmationPack)\n\n    kickoffConfirmation(mutableConfirmationPack)\n}\n\nconst addCustomSendMethod = mutableConfirmationPack => {\n    const customSendMethods = [\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'klay_getTransactionReceipt',\n            params: 1,\n            outputFormatter: !mutableConfirmationPack.method.outputFormatterDisable\n                ? formatters.outputTransactionReceiptFormatter\n                : undefined,\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'klay_getCode',\n            params: 2,\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter],\n        }),\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'klay',\n            subscriptions: {\n                newBlockHeaders: {\n                    subscriptionName: 'newHeads', // replace subscription with this name\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter,\n                },\n            },\n        }),\n    ]\n\n    // add custom send Methods\n    _.each(customSendMethods, mthd => {\n        // attach methods to _klaytnCall\n        mthd.attachToObject(mutableConfirmationPack._klaytnCall)\n        // assign rather than call setRequestManager()\n        mthd.requestManager = mutableConfirmationPack.method.requestManager\n    })\n}\n\nconst kickoffConfirmation = mutableConfirmationPack => {\n    // eslint-disable-next-line no-unused-vars\n    const { defer, promiseResolved, result, _klaytnCall } = mutableConfirmationPack\n    // first check if we already have a confirmed transaction\n\n    _klaytnCall\n        .getTransactionReceipt(result)\n        .then(receipt => {\n            if (receipt && receipt.blockHash) {\n                // `isPolling` is false in default.\n                checkConfirmation(mutableConfirmationPack, receipt, false)\n            } else if (!promiseResolved) startWatching(mutableConfirmationPack, receipt)\n        })\n        .catch(() => {\n            if (!promiseResolved) startWatching(mutableConfirmationPack)\n        })\n}\n\n// start watching for confirmation depending on the support features of the provider\nconst startWatching = function(mutableConfirmationPack, existingReceipt) {\n    // eslint-disable-next-line no-unused-vars\n    const { _klaytnCall, intervalId, method } = mutableConfirmationPack\n    // if provider allows PUB/SUB\n    if (method.requestManager.provider.supportsSubscriptions()) {\n        _klaytnCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, mutableConfirmationPack, existingReceipt, false))\n    } else {\n        mutableConfirmationPack.intervalId = setInterval(checkConfirmation.bind(null, mutableConfirmationPack, existingReceipt, true), 1000)\n    }\n}\n\n// fire \"receipt\" and confirmation events and resolve after\n\nconst checkConfirmation = function(mutableConfirmationPack, existingReceipt, isPolling, err, blockHeader, sub) {\n    const {\n        // L1\n        intervalId, // eslint-disable-line no-unused-vars\n        defer,\n        method,\n        canUnsubscribe, // eslint-disable-line no-unused-vars\n        _klaytnCall,\n        // L2\n        isContractDeployment,\n        promiseResolved, // eslint-disable-line no-unused-vars\n        timeoutCount, // eslint-disable-line no-unused-vars\n        result,\n    } = mutableConfirmationPack\n\n    if (err) {\n        sub.unsubscribe()\n        mutableConfirmationPack.promiseResolved = true\n        utils._fireError(\n            {\n                message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n                data: err,\n            },\n            defer.eventEmitter,\n            defer.reject\n        )\n        return\n    }\n\n    // create fake unsubscribe\n    sub = sub || {\n        unsubscribe: () => clearInterval(mutableConfirmationPack.intervalId),\n    }\n\n    // if we have a valid receipt we don't need to send a request\n    return (\n        ((existingReceipt && utils.promiEvent.resolve(existingReceipt)) || _klaytnCall.getTransactionReceipt(result))\n            // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n            .then(receipt => {\n                checkIsReceiptInBlock(receipt)\n\n                const formattedReceipt = formatReceipt(receipt, method)\n\n                if (mutableConfirmationPack.promiseResolved) return\n\n                return isContractDeployment\n                    ? checkForContractDeployment(mutableConfirmationPack, formattedReceipt, sub)\n                    : checkForNormalTx(mutableConfirmationPack, formattedReceipt, sub)\n            })\n            .catch(countTimeout)\n    )\n}\n\nconst checkIsReceiptInBlock = receipt => {\n    if (receipt && !receipt.blockHash) throw errors.blockHashNull\n}\n\nconst formatReceipt = (receipt, method) => {\n    if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n        receipt = method.extraFormatters.receiptFormatter(receipt)\n    }\n    return receipt\n}\n\nconst countTimeout = (mutableConfirmationPack, isPolling, sub) => {\n    // eslint-disable-next-line no-unused-vars\n    const { defer, timeoutCount, promiseResolved } = mutableConfirmationPack\n    // time out the transaction if not mined after 50 blocks\n    mutableConfirmationPack.timeoutCount++\n\n    // check to see if we are http polling\n    if (isPolling) {\n        // polling timeout is different than TIMEOUTBLOCK blocks since we are triggering every second\n        if (mutableConfirmationPack.timeoutCount - 1 >= POLLINGTIMEOUT) {\n            sub.unsubscribe()\n            mutableConfirmationPack.promiseResolved = true\n            utils._fireError(\n                new Error(\n                    `Transaction was not mined within${POLLINGTIMEOUT} seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!`\n                ),\n                defer.eventEmitter,\n                defer.reject\n            )\n        }\n    } else if (mutableConfirmationPack.timeoutCount - 1 >= TIMEOUTBLOCK) {\n        sub.unsubscribe()\n        mutableConfirmationPack.promiseResolved = true\n        utils._fireError(\n            new Error(\n                'Transaction was not mined within 50 blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'\n            ),\n            defer.eventEmitter,\n            defer.reject\n        )\n    }\n}\n\nconst checkForContractDeployment = (mutableConfirmationPack, receipt, sub) => {\n    // eslint-disable-next-line no-unused-vars\n    const { defer, method, canUnsubscribe, _klaytnCall, promiseResolved } = mutableConfirmationPack\n\n    // If contract address doesn't exist, fire error.\n    if (!receipt.contractAddress) {\n        if (canUnsubscribe) {\n            sub.unsubscribe()\n            mutableConfirmationPack.promiseResolved = true\n        }\n\n        utils._fireError(errors.receiptDidntContainContractAddress, defer.eventEmitter, defer.reject)\n        return\n    }\n\n    if (!receipt.status && receipt.txError) {\n        const receiptJSON = JSON.stringify(receipt, null, 2)\n        utils._fireError(new Error(`${errors.txErrorTable[receipt.txError]}\\n ${receiptJSON}`), defer.eventEmitter, defer.reject)\n    }\n\n    _klaytnCall.getCode(receipt.contractAddress, (e, code) => {\n        if (!code) return\n\n        defer.eventEmitter.emit('receipt', receipt)\n\n        // if contract, return instance instead of receipt\n        defer.resolve(\n            (method.extraFormatters &&\n                method.extraFormatters.contractDeployFormatter &&\n                method.extraFormatters.contractDeployFormatter(receipt)) ||\n                receipt\n        )\n\n        // need to remove listeners, as they aren't removed automatically when succesfull\n        if (canUnsubscribe) defer.eventEmitter.removeAllListeners()\n\n        if (canUnsubscribe) sub.unsubscribe()\n        mutableConfirmationPack.promiseResolved = true\n    })\n\n    return receipt\n}\n\nconst checkForNormalTx = (mutableConfirmationPack, receipt, sub) => {\n    // eslint-disable-next-line no-unused-vars\n    const { defer, canUnsubscribe, promiseResolved, gasProvided } = mutableConfirmationPack\n\n    if (\n        receipt &&\n        !receipt.outOfGas &&\n        (!gasProvided || gasProvided !== receipt.gasUsed) &&\n        (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')\n    ) {\n        // Happy case: transaction is processed well. A.K.A 'well-done receipt'.\n        try {\n            mutableConfirmationPack.defer.eventEmitter.emit('receipt', receipt)\n            mutableConfirmationPack.defer.resolve(receipt)\n        } catch (e) {\n            console.log('receipt error', e)\n        }\n\n        // need to remove listeners, as they aren't removed automatically when succesfull\n        if (canUnsubscribe) {\n            mutableConfirmationPack.defer.eventEmitter.removeAllListeners()\n        }\n    } else {\n        // Unhappy case: trasaction has error. A.K.A 'bad receipt'.\n        if (!receipt) return\n        const receiptJSON = JSON.stringify(receipt, null, 2)\n\n        const { txError } = receipt\n        if (txError && errors.txErrorTable[txError]) {\n            utils._fireError(\n                new Error(`${errors.txErrorTable[txError]}\\n ${receiptJSON}`),\n                mutableConfirmationPack.defer.eventEmitter,\n                mutableConfirmationPack.defer.reject\n            )\n        } else if (receipt.status === false || receipt.status === '0x0') {\n            utils._fireError(\n                errors.transactionReverted(receiptJSON),\n                mutableConfirmationPack.defer.eventEmitter,\n                mutableConfirmationPack.defer.reject\n            )\n        } else if (receipt.gasUsed >= gasProvided) {\n            utils._fireError(\n                errors.transactionRanOutOfGas(receiptJSON),\n                mutableConfirmationPack.defer.eventEmitter,\n                mutableConfirmationPack.defer.reject\n            )\n        } else {\n            utils._fireError(\n                errors.transactionRanOutOfGas(receiptJSON),\n                mutableConfirmationPack.defer.eventEmitter,\n                mutableConfirmationPack.defer.reject\n            )\n        }\n    }\n\n    if (canUnsubscribe) sub.unsubscribe()\n    mutableConfirmationPack.promiseResolved = true\n}\n\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nfunction request(...args) {\n    const payload = this.toPayload(args)\n    payload.format = this.formatOutput.bind(this)\n    return payload\n}\n\nmodule.exports = Method\n"]},"metadata":{},"sourceType":"script"}