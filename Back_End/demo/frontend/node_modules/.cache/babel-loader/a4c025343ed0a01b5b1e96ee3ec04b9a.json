{"ast":null,"code":"/*\n    Copyright 2018 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Should be called to check the parameters of transaction\n *\n * @method validateParams\n * @param {Object}\n * @return {Error}\n */\nvar utils = require('../../caver-utils');\n\nvar _require = require('../../caver-transaction/src/transactionHelper/transactionHelper'),\n    TX_TYPE_STRING = _require.TX_TYPE_STRING;\n\nfunction validateParams(tx) {\n  var error; // validate for fee payer transaction format\n\n  if (tx.senderRawTransaction) {\n    if (!tx.feePayer || tx.feePayer === '0x') {\n      error = new Error(\"Invalid fee payer: \".concat(tx.feePayer));\n    } else if (!utils.isAddress(tx.feePayer)) {\n      error = new Error(\"Invalid address of fee payer: \".concat(tx.feePayer));\n    }\n\n    return error;\n  }\n\n  var isValidateType = validateTxType(tx.type);\n\n  if (!isValidateType) {\n    return new Error(\"The transaction type [\".concat(tx.type, \"] is not supported\"));\n  }\n\n  error = validateTxObjectWithType(tx);\n\n  if (error !== undefined) {\n    return error;\n  }\n\n  if (tx.type !== TX_TYPE_STRING.TxTypeLegacyTransaction && !tx.from) {\n    error = new Error('\"from\" is missing');\n  } else if (tx.from) {\n    if (tx.from === '0x') {\n      if (tx.type !== TX_TYPE_STRING.TxTypeLegacyTransaction) {\n        error = new Error(\"Invalid address of from: \".concat(tx.from));\n      }\n    } else if (!utils.isAddress(tx.from)) {\n      error = new Error(\"Invalid address of from: \".concat(tx.from));\n    }\n  }\n\n  if (tx.gas === undefined && tx.gasLimit === undefined) {\n    error = new Error('\"gas\" is missing');\n  } else if (tx.nonce < 0 || tx.gas < 0 || tx.gasPrice < 0 || tx.chainId < 0) {\n    error = new Error('gas, gasPrice, nonce or chainId is lower than 0');\n  } // If feePayerSignatures is set in transaction object, feePayer also should be defined together.\n\n\n  if (tx.feePayerSignatures && !utils.isEmptySig(tx.feePayerSignatures)) {\n    if (!tx.feePayer || tx.feePayer === '0x') {\n      error = new Error('\"feePayer\" is missing: feePayer must be defined with feePayerSignatures.');\n    } else if (!utils.isAddress(tx.feePayer)) {\n      error = new Error(\"Invalid address of fee payer: \".concat(tx.feePayer));\n    }\n  }\n\n  return error;\n}\n/**\n * Should be called to check the type of transaction\n * Transaction type has to be checked if type is set.\n *\n * @method validateTypes\n * @param {string}\n * @return {bool}\n */\n\n\nfunction validateTxType(txType) {\n  if (!txType) {\n    return true;\n  }\n\n  switch (txType) {\n    case 'VALUE_TRANSFER':\n    case 'FEE_DELEGATED_VALUE_TRANSFER':\n    case 'FEE_DELEGATED_VALUE_TRANSFER_WITH_RATIO':\n    case 'VALUE_TRANSFER_MEMO':\n    case 'FEE_DELEGATED_VALUE_TRANSFER_MEMO':\n    case 'FEE_DELEGATED_VALUE_TRANSFER_MEMO_WITH_RATIO':\n    case 'ACCOUNT_UPDATE':\n    case 'FEE_DELEGATED_ACCOUNT_UPDATE':\n    case 'FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO':\n    case 'SMART_CONTRACT_DEPLOY':\n    case 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY':\n    case 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY_WITH_RATIO':\n    case 'SMART_CONTRACT_EXECUTION':\n    case 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION':\n    case 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION_WITH_RATIO':\n    case 'CANCEL':\n    case 'FEE_DELEGATED_CANCEL':\n    case 'FEE_DELEGATED_CANCEL_WITH_RATIO':\n    case 'CHAIN_DATA_ANCHORING':\n    case 'LEGACY':\n    case TX_TYPE_STRING.TxTypeValueTransfer:\n    case TX_TYPE_STRING.TxTypeFeeDelegatedValueTransfer:\n    case TX_TYPE_STRING.TxTypeFeeDelegatedValueTransferWithRatio:\n    case TX_TYPE_STRING.TxTypeValueTransferMemo:\n    case TX_TYPE_STRING.TxTypeFeeDelegatedValueTransferMemo:\n    case TX_TYPE_STRING.TxTypeFeeDelegatedValueTransferMemoWithRatio:\n    case TX_TYPE_STRING.TxTypeAccountUpdate:\n    case TX_TYPE_STRING.TxTypeFeeDelegatedAccountUpdate:\n    case TX_TYPE_STRING.TxTypeFeeDelegatedAccountUpdateWithRatio:\n    case TX_TYPE_STRING.TxTypeSmartContractDeploy:\n    case TX_TYPE_STRING.TxTypeFeeDelegatedSmartContractDeploy:\n    case TX_TYPE_STRING.TxTypeFeeDelegatedSmartContractDeployWithRatio:\n    case TX_TYPE_STRING.TxTypeSmartContractExecution:\n    case TX_TYPE_STRING.TxTypeFeeDelegatedSmartContractExecution:\n    case TX_TYPE_STRING.TxTypeFeeDelegatedSmartContractExecutionWithRatio:\n    case TX_TYPE_STRING.TxTypeCancel:\n    case TX_TYPE_STRING.TxTypeFeeDelegatedCancel:\n    case TX_TYPE_STRING.TxTypeFeeDelegatedCancelWithRatio:\n    case TX_TYPE_STRING.TxTypeChainDataAnchoring:\n    case TX_TYPE_STRING.TxTypeFeeDelegatedChainDataAnchoring:\n    case TX_TYPE_STRING.TxTypeFeeDelegatedChainDataAnchoringWithRatio:\n    case TX_TYPE_STRING.TxTypeLegacyTransaction:\n      return true;\n  }\n\n  return false;\n}\n/**\n * Should be called to check codeFormat\n *\n * @method validateTypes\n * @param {string}\n * @return {bool}\n */\n\n\nfunction validateCodeFormat(cf) {\n  if (cf === undefined) {\n    return true;\n  }\n\n  switch (cf) {\n    case 0:\n    case 'EVM':\n    case '0x':\n    case '0x0':\n      return true;\n  }\n\n  return false;\n}\n\nfunction validateTxObjectWithType(tx) {\n  if (tx.type === undefined) {\n    return validateLegacy(tx);\n  }\n\n  switch (tx.type) {\n    case 'LEGACY':\n    case TX_TYPE_STRING.TxTypeLegacyTransaction:\n      return validateLegacy(tx);\n\n    case 'VALUE_TRANSFER':\n    case TX_TYPE_STRING.TxTypeValueTransfer:\n      return validateValueTransfer(tx);\n\n    case 'FEE_DELEGATED_VALUE_TRANSFER':\n    case TX_TYPE_STRING.TxTypeFeeDelegatedValueTransfer:\n      return validateFeeDelegatedValueTransfer(tx);\n\n    case 'FEE_DELEGATED_VALUE_TRANSFER_WITH_RATIO':\n    case TX_TYPE_STRING.TxTypeFeeDelegatedValueTransferWithRatio:\n      return validateFeeDelegatedValueTransferWithRatio(tx);\n\n    case 'VALUE_TRANSFER_MEMO':\n    case TX_TYPE_STRING.TxTypeValueTransferMemo:\n      return validateValueTransferMemo(tx);\n\n    case 'FEE_DELEGATED_VALUE_TRANSFER_MEMO':\n    case TX_TYPE_STRING.TxTypeFeeDelegatedValueTransferMemo:\n      return validateFeeDelegatedValueTransferMemo(tx);\n\n    case 'FEE_DELEGATED_VALUE_TRANSFER_MEMO_WITH_RATIO':\n    case TX_TYPE_STRING.TxTypeFeeDelegatedValueTransferMemoWithRatio:\n      return validateFeeDelegatedValueTransferMemoWithRatio(tx);\n\n    case 'ACCOUNT_UPDATE':\n    case TX_TYPE_STRING.TxTypeAccountUpdate:\n      return validateAccountUpdate(tx);\n\n    case 'FEE_DELEGATED_ACCOUNT_UPDATE':\n    case TX_TYPE_STRING.TxTypeFeeDelegatedAccountUpdate:\n      return validateFeeDelegatedAccountUpdate(tx);\n\n    case 'FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO':\n    case TX_TYPE_STRING.TxTypeFeeDelegatedAccountUpdateWithRatio:\n      return validateFeeDelegatedAccountUpdateWithRatio(tx);\n\n    case 'SMART_CONTRACT_DEPLOY':\n    case TX_TYPE_STRING.TxTypeSmartContractDeploy:\n      return validateSmartContractDeploy(tx);\n\n    case 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY':\n    case TX_TYPE_STRING.TxTypeFeeDelegatedSmartContractDeploy:\n      return validateFeeDelegatedSmartContractDeploy(tx);\n\n    case 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY_WITH_RATIO':\n    case TX_TYPE_STRING.TxTypeFeeDelegatedSmartContractDeployWithRatio:\n      return validateFeeDelegatedSmartContractDeployWithRatio(tx);\n\n    case 'SMART_CONTRACT_EXECUTION':\n    case TX_TYPE_STRING.TxTypeSmartContractExecution:\n      return validateSmartContractExecution(tx);\n\n    case 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION':\n    case TX_TYPE_STRING.TxTypeFeeDelegatedSmartContractExecution:\n      return validateFeeDelegatedSmartContractExecution(tx);\n\n    case 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION_WITH_RATIO':\n    case TX_TYPE_STRING.TxTypeFeeDelegatedSmartContractExecutionWithRatio:\n      return validateFeeDelegatedSmartContractExecutionWithRatio(tx);\n\n    case 'CANCEL':\n    case TX_TYPE_STRING.TxTypeCancel:\n      return validateCancel(tx);\n\n    case 'FEE_DELEGATED_CANCEL':\n    case TX_TYPE_STRING.TxTypeFeeDelegatedCancel:\n      return validateFeeDelegatedCancel(tx);\n\n    case 'FEE_DELEGATED_CANCEL_WITH_RATIO':\n    case TX_TYPE_STRING.TxTypeFeeDelegatedCancelWithRatio:\n      return validateFeeDelegatedCancelWithRatio(tx);\n\n    case 'CHAIN_DATA_ANCHORING':\n    case TX_TYPE_STRING.TxTypeChainDataAnchoring:\n      return validateChainDataAnchoring(tx);\n\n    case TX_TYPE_STRING.TxTypeFeeDelegatedChainDataAnchoring:\n      return validateFeeDelegatedChainDataAnchoring(tx);\n\n    case TX_TYPE_STRING.TxTypeFeeDelegatedChainDataAnchoringWithRatio:\n      return validateFeeDelegatedChainDataAnchoringWithRatio(tx);\n  }\n\n  return undefined;\n}\n\nfunction validateLegacy(transaction) {\n  if (transaction.to === undefined && transaction.data === undefined && transaction.input === undefined) {\n    return new Error('contract creation without any data provided');\n  }\n\n  if (transaction.to && transaction.to !== '0x' && !utils.isAddress(transaction.to)) {\n    return new Error(\"Invalid address of to: \".concat(transaction.to));\n  }\n\n  if (transaction.codeFormat !== undefined) {\n    return new Error(\"\\\"codeFormat\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.humanReadable !== undefined) {\n    return new Error(\"\\\"humanReadable\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  var error = validateNonFeeDelegated(transaction);\n  if (error) return error;\n  return validateNotAccountTransaction(transaction);\n}\n\nfunction validateNonFeeDelegated(transaction) {\n  var type = transaction.type ? transaction.type : 'LEGACY';\n\n  if (transaction.feePayer !== undefined) {\n    return new Error(\"\\\"feePayer\\\" cannot be used with \".concat(type, \" transaction\"));\n  }\n\n  if (transaction.feeRatio !== undefined) {\n    return new Error(\"\\\"feeRatio\\\" cannot be used with \".concat(type, \" transaction\"));\n  }\n\n  if (transaction.feePayerSignatures !== undefined) {\n    return new Error(\"\\\"feePayerSignatures\\\" cannot be used with \".concat(type, \" transaction\"));\n  }\n}\n\nfunction validateFeeDelegated(transaction) {\n  if (transaction.type.includes('WITH_RATIO') || transaction.type.includes('WithRatio')) {\n    if (transaction.feeRatio === undefined) {\n      return new Error('\"feeRatio\" is missing');\n    }\n  } else if (transaction.feeRatio !== undefined) {\n    return new Error(\"\\\"feeRatio\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n}\n\nfunction validateNotAccountTransaction(transaction) {\n  var type = transaction.type ? transaction.type : 'LEGACY';\n\n  if (transaction.account !== undefined) {\n    return new Error(\"\\\"account\\\" cannot be used with \".concat(type, \" transaction\"));\n  }\n\n  if (transaction.key !== undefined) {\n    return new Error(\"\\\"key\\\" cannot be used with \".concat(type, \" transaction\"));\n  }\n\n  if (transaction.legacyKey !== undefined) {\n    return new Error(\"\\\"legacyKey\\\" cannot be used with \".concat(type, \" transaction\"));\n  }\n\n  if (transaction.publicKey !== undefined) {\n    return new Error(\"\\\"publicKey\\\" cannot be used with \".concat(type, \" transaction\"));\n  }\n\n  if (transaction.multisig !== undefined) {\n    return new Error(\"\\\"multisig\\\" cannot be used with \".concat(type, \" transaction\"));\n  }\n\n  if (transaction.roleTransactionKey !== undefined) {\n    return new Error(\"\\\"roleTransactionKey\\\" cannot be used with \".concat(type, \" transaction\"));\n  }\n\n  if (transaction.roleAccountUpdateKey !== undefined) {\n    return new Error(\"\\\"roleAccountUpdateKey\\\" cannot be used with \".concat(type, \" transaction\"));\n  }\n\n  if (transaction.roleFeePayerKey !== undefined) {\n    return new Error(\"\\\"roleFeePayerKey\\\" cannot be used with \".concat(type, \" transaction\"));\n  }\n\n  if (transaction.failKey !== undefined) {\n    return new Error(\"\\\"failKey\\\" cannot be used with \".concat(type, \" transaction\"));\n  }\n}\n\nfunction checkValueTransferEssential(transaction) {\n  if (transaction.to === undefined) {\n    return new Error('\"to\" is missing');\n  }\n\n  if (!utils.isAddress(transaction.to)) {\n    return new Error(\"Invalid address of to: \".concat(transaction.to));\n  }\n\n  if (transaction.value === undefined) {\n    return new Error('\"value\" is missing');\n  }\n\n  if (transaction.codeFormat !== undefined) {\n    return new Error(\"\\\"codeFormat\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.data !== undefined) {\n    return new Error(\"\\\"data\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.input !== undefined) {\n    return new Error(\"\\\"input\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.humanReadable !== undefined) {\n    return new Error(\"\\\"humanReadable\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n}\n\nfunction validateValueTransfer(transaction) {\n  var error = checkValueTransferEssential(transaction);\n  if (error) return error;\n  error = validateNonFeeDelegated(transaction);\n  if (error) return error;\n  return validateNotAccountTransaction(transaction);\n}\n\nfunction validateFeeDelegatedValueTransfer(transaction) {\n  var error = checkValueTransferEssential(transaction);\n  if (error) return error;\n  error = validateFeeDelegated(transaction);\n  if (error) return error;\n  return validateNotAccountTransaction(transaction);\n}\n\nfunction validateFeeDelegatedValueTransferWithRatio(transaction) {\n  return validateFeeDelegatedValueTransfer(transaction);\n}\n\nfunction checkValueTransferMemoEssential(transaction) {\n  if (transaction.to === undefined) {\n    return new Error('\"to\" is missing');\n  }\n\n  if (!utils.isAddress(transaction.to)) {\n    return new Error(\"Invalid address of to: \".concat(transaction.to));\n  }\n\n  if (transaction.value === undefined) {\n    return new Error('\"value\" is missing');\n  }\n\n  if (transaction.input !== undefined && transaction.data !== undefined) {\n    return new Error(\"\\\"data\\\" and \\\"input\\\" cannot be used as properties of transactions at the same time.\");\n  }\n\n  if (transaction.input === undefined && transaction.data === undefined) {\n    if (transaction.type.includes('TxType')) return new Error('\"input\" is missing');\n    return new Error('\"data\" is missing');\n  }\n\n  if (transaction.codeFormat !== undefined) {\n    return new Error(\"\\\"codeFormat\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.humanReadable !== undefined) {\n    return new Error(\"\\\"humanReadable\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n}\n\nfunction validateValueTransferMemo(transaction) {\n  var error = checkValueTransferMemoEssential(transaction);\n  if (error) return error;\n  error = validateNonFeeDelegated(transaction);\n  if (error) return error;\n  return validateNotAccountTransaction(transaction);\n}\n\nfunction validateFeeDelegatedValueTransferMemo(transaction) {\n  var error = checkValueTransferMemoEssential(transaction);\n  if (error) return error;\n  error = validateFeeDelegated(transaction);\n  if (error) return error;\n  return validateNotAccountTransaction(transaction);\n}\n\nfunction validateFeeDelegatedValueTransferMemoWithRatio(transaction) {\n  return validateFeeDelegatedValueTransferMemo(transaction);\n}\n\nfunction validateAccountTransaction(transaction) {\n  if (transaction.data !== undefined) {\n    return new Error(\"\\\"data\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.input !== undefined) {\n    return new Error(\"\\\"input\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.codeFormat !== undefined) {\n    return new Error(\"\\\"codeFormat\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.humanReadable !== undefined) {\n    return new Error(\"\\\"humanReadable\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  } // TxTypeAccountUpdate, TxTypeFeeDelegatedAccountUpdate and TxTypeFeeDelegatedAccountUpdateWithRatio transaction use 'account' only\n\n\n  if (transaction.type.includes('TxType')) {\n    if (!transaction.account) return new Error(\"Missing account information with \".concat(transaction.type, \" transaction\"));\n\n    if (transaction.key !== undefined) {\n      return new Error(\"\\\"key\\\" cannot be used with \".concat(transaction.type, \" transaction.\"));\n    }\n\n    if (transaction.legacyKey !== undefined) {\n      return new Error(\"\\\"legacyKey\\\" cannot be used with \".concat(transaction.type, \" transaction.\"));\n    }\n\n    if (transaction.publicKey) {\n      return new Error(\"\\\"publicKey\\\" cannot be used with \".concat(transaction.type, \" transaction.\"));\n    }\n\n    if (transaction.multisig) {\n      return new Error(\"\\\"multisig\\\" cannot be used with \".concat(transaction.type, \" transaction.\"));\n    }\n\n    if (transaction.roleTransactionKey) {\n      return new Error(\"\\\"roleTransactionKey\\\" cannot be used with \".concat(transaction.type, \" transaction.\"));\n    }\n\n    if (transaction.roleAccountUpdateKey) {\n      return new Error(\"\\\"roleAccountUpdateKey\\\" cannot be used with \".concat(transaction.type, \" transaction.\"));\n    }\n\n    if (transaction.roleFeePayerKey) {\n      return new Error(\"\\\"roleFeePayerKey\\\" cannot be used with \".concat(transaction.type, \" transaction.\"));\n    }\n\n    if (transaction.failKey !== undefined) {\n      return new Error(\"\\\"failKey\\\" cannot be used with \".concat(transaction.type, \" transaction.\"));\n    }\n\n    return;\n  }\n\n  if (transaction.account) return new Error(\"\\\"account\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  var duplicatedKeyInfo = \"The key parameter to be used for \".concat(transaction.type, \" is duplicated.\");\n\n  if (!transaction.key && transaction.legacyKey === undefined && !transaction.publicKey && !transaction.multisig && !transaction.roleTransactionKey && !transaction.roleAccountUpdateKey && !transaction.roleFeePayerKey && transaction.failKey === undefined) {\n    return new Error(\"Missing key information with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.key) {\n    if (transaction.legacyKey !== undefined || transaction.publicKey || transaction.multisig || transaction.roleTransactionKey || transaction.roleAccountUpdateKey || transaction.roleFeePayerKey || transaction.failKey !== undefined) {\n      return new Error(duplicatedKeyInfo);\n    }\n  } else if (transaction.legacyKey !== undefined) {\n    if (transaction.publicKey || transaction.multisig || transaction.roleTransactionKey || transaction.roleAccountUpdateKey || transaction.roleFeePayerKey || transaction.failKey !== undefined) {\n      return new Error(duplicatedKeyInfo);\n    }\n  } else if (transaction.publicKey) {\n    if (transaction.multisig || transaction.roleTransactionKey || transaction.roleAccountUpdateKey || transaction.roleFeePayerKey || transaction.failKey !== undefined) {\n      return new Error(duplicatedKeyInfo);\n    }\n  } else if (transaction.multisig) {\n    if (transaction.roleTransactionKey || transaction.roleAccountUpdateKey || transaction.roleFeePayerKey || transaction.failKey !== undefined) {\n      return new Error(duplicatedKeyInfo);\n    }\n  } else if (transaction.failKey !== undefined) {\n    if (transaction.roleTransactionKey || transaction.roleAccountUpdateKey || transaction.roleFeePayerKey) {\n      return new Error(duplicatedKeyInfo);\n    }\n  }\n}\n\nfunction checkUpdateEssential(transaction) {\n  if (transaction.to !== undefined) {\n    return new Error(\"\\\"to\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.value !== undefined) {\n    return new Error(\"\\\"value\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n}\n\nfunction validateAccountUpdate(transaction) {\n  var error = checkUpdateEssential(transaction);\n  if (error) return error;\n  error = validateAccountTransaction(transaction);\n  if (error) return error;\n  return validateNonFeeDelegated(transaction);\n}\n\nfunction validateFeeDelegatedAccountUpdate(transaction) {\n  var error = checkUpdateEssential(transaction);\n  if (error) return error;\n  error = validateAccountTransaction(transaction);\n  if (error) return error;\n  return validateFeeDelegated(transaction);\n}\n\nfunction validateFeeDelegatedAccountUpdateWithRatio(transaction) {\n  return validateFeeDelegatedAccountUpdate(transaction);\n}\n\nfunction checkDeployEssential(transaction) {\n  if (transaction.value === undefined && !transaction.type.includes('TxType')) {\n    return new Error('\"value\" is missing');\n  }\n\n  if (transaction.input !== undefined && transaction.data !== undefined && !transaction.type.includes('TxType')) {\n    return new Error(\"\\\"data\\\" and \\\"input\\\" cannot be used as properties of transactions at the same time.\");\n  }\n\n  if (transaction.input === undefined && transaction.data === undefined) {\n    if (transaction.type.includes('TxType')) return new Error('\"input\" is missing');\n    return new Error('\"data\" is missing');\n  }\n\n  if (transaction.to !== undefined && transaction.to !== '0x') {\n    return new Error(\"\\\"to\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.codeFormat !== undefined && !validateCodeFormat(transaction.codeFormat)) {\n    return new Error(\"The codeFormat(\".concat(transaction.codeFormat, \") is invalid.\"));\n  }\n\n  if (transaction.humanReadable !== undefined && transaction.humanReadable === true) {\n    return new Error('HumanReadableAddress is not supported yet.');\n  }\n}\n\nfunction validateSmartContractDeploy(transaction) {\n  var error = checkDeployEssential(transaction);\n  if (error) return error;\n  error = validateNonFeeDelegated(transaction);\n  if (error) return error;\n  return validateNotAccountTransaction(transaction);\n}\n\nfunction validateFeeDelegatedSmartContractDeploy(transaction) {\n  var error = checkDeployEssential(transaction);\n  if (error) return error;\n  error = validateNotAccountTransaction(transaction);\n  if (error) return error;\n  return validateFeeDelegated(transaction);\n}\n\nfunction validateFeeDelegatedSmartContractDeployWithRatio(transaction) {\n  return validateFeeDelegatedSmartContractDeploy(transaction);\n}\n\nfunction checkExecutionEssential(transaction) {\n  if (transaction.to === undefined) {\n    return new Error('\"to\" is missing');\n  }\n\n  if (!utils.isAddress(transaction.to)) {\n    return new Error(\"Invalid address of to: \".concat(transaction.to));\n  }\n\n  if (transaction.input !== undefined && transaction.data !== undefined) {\n    return new Error(\"\\\"data\\\" and \\\"input\\\" cannot be used as properties of transactions at the same time.\");\n  }\n\n  if (transaction.input === undefined && transaction.data === undefined) {\n    if (transaction.type.includes('TxType')) return new Error('\"input\" is missing');\n    return new Error('\"data\" is missing');\n  }\n\n  if (transaction.codeFormat !== undefined) {\n    return new Error(\"\\\"codeFormat\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.humanReadable !== undefined) {\n    return new Error(\"\\\"humanReadable\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n}\n\nfunction validateSmartContractExecution(transaction) {\n  var error = checkExecutionEssential(transaction);\n  if (error) return error;\n  error = validateNonFeeDelegated(transaction);\n  if (error) return error;\n  return validateNotAccountTransaction(transaction);\n}\n\nfunction validateFeeDelegatedSmartContractExecution(transaction) {\n  var error = checkExecutionEssential(transaction);\n  if (error) return error;\n  error = validateNotAccountTransaction(transaction);\n  if (error) return error;\n  return validateFeeDelegated(transaction);\n}\n\nfunction validateFeeDelegatedSmartContractExecutionWithRatio(transaction) {\n  return validateFeeDelegatedSmartContractExecution(transaction);\n}\n\nfunction checkCacncelEssential(transaction) {\n  if (transaction.to !== undefined) {\n    return new Error(\"\\\"to\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.value !== undefined) {\n    return new Error(\"\\\"value\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.data !== undefined) {\n    return new Error(\"\\\"data\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.input !== undefined) {\n    return new Error(\"\\\"input\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.codeFormat !== undefined) {\n    return new Error(\"\\\"codeFormat\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.humanReadable !== undefined) {\n    return new Error(\"\\\"humanReadable\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n}\n\nfunction validateCancel(transaction) {\n  var error = checkCacncelEssential(transaction);\n  if (error) return error;\n  error = validateNonFeeDelegated(transaction);\n  if (error) return error;\n  return validateNotAccountTransaction(transaction);\n}\n\nfunction validateFeeDelegatedCancel(transaction) {\n  var error = checkCacncelEssential(transaction);\n  if (error) return error;\n  error = validateNotAccountTransaction(transaction);\n  if (error) return error;\n  return validateFeeDelegated(transaction);\n}\n\nfunction validateFeeDelegatedCancelWithRatio(transaction) {\n  return validateFeeDelegatedCancel(transaction);\n}\n\nfunction checkChainDataAnchoringEssential(transaction) {\n  if (transaction.input !== undefined && transaction.data !== undefined) {\n    return new Error(\"\\\"data\\\" and \\\"input\\\" cannot be used as properties of transactions at the same time.\");\n  }\n\n  if (transaction.input === undefined && transaction.data === undefined) {\n    if (transaction.anchoredData !== undefined) {\n      transaction.data = transaction.anchoredData;\n      delete transaction.anchoredData;\n    } else {\n      if (transaction.type.includes('TxType')) return new Error('\"input\" is missing');\n      return new Error('\"data\" is missing');\n    }\n  }\n\n  if (transaction.value !== undefined) {\n    return new Error(\"\\\"value\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.to !== undefined) {\n    return new Error(\"\\\"to\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.codeFormat !== undefined) {\n    return new Error(\"\\\"codeFormat\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n\n  if (transaction.humanReadable !== undefined) {\n    return new Error(\"\\\"humanReadable\\\" cannot be used with \".concat(transaction.type, \" transaction\"));\n  }\n}\n\nfunction validateChainDataAnchoring(transaction) {\n  var error = checkChainDataAnchoringEssential(transaction);\n  if (error) return error;\n  error = validateNonFeeDelegated(transaction);\n  if (error) return error;\n  return validateNotAccountTransaction(transaction);\n}\n\nfunction validateFeeDelegatedChainDataAnchoring(transaction) {\n  var error = checkChainDataAnchoringEssential(transaction);\n  if (error) return error;\n  error = validateNotAccountTransaction(transaction);\n  if (error) return error;\n  return validateFeeDelegated(transaction);\n}\n\nfunction validateFeeDelegatedChainDataAnchoringWithRatio(transaction) {\n  return validateFeeDelegatedChainDataAnchoring(transaction);\n}\n\nmodule.exports = {\n  validateParams: validateParams,\n  validateTxType: validateTxType,\n  validateCodeFormat: validateCodeFormat\n};","map":null,"metadata":{},"sourceType":"script"}