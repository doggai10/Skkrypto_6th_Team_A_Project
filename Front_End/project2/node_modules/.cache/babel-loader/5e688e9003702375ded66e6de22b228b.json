{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst _ = require('lodash');\n\nconst Keyring = require('./keyring/keyringFactory');\n\nconst AbstractKeyring = require('./keyring/abstractKeyring');\n\nconst utils = require('../../caver-utils/src');\n/**\n * representing a Keyring container which manages keyrings.\n * @class\n */\n\n\nclass KeyringContainer {\n  /**\n   * creates a keyringContainer.\n   * @param {Array.<Keyring>} keyrings - The keyrings to be managed in KeyringContainer.\n   */\n  constructor(keyrings) {\n    keyrings = keyrings || [];\n    this._addressKeyringMap = new Map(); // add keyrings to keyringContainer\n\n    for (const keyring of keyrings) {\n      this.add(keyring);\n    }\n  }\n  /**\n   * @type {number}\n   */\n\n\n  get length() {\n    return this._addressKeyringMap.size;\n  }\n  /**\n   * generates keyrings in the keyringContainer with randomly generated key pairs.\n   *\n   * @param {number} numberOfKeyrings The number of keyrings to create.\n   * @param {string} [entropy] A random string to increase entropy. If undefined, a random string will be generated using randomHex.\n   * @return {Array.<string>}\n   */\n\n\n  generate(numberOfKeyrings, entropy) {\n    const addresses = [];\n\n    for (let i = 0; i < numberOfKeyrings; ++i) {\n      addresses.push(this.add(Keyring.generate(entropy)).address);\n    }\n\n    return addresses;\n  }\n  /**\n   * creates a keyring instance with given parameters and adds it to the keyringContainer.\n   * KeyringContainer manages Keyring instance using Map <string:Keyring> which has address as key value.\n   *\n   * @param {string} address The address of the keyring.\n   * @param {string|Array.<string>|Array.<Array.<string>>} key Private key string(s) to use in keyring. If different keys are used for each role, key must be defined as a two-dimensional array.\n   * @return {Keyring}\n   */\n\n\n  newKeyring(address, key) {\n    // The format of key parameter can be\n    // 1. single private key string   => `0x{private key}`\n    // 2. multiple private key string =>[`0x{private key}`, `0x{private key}`, ...]\n    // 3. role based private keys     => [[`0x{private key}`, `0x{private key}`, ...], [], [`0x{private key}`]]\n    let keyring;\n    if (_.isString(key)) keyring = Keyring.createWithSingleKey(address, key);\n\n    if (_.isArray(key)) {\n      if (key.length === 0) throw new Error(\"Insufficient private key information: Empty array\");\n\n      if (_.isArray(key[0])) {\n        keyring = Keyring.createWithRoleBasedKey(address, key);\n      } else {\n        keyring = Keyring.createWithMultipleKey(address, key);\n      }\n    }\n\n    if (!(keyring instanceof AbstractKeyring)) throw new Error(\"Unsupported type value: \".concat(key, \" (type:\").concat(typeof key, \")\"));\n    return this.add(keyring);\n  }\n  /**\n   * updates the keyring inside the keyringContainer.\n   * Query the keyring to be updated from keyringContainer with the keyring's address,\n   * and an error occurs when the keyring is not found in the keyringContainer.\n   *\n   * @param {Keyring} keyring The keyring with new key.\n   * @return {Keyring}\n   */\n\n\n  updateKeyring(keyring) {\n    const founded = this._addressKeyringMap.get(keyring.address.toLowerCase());\n\n    if (founded === undefined) throw new Error(\"Failed to find keyring to update\");\n    this.remove(founded.address);\n    this.add(keyring);\n    return keyring;\n  }\n  /**\n   * Get the keyring in container corresponding to the address\n   *\n   * @param {string} address The address of keyring to query.\n   * @return {Keyring}\n   */\n\n\n  getKeyring(address) {\n    if (!utils.isAddress(address)) throw new Error(\"Invalid address \".concat(address, \". To get keyring from wallet, you need to pass a valid address string as a parameter.\"));\n\n    const founded = this._addressKeyringMap.get(address.toLowerCase());\n\n    return founded;\n  }\n  /**\n   * adds a keyring to the keyringContainer.\n   *\n   * @param {Keyring} keyring A keyring instance to add to keyringContainer.\n   * @return {Keyring}\n   */\n\n\n  add(keyring) {\n    if (this._addressKeyringMap.get(keyring.address.toLowerCase()) !== undefined) throw new Error(\"Duplicate Account \".concat(keyring.address, \". Please use updateKeyring() instead.\"));\n    const keyringToAdd = keyring.copy();\n\n    this._addressKeyringMap.set(keyringToAdd.address.toLowerCase(), keyringToAdd);\n\n    return keyringToAdd;\n  }\n  /**\n   * deletes the keyring that associates with the given address from keyringContainer.\n   *\n   * @param {string} address An address of the keyring to be deleted in keyringContainer.\n   * @return {boolean}\n   */\n\n\n  remove(address) {\n    let keyringToRemove;\n\n    if (utils.isAddress(address)) {\n      keyringToRemove = this.getKeyring(address);\n    } else {\n      throw new Error(\"To remove the keyring, the first parameter should be an address string.\");\n    }\n\n    if (keyringToRemove === undefined) return false; // deallocate keyring object created for keyringContainer\n\n    keyringToRemove.keys = null;\n\n    this._addressKeyringMap.delete(keyringToRemove.address.toLowerCase());\n\n    return true;\n  }\n  /**\n   * signs with data and returns the result object that includes `signature`, `message` and `messageHash`\n   *\n   * @param {string} address An address of keyring in keyringContainer.\n   * @param {string} data The data string to sign.\n   * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n   * @param {number} [index] An index of key to use for signing.\n   * @return {object}\n   */\n\n\n  signMessage(address, data, role, index) {\n    const keyring = this.getKeyring(address);\n    if (keyring === undefined) throw new Error(\"Failed to find keyring from wallet with \".concat(address));\n    return keyring.signMessage(data, role, index);\n  }\n  /**\n   * signs the transaction using one key and return the transactionHash\n   *\n   * @param {string} address An address of keyring in keyringContainer.\n   * @param {Transaction} transaction A transaction object.\n   * @param {number} [index] An index of key to use for signing. If index is undefined, all private keys in keyring will be used.\n   * @param {function} [hasher] A function to return hash of transaction.\n   * @return {Transaction}\n   */\n\n\n  async sign(address, transaction, index, hasher) {\n    const keyring = this.getKeyring(address);\n    if (keyring === undefined) throw new Error(\"Failed to find keyring from wallet with \".concat(address));\n    const signed = await transaction.sign(keyring, index, hasher);\n    return signed;\n  }\n  /**\n   * signs the transaction as a fee payer using one key and return the transactionHash\n   *\n   * @param {string} address An address of keyring in keyringContainer.\n   * @param {Transaction} transaction A transaction object. This should be `FEE_DELEGATED` type.\n   * @param {number} [index] An index of key to use for signing. If index is undefined, all private keys in keyring will be used.\n   * @param {function} [hasher] A function to return hash of transaction.\n   * @return {Transaction}\n   */\n\n\n  async signAsFeePayer(address, transaction, index, hasher) {\n    const keyring = this.getKeyring(address);\n    if (keyring === undefined) throw new Error(\"Failed to find keyring from wallet with \".concat(address));\n    const signed = await transaction.signAsFeePayer(keyring, index, hasher);\n    return signed;\n  }\n\n}\n\nmodule.exports = KeyringContainer;","map":null,"metadata":{},"sourceType":"script"}