{"ast":null,"code":"var _slicedToArray = require(\"/Users/heeje/Desktop/test/react-dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\n/*\n    Copyright 2018 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst RLP = require('eth-lib/lib/rlp');\n\nconst Bytes = require('eth-lib/lib/bytes');\n\nconst utils = require('../../../../caver-utils');\n\nconst helpers = require('../../../../caver-core-helpers');\n\nconst _helpers$constants = helpers.constants,\n      ACCOUNT_UPDATE_TYPE_TAG = _helpers$constants.ACCOUNT_UPDATE_TYPE_TAG,\n      ACCOUNT_KEY_NIL_TAG = _helpers$constants.ACCOUNT_KEY_NIL_TAG,\n      ACCOUNT_KEY_LEGACY_TAG = _helpers$constants.ACCOUNT_KEY_LEGACY_TAG,\n      ACCOUNT_KEY_PUBLIC_TAG = _helpers$constants.ACCOUNT_KEY_PUBLIC_TAG,\n      ACCOUNT_KEY_FAIL_TAG = _helpers$constants.ACCOUNT_KEY_FAIL_TAG,\n      ACCOUNT_KEY_WEIGHTED_MULTISIG_TAG = _helpers$constants.ACCOUNT_KEY_WEIGHTED_MULTISIG_TAG,\n      ACCOUNT_KEY_ROLE_BASED_TAG = _helpers$constants.ACCOUNT_KEY_ROLE_BASED_TAG,\n      FEE_DELEGATED_ACCOUNT_UPDATE_TYPE_TAG = _helpers$constants.FEE_DELEGATED_ACCOUNT_UPDATE_TYPE_TAG,\n      FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO_TYPE_TAG = _helpers$constants.FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO_TYPE_TAG;\n\nfunction rlpEncodeForAccountUpdate(transaction) {\n  const accountKey = resolveRawKeyToAccountKey(transaction);\n  return RLP.encode([RLP.encode([ACCOUNT_UPDATE_TYPE_TAG, Bytes.fromNat(transaction.nonce), Bytes.fromNat(transaction.gasPrice), Bytes.fromNat(transaction.gas), transaction.from.toLowerCase(), accountKey]), Bytes.fromNat(transaction.chainId || '0x1'), '0x', '0x']);\n}\n\nfunction rlpEncodeForFeeDelegatedAccountUpdate(transaction) {\n  if (transaction.senderRawTransaction) {\n    const typeDetacehdRawTransaction = \"0x\".concat(transaction.senderRawTransaction.slice(4)); // eslint-disable-next-line no-unused-vars\n\n    const _utils$rlpDecode = utils.rlpDecode(typeDetacehdRawTransaction),\n          _utils$rlpDecode2 = _slicedToArray(_utils$rlpDecode, 6),\n          nonce = _utils$rlpDecode2[0],\n          gasPrice = _utils$rlpDecode2[1],\n          gas = _utils$rlpDecode2[2],\n          from = _utils$rlpDecode2[3],\n          accountKey = _utils$rlpDecode2[4],\n          _utils$rlpDecode2$ = _slicedToArray(_utils$rlpDecode2[5], 1),\n          _utils$rlpDecode2$$ = _slicedToArray(_utils$rlpDecode2$[0], 3),\n          v = _utils$rlpDecode2$$[0],\n          r = _utils$rlpDecode2$$[1],\n          s = _utils$rlpDecode2$$[2];\n\n    return RLP.encode([RLP.encode([FEE_DELEGATED_ACCOUNT_UPDATE_TYPE_TAG, Bytes.fromNat(nonce), Bytes.fromNat(gasPrice), Bytes.fromNat(gas), from.toLowerCase(), accountKey]), transaction.feePayer.toLowerCase(), Bytes.fromNat(transaction.chainId || '0x1'), '0x', '0x']);\n  }\n\n  const accountKey = resolveRawKeyToAccountKey(transaction);\n  return RLP.encode([RLP.encode([FEE_DELEGATED_ACCOUNT_UPDATE_TYPE_TAG, Bytes.fromNat(transaction.nonce), Bytes.fromNat(transaction.gasPrice), Bytes.fromNat(transaction.gas), transaction.from.toLowerCase(), accountKey]), Bytes.fromNat(transaction.chainId || '0x1'), '0x', '0x']);\n}\n\nfunction rlpEncodeForFeeDelegatedAccountUpdateWithRatio(transaction) {\n  if (transaction.senderRawTransaction) {\n    const typeDetacehdRawTransaction = \"0x\".concat(transaction.senderRawTransaction.slice(4)); // eslint-disable-next-line no-unused-vars\n\n    const _utils$rlpDecode3 = utils.rlpDecode(typeDetacehdRawTransaction),\n          _utils$rlpDecode4 = _slicedToArray(_utils$rlpDecode3, 7),\n          nonce = _utils$rlpDecode4[0],\n          gasPrice = _utils$rlpDecode4[1],\n          gas = _utils$rlpDecode4[2],\n          from = _utils$rlpDecode4[3],\n          accountKey = _utils$rlpDecode4[4],\n          feeRatio = _utils$rlpDecode4[5],\n          _utils$rlpDecode4$ = _slicedToArray(_utils$rlpDecode4[6], 1),\n          _utils$rlpDecode4$$ = _slicedToArray(_utils$rlpDecode4$[0], 3),\n          v = _utils$rlpDecode4$$[0],\n          r = _utils$rlpDecode4$$[1],\n          s = _utils$rlpDecode4$$[2];\n\n    return RLP.encode([RLP.encode([FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO_TYPE_TAG, Bytes.fromNat(nonce), Bytes.fromNat(gasPrice), Bytes.fromNat(gas), from.toLowerCase(), accountKey, Bytes.fromNat(feeRatio)]), transaction.feePayer.toLowerCase(), Bytes.fromNat(transaction.chainId || '0x1'), '0x', '0x']);\n  }\n\n  const accountKey = resolveRawKeyToAccountKey(transaction);\n  return RLP.encode([RLP.encode([FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO_TYPE_TAG, Bytes.fromNat(transaction.nonce), Bytes.fromNat(transaction.gasPrice), Bytes.fromNat(transaction.gas), transaction.from.toLowerCase(), accountKey, Bytes.fromNat(transaction.feeRatio)]), Bytes.fromNat(transaction.chainId || '0x1'), '0x', '0x']);\n}\n\nfunction resolveRawKeyToAccountKey(transaction) {\n  // Handles the case where AccountForUpdate is set in key field in transaction object to update account.\n  if (transaction.key) {\n    if (transaction.from && transaction.from.toLowerCase() !== transaction.key.address.toLowerCase()) {\n      throw new Error('The value of the from field of the transaction does not match the address of AccountForUpdate.');\n    }\n\n    transaction.key.fillUpdateObject(transaction);\n  }\n\n  if (transaction.legacyKey) return ACCOUNT_KEY_LEGACY_TAG;\n  if (transaction.failKey) return ACCOUNT_KEY_FAIL_TAG;\n\n  if (transaction.multisig) {\n    const _transaction$multisig = transaction.multisig,\n          threshold = _transaction$multisig.threshold,\n          keys = _transaction$multisig.keys;\n    const encodedMultisigPublicKeys = keys.map(({\n      weight,\n      publicKey\n    }) => {\n      if (!weight) throw new Error('weight should be specified for multisig account');\n      if (!publicKey) throw new Error('publicKey should be specified for multisig account');\n      const compressedPublicKey = utils.compressPublicKey(publicKey);\n      return [Bytes.fromNat(utils.numberToHex(weight)), compressedPublicKey];\n    });\n    return ACCOUNT_KEY_WEIGHTED_MULTISIG_TAG + RLP.encode([Bytes.fromNat(utils.numberToHex(threshold)), encodedMultisigPublicKeys]).slice(2);\n  }\n\n  if (transaction.publicKey) {\n    const compressedPublicKey = utils.compressPublicKey(transaction.publicKey);\n    return ACCOUNT_KEY_PUBLIC_TAG + RLP.encode(compressedPublicKey).slice(2);\n  }\n\n  if (transaction.roleTransactionKey || transaction.roleAccountUpdateKey || transaction.roleFeePayerKey) {\n    // Create a new object so as not to damage the input transaction object.\n    const roleBasedObject = {};\n    roleBasedObject.roleTransactionKey = transaction.roleTransactionKey ? resolveRawKeyToAccountKey(transaction.roleTransactionKey) : ACCOUNT_KEY_NIL_TAG;\n    roleBasedObject.roleAccountUpdateKey = transaction.roleAccountUpdateKey ? resolveRawKeyToAccountKey(transaction.roleAccountUpdateKey) : ACCOUNT_KEY_NIL_TAG;\n    roleBasedObject.roleFeePayerKey = transaction.roleFeePayerKey ? resolveRawKeyToAccountKey(transaction.roleFeePayerKey) : ACCOUNT_KEY_NIL_TAG;\n    const keys = [roleBasedObject.roleTransactionKey, roleBasedObject.roleAccountUpdateKey, roleBasedObject.roleFeePayerKey];\n    return ACCOUNT_KEY_ROLE_BASED_TAG + RLP.encode(keys).slice(2);\n  }\n\n  return ACCOUNT_KEY_NIL_TAG;\n}\n\nfunction parseAccountKey(transaction) {\n  const key = transaction.accountKey;\n  delete transaction.accountKey;\n\n  if (key.startsWith(ACCOUNT_KEY_LEGACY_TAG)) {\n    transaction.legacyKey = true;\n  } else if (key.startsWith(ACCOUNT_KEY_FAIL_TAG)) {\n    transaction.failKey = true;\n  } else if (key.startsWith(ACCOUNT_KEY_PUBLIC_TAG)) {\n    transaction.publicKey = RLP.decode(\"0x\".concat(key.slice(ACCOUNT_KEY_PUBLIC_TAG.length)));\n  } else if (key.startsWith(ACCOUNT_KEY_WEIGHTED_MULTISIG_TAG)) {\n    let _RLP$decode = RLP.decode(\"0x\".concat(key.slice(ACCOUNT_KEY_WEIGHTED_MULTISIG_TAG.length))),\n        _RLP$decode2 = _slicedToArray(_RLP$decode, 2),\n        threshold = _RLP$decode2[0],\n        multiSigkeys = _RLP$decode2[1];\n\n    multiSigkeys = multiSigkeys.map(k => {\n      return {\n        weight: utils.hexToNumber(k[0]),\n        publicKey: k[1]\n      };\n    });\n    transaction.multisig = {\n      threshold: utils.hexToNumber(threshold),\n      keys: multiSigkeys\n    };\n  } else if (key.startsWith(ACCOUNT_KEY_ROLE_BASED_TAG)) {\n    const keys = RLP.decode(\"0x\".concat(key.slice(ACCOUNT_KEY_ROLE_BASED_TAG.length)));\n    keys.map(k => {\n      if (k.startsWith(ACCOUNT_KEY_ROLE_BASED_TAG)) throw new Error('Nested role based key.');\n    });\n    if (keys.length > 0 && !keys[0].startsWith(ACCOUNT_KEY_NIL_TAG)) transaction.roleTransactionKey = parseAccountKey({\n      accountKey: keys[0]\n    });\n    if (keys.length > 1 && !keys[1].startsWith(ACCOUNT_KEY_NIL_TAG)) transaction.roleAccountUpdateKey = parseAccountKey({\n      accountKey: keys[1]\n    });\n    if (keys.length > 2 && !keys[2].startsWith(ACCOUNT_KEY_NIL_TAG)) transaction.roleFeePayerKey = parseAccountKey({\n      accountKey: keys[2]\n    });\n  }\n\n  return transaction;\n}\n\nmodule.exports = {\n  rlpEncodeForAccountUpdate,\n  rlpEncodeForFeeDelegatedAccountUpdate,\n  rlpEncodeForFeeDelegatedAccountUpdateWithRatio,\n  parseAccountKey\n};","map":null,"metadata":{},"sourceType":"script"}