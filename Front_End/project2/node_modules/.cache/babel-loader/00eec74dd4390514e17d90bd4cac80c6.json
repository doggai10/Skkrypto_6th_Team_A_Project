{"ast":null,"code":"var _slicedToArray = require(\"/Users/heeje/Desktop/test/react-dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\n/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-eth-accounts/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file accounts.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nconst _ = require('lodash');\n\nconst Promise = require('any-promise'); // account, hash, rlp, nat, bytes library will be used from 'eth-lib' temporarily.\n\n\nconst AccountLib = require('eth-lib/lib/account');\n\nconst Hash = require('eth-lib/lib/hash');\n\nconst RLP = require('eth-lib/lib/rlp');\n\nconst Nat = require('eth-lib/lib/nat');\n\nconst Bytes = require('eth-lib/lib/bytes');\n\nconst cryp = typeof global === 'undefined' ? require('crypto-browserify') : require('crypto');\n\nconst uuid = require('uuid');\n\nconst elliptic = require('elliptic');\n\nconst scrypt = require('scrypt-js');\n\nconst utils = require('../../../caver-utils');\n\nconst helpers = require('../../../caver-core-helpers');\n\nconst Method = require('../../../caver-core-method');\n\nconst core = require('../../../caver-core');\n\nconst _require = require('./makeRawTransaction'),\n      encodeRLPByTxType = _require.encodeRLPByTxType,\n      makeRawTransaction = _require.makeRawTransaction,\n      getSenderTxHash = _require.getSenderTxHash,\n      decodeFromRawTransaction = _require.decodeFromRawTransaction,\n      splitFeePayer = _require.splitFeePayer,\n      extractSignatures = _require.extractSignatures;\n\nconst secp256k1 = new elliptic.ec('secp256k1');\n\nconst AccountKeyPublic = require('./accountKey/accountKeyPublic');\n\nconst AccountKeyMultiSig = require('./accountKey/accountKeyMultiSig');\n\nconst AccountKeyRoleBased = require('./accountKey/accountKeyRoleBased');\n\nconst _require2 = require('./accountKey/accountKeyEnum'),\n      AccountKeyEnum = _require2.AccountKeyEnum;\n\nconst Account = require('./account/account');\n\nconst AccountForUpdate = require('./account/accountForUpdate');\n\nconst _require3 = require('../../../caver-rtm'),\n      rpc = _require3.rpc;\n\nconst isNot = function (value) {\n  return _.isUndefined(value) || _.isNull(value);\n};\n\nfunction coverInitialTxValue(tx) {\n  if (typeof tx !== 'object') throw new Error('Invalid transaction');\n\n  if (!tx.senderRawTransaction && (!tx.type || tx.type === 'LEGACY' || tx.type.includes('SMART_CONTRACT_DEPLOY'))) {\n    tx.to = tx.to || '0x';\n    tx.data = utils.addHexPrefix(tx.data || '0x');\n  }\n\n  tx.chainId = utils.numberToHex(tx.chainId);\n  return tx;\n}\n/**\n * resolveArgsForSignTransaction parse arguments for signTransaction.\n *\n * @method resolveArgsForSignTransaction\n * @param {Object} args Parameters of signTransaction.\n * @return {Object}\n */\n\n\nfunction resolveArgsForSignTransaction(args) {\n  if (args.length === 0 || args.length > 3) {\n    throw new Error('Invalid parameter: The number of parameters is invalid.');\n  } // privateKey and callback are optional parameter\n  // \"args.length === 2\" means that user sent parameter privateKey or callback\n\n\n  const tx = args[0];\n  let privateKey;\n  let callback;\n\n  if (!tx || !_.isObject(tx) && !_.isString(tx)) {\n    throw new Error('Invalid parameter: The transaction must be defined as an object or RLP encoded string');\n  }\n\n  if (args.length === 2) {\n    if (_.isFunction(args[1])) {\n      callback = args[1];\n    } else {\n      privateKey = args[1];\n    }\n  } else if (args.length === 3) {\n    if (args[1] && typeof args[1] !== 'string' && !_.isArray(args[1])) {\n      throw new Error('Invalid parameter: The parameter for the private key is invalid');\n    }\n\n    privateKey = args[1];\n    callback = args[2];\n  } // For handling when callback is undefined.\n\n\n  callback = callback || function () {};\n\n  return {\n    tx,\n    privateKey,\n    callback\n  };\n}\n/**\n * resolveArgsForFeePayerSignTransaction parse arguments for feePayerSignTransaction.\n *\n * @method resolveArgsForFeePayerSignTransaction\n * @param {Object} args Parameters of feePayerSignTransaction.\n * @return {Object}\n */\n\n\nfunction resolveArgsForFeePayerSignTransaction(args) {\n  if (args.length === 0 || args.length > 4) {\n    throw new Error('Invalid parameter: The number of parameters is invalid.');\n  } // privateKey and callback are optional parameter\n  // \"args.length === 3\" means that user sent parameter privateKey or callback\n\n\n  const tx = args[0];\n  const feePayer = args[1];\n  let privateKey;\n  let callback;\n\n  if (!tx || !_.isObject(tx) && !_.isString(tx)) {\n    throw new Error('Invalid parameter: The transaction must be defined as an object or RLP encoded string');\n  }\n\n  if (!utils.isAddress(feePayer)) {\n    throw new Error(\"Invalid fee payer address : \".concat(feePayer));\n  }\n\n  if (args.length === 3) {\n    if (_.isFunction(args[2])) {\n      callback = args[2];\n    } else {\n      privateKey = args[2];\n    }\n  } else if (args.length === 4) {\n    if (args[2] && typeof args[2] !== 'string' && !_.isArray(args[2])) {\n      throw new Error('Invalid parameter: The parameter for the private key is invalid');\n    }\n\n    privateKey = args[2];\n    callback = args[3];\n  } // For handling when callback is undefined.\n\n\n  callback = callback || function () {};\n\n  return {\n    tx,\n    privateKey,\n    feePayer,\n    callback\n  };\n}\n/**\n * resolveArgsForSignTransactionWithHash parse arguments for signTransactionWithHash.\n *\n * @method resolveArgsForSignTransactionWithHash\n * @param {Object} args Parameters of signTransactionWithHash.\n * @return {Object}\n */\n\n\nfunction resolveArgsForSignTransactionWithHash(args) {\n  if (args.length < 2 || args.length > 4) {\n    throw new Error('Invalid parameter: The number of parameters is invalid.');\n  }\n\n  const hash = args[0];\n  const privateKeys = args[1];\n  let chainId;\n  let callback;\n\n  if (!hash) {\n    throw new Error('Invalid parameter: The hash of transaction must be defined as a parameter.');\n  }\n\n  if (!utils.isValidHashStrict(hash)) {\n    throw new Error('Invalid parameter: The hash of transaction must be 0x-hex prefixed string format.');\n  }\n\n  if (!privateKeys || !Array.isArray(privateKeys) && !_.isString(privateKeys)) {\n    throw new Error(\"Invalid parameter: The private key should be a private key string or an array of private keys.\");\n  }\n\n  if (args.length === 3) {\n    if (_.isFunction(args[2])) {\n      callback = args[2];\n    } else {\n      chainId = args[2];\n    }\n  } else if (args.length === 4) {\n    if (args[2] && !_.isString(args[2]) && !_.isNumber(args[2])) {\n      throw new Error('Invalid parameter: The parameter for the chain id is invalid.');\n    }\n\n    chainId = args[2];\n    callback = args[3];\n  } // For handling when callback is undefined.\n\n\n  callback = callback || function () {};\n\n  return {\n    hash,\n    privateKeys,\n    chainId,\n    callback\n  };\n}\n\nfunction encryptKey(privateKey, password, options) {\n  const encryptedArray = [];\n  if (!privateKey) return encryptedArray;\n  const privateKeyArray = _.isArray(privateKey) ? privateKey : [privateKey];\n\n  for (let i = 0; i < privateKeyArray.length; i++) {\n    const salt = options.salt || cryp.randomBytes(32);\n    const iv = options.iv || cryp.randomBytes(16);\n    let derivedKey;\n    const kdf = options.kdf || 'scrypt';\n    const kdfparams = {\n      dklen: options.dklen || 32,\n      salt: salt.toString('hex')\n    };\n    /**\n     * Supported kdf modules are the following:\n     * 1) pbkdf2\n     * 2) scrypt - default\n     */\n\n    if (kdf === 'pbkdf2') {\n      kdfparams.c = options.c || 262144;\n      kdfparams.prf = 'hmac-sha256';\n      derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n    } else if (kdf === 'scrypt') {\n      // FIXME: support progress reporting callback\n      kdfparams.n = options.n || 4096; // 2048 4096 8192 16384\n\n      kdfparams.r = options.r || 8;\n      kdfparams.p = options.p || 1;\n      derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n    } else {\n      throw new Error('Unsupported kdf');\n    }\n\n    const cipher = cryp.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);\n\n    if (!cipher) {\n      throw new Error('Unsupported cipher');\n    }\n\n    const ciphertext = Buffer.from([...cipher.update(Buffer.from(privateKeyArray[i].replace('0x', ''), 'hex')), ...cipher.final()]);\n    const mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '');\n    encryptedArray.push({\n      ciphertext: ciphertext.toString('hex'),\n      cipherparams: {\n        iv: iv.toString('hex')\n      },\n      cipher: options.cipher || 'aes-128-ctr',\n      kdf,\n      kdfparams,\n      mac: mac.toString('hex')\n    });\n  }\n\n  return encryptedArray;\n}\n\nconst Accounts = function Accounts(...args) {\n  const _this = this; // sets _requestmanager\n\n\n  core.packageInit(this, args); // remove unecessary core functions\n\n  delete this.BatchRequest;\n  delete this.extend;\n  const _klaytnCall = [rpc.getChainId, rpc.getGasPrice, rpc.getTransactionCount]; // attach methods to this._klaytnCall\n\n  this._klaytnCall = {};\n\n  _.each(_klaytnCall, function (method) {\n    method = new Method(method);\n    method.attachToObject(_this._klaytnCall);\n    method.setRequestManager(_this._requestManager);\n  });\n\n  this.wallet = new Wallet(this);\n};\n\nAccounts.prototype._addAccountFunctions = function (account) {\n  const _this = this; // add sign functions\n\n\n  account.signTransaction = function signTransaction(tx, callback) {\n    const roleKey = _this._getRoleKey(tx, account);\n\n    return _this.signTransaction(tx, roleKey, callback);\n  };\n\n  account.feePayerSignTransaction = function feePayerSignTransaction(tx, callback) {\n    return _this.feePayerSignTransaction(tx, account.address, account.feePayerKey, callback);\n  };\n\n  account.sign = function sign(data) {\n    return _this.sign(data, account.privateKey);\n  };\n\n  account.encrypt = function encrypt(password, options = {}) {\n    options.address = account.address;\n    return _this.encrypt(account.keys, password, options);\n  };\n\n  account.getKlaytnWalletKey = function getKlaytnWalletKey() {\n    return genKlaytnWalletKeyStringFromAccount(account);\n  };\n\n  return account;\n};\n/**\n * _determineAddress determines the priority of the parameters entered and returns the address that should be used for the account.\n *\n * @method _determineAddress\n * @param {Object} legacyAccount Account with a legacy account key extracted from private key to be used for address determination.\n * @param {String} addressFromKey Address extracted from key.\n * @param {String} userInputAddress Address passed as parameter by user.\n * @return {String}\n */\n\n\nAccounts.prototype._determineAddress = function _determineAddress(legacyAccount, addressFromKey, userInputAddress) {\n  if (userInputAddress) {\n    if (addressFromKey && addressFromKey !== userInputAddress) {\n      throw new Error('The address extracted from the private key does not match the address received as the input value.');\n    }\n\n    if (!utils.isAddress(userInputAddress)) {\n      throw new Error('The address received as the input value is invalid.');\n    }\n\n    return userInputAddress;\n  }\n\n  if (addressFromKey) {\n    if (!utils.isAddress(addressFromKey)) {\n      throw new Error('The address extracted from the private key is invalid.');\n    } // If userInputAddress is undefined and address which is came from private is existed, set address in account.\n\n\n    return addressFromKey;\n  }\n\n  return legacyAccount.address;\n};\n/**\n * _getRoleKey returns a key that matches the role that should be used according to the transaction.\n *\n * @method _getRoleKey\n * @param {Object} tx transaction object to be sign.\n * @param {Object} account Account to be used for signing.\n * @return {String|Array}\n */\n\n\nAccounts.prototype._getRoleKey = function _getRoleKey(tx, account) {\n  let key;\n\n  if (!account) {\n    throw new Error('The account to be used for signing is not defined.');\n  }\n\n  if (tx.senderRawTransaction && tx.feePayer) {\n    key = account.feePayerKey;\n  } else if (tx.type && tx.type.includes('ACCOUNT_UPDATE')) {\n    key = account.updateKey;\n  } else {\n    key = account.transactionKey;\n  }\n\n  if (!key) {\n    throw new Error('The key corresponding to the role used for signing is not defined.');\n  }\n\n  return key;\n};\n/**\n * create function creates random account with entropy.\n *\n * @method create\n * @param {Object} entropy A random string to increase entropy.\n * @return {Object}\n */\n\n\nAccounts.prototype.create = function create(entropy) {\n  return this._addAccountFunctions(Account.fromObject(AccountLib.create(entropy || utils.randomHex(32))));\n};\n/**\n * createAccountKey creates AccountKeyPublic, AccountKeyMultiSig or AccountKeyRoleBased instance with parameter.\n *\n * @method createAccountKey\n * @param {String|Array|Object} accountKey Parameters to be used when creating the AccountKey.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountKey = function createAccountKey(accountKey) {\n  if (Account.isAccountKey(accountKey)) accountKey = accountKey.keys;\n\n  if (_.isString(accountKey)) {\n    accountKey = this.createAccountKeyPublic(accountKey);\n  } else if (_.isArray(accountKey)) {\n    accountKey = this.createAccountKeyMultiSig(accountKey);\n  } else if (_.isObject(accountKey)) {\n    accountKey = this.createAccountKeyRoleBased(accountKey);\n  } else {\n    throw new Error(\"Invalid accountKey type: \".concat(typeof accountKey));\n  }\n\n  return accountKey;\n};\n/**\n * createAccountKeyPublic creates AccountKeyPublic with a string of private key.\n *\n * @method createAccountKeyPublic\n * @param {String} privateKey Private key string that will be used to create AccountKeyPublic.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountKeyPublic = function createAccountKeyPublic(privateKey) {\n  if (privateKey instanceof AccountKeyPublic) return privateKey;\n\n  if (!_.isString(privateKey)) {\n    throw new Error('Creating a AccountKeyPublic requires a private key string.');\n  }\n\n  const parsed = utils.parsePrivateKey(privateKey);\n  privateKey = parsed.privateKey;\n\n  if (!utils.isValidPrivateKey(privateKey)) {\n    throw new Error(\"Failed to create AccountKeyPublic. Invalid private key : \".concat(privateKey));\n  }\n\n  return new AccountKeyPublic(privateKey);\n};\n/**\n * createAccountKeyMultiSig creates AccountKeyMultiSig with an array of private keys.\n *\n * @method createAccountKeyMultiSig\n * @param {Array} privateKeys An Array of private key strings that will be used to create AccountKeyMultiSig.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountKeyMultiSig = function createAccountKeyMultiSig(privateKeys) {\n  if (privateKeys instanceof AccountKeyMultiSig) return privateKeys;\n\n  if (!_.isArray(privateKeys)) {\n    throw new Error('Creating a AccountKeyMultiSig requires an array of private key string.');\n  }\n\n  for (let i = 0; i < privateKeys.length; i++) {\n    const parsed = utils.parsePrivateKey(privateKeys[i]);\n    const p = parsed.privateKey;\n\n    if (!utils.isValidPrivateKey(p)) {\n      throw new Error(\"Failed to create AccountKeyMultiSig. Invalid private key : \".concat(p));\n    }\n  }\n\n  return new AccountKeyMultiSig(privateKeys);\n};\n/**\n * createAccountKeyRoleBased creates AccountKeyRoleBased with an object of key.\n *\n * @method createAccountKeyRoleBased\n * @param {Object} keyObject Object that defines key for each role to use when creating AccountKeyRoleBased.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountKeyRoleBased = function createAccountKeyRoleBased(keyObject) {\n  if (keyObject instanceof AccountKeyRoleBased) return keyObject;\n\n  if (!_.isObject(keyObject) || _.isArray(keyObject)) {\n    throw new Error('Creating a AccountKeyRoleBased requires an object.');\n  }\n\n  return new AccountKeyRoleBased(keyObject);\n};\n/**\n * accountKeyToPublicKey creates public key format with AccountKey.\n *\n * @method accountKeyToPublicKey\n * @param {Object} accountKey AccountKey instance for which you want to generate a public key format.\n * @return {String|Array|Object}\n */\n\n\nAccounts.prototype.accountKeyToPublicKey = function accountKeyToPublicKey(accountKey) {\n  accountKey = this.createAccountKey(accountKey);\n  return accountKey.toPublicKey(this.privateKeyToPublicKey);\n};\n/**\n * createWithAccountKey creates Account instance with AccountKey.\n *\n * @method createWithAccountKey\n * @param {String} address The address of account.\n * @param {String|Array|Object} accountKey The accountKey of account.\n * @return {Object}\n */\n\n\nAccounts.prototype.createWithAccountKey = function createWithAccountKey(address, accountKey) {\n  const account = new Account(address, this.createAccountKey(accountKey));\n  return this._addAccountFunctions(account);\n};\n/**\n * createWithAccountKeyPublic create an account with AccountKeyPublic.\n *\n * @method createWithAccountKeyPublic\n * @param {String} address An address of account.\n * @param {String|Object} key Key of account.\n * @return {Object}\n */\n\n\nAccounts.prototype.createWithAccountKeyPublic = function createWithAccountKeyPublic(address, key) {\n  if (!Account.isAccountKey(key)) key = this.createAccountKeyPublic(key);\n\n  if (key.type !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n    throw new Error(\"Failed to create account with AccountKeyPublic. Invalid account key : \".concat(key.type));\n  }\n\n  const account = new Account(address, key);\n  return this._addAccountFunctions(account);\n};\n/**\n * createWithAccountKeyMultiSig create an account with AccountKeyMultiSig.\n *\n * @method createWithAccountKeyMultiSig\n * @param {String} address An address of account.\n * @param {String|Object} keys Key of account.\n * @return {Object}\n */\n\n\nAccounts.prototype.createWithAccountKeyMultiSig = function createWithAccountKeyMultiSig(address, keys) {\n  if (!Account.isAccountKey(keys)) keys = this.createAccountKeyMultiSig(keys);\n\n  if (keys.type !== AccountKeyEnum.ACCOUNT_KEY_MULTISIG) {\n    throw new Error(\"Failed to create account with AccountKeyMultiSig. Invalid account key : \".concat(keys.type));\n  }\n\n  const account = new Account(address, keys);\n  return this._addAccountFunctions(account);\n};\n/**\n * createWithAccountKeyRoleBased create an account with AccountKeyRoleBased.\n *\n * @method createWithAccountKeyRoleBased\n * @param {String} address An address of account.\n * @param {String|Object} keyObject Key of account.\n * @return {Object}\n */\n\n\nAccounts.prototype.createWithAccountKeyRoleBased = function createWithAccountKeyRoleBased(address, keyObject) {\n  if (!Account.isAccountKey(keyObject)) {\n    keyObject = this.createAccountKeyRoleBased(keyObject);\n  }\n\n  if (keyObject.type !== AccountKeyEnum.ACCOUNT_KEY_ROLEBASED) {\n    throw new Error(\"Failed to create account with AccountKeyRoleBased. Invalid account key : \".concat(keyObject.type));\n  }\n\n  const account = new Account(address, keyObject);\n  return this._addAccountFunctions(account);\n};\n/**\n * privateKeyToAccount creates and returns an Account through the input passed as parameters.\n *\n * @method privateKeyToAccount\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @param {String} userInputAddress The address entered by the user for use in creating an account.\n * @return {Object}\n */\n\n\nAccounts.prototype.privateKeyToAccount = function privateKeyToAccount(key, userInputAddress) {\n  const _this$getLegacyAccoun = this.getLegacyAccount(key),\n        account = _this$getLegacyAccoun.legacyAccount,\n        klaytnWalletKeyAddress = _this$getLegacyAccoun.klaytnWalletKeyAddress;\n\n  account.address = this._determineAddress(account, klaytnWalletKeyAddress, userInputAddress);\n  account.address = account.address.toLowerCase();\n  account.address = utils.addHexPrefix(account.address);\n  return account;\n};\n/**\n * createAccountForUpdate creates an AccountForUpdate instance.\n * The AccountForUpdate returned as a result of this function contains only the address and public key used to update the account.\n *\n * @method createAccountForUpdate\n * @param {String} address The address value of AccountForUpdate, a structure that contains data for updating an account.\n * @param {String|Array|Object} accountKey Private key or AccountKey to update account.\n * @param {Object} options Options to use for setting threshold and weight for multiSig.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountForUpdate = function createAccountForUpdate(address, accountKey, options) {\n  let legacyOrFail; // Logic for handling cases where legacyKey or failKey is set inside AccountKeyRoleBased object.\n\n  if (!_.isArray(accountKey) && _.isObject(accountKey)) {\n    legacyOrFail = {};\n    Object.keys(accountKey).map(role => {\n      if (accountKey[role] === 'legacyKey' || accountKey[role] === 'failKey') {\n        legacyOrFail[role] = accountKey[role];\n        delete accountKey[role];\n      }\n    });\n\n    if (Object.keys(accountKey).length === 0) {\n      return new AccountForUpdate(address, legacyOrFail, options);\n    }\n  }\n\n  const publicKey = this.accountKeyToPublicKey(accountKey);\n\n  if (legacyOrFail !== undefined) {\n    Object.assign(publicKey, legacyOrFail);\n  }\n\n  return new AccountForUpdate(address, publicKey, options);\n};\n/**\n * createAccountForUpdateWithPublicKey creates AccountForUpdate instance with public key format.\n *\n * @method createAccountForUpdateWithPublicKey\n * @param {String} address The address value of AccountForUpdate, a structure that contains data for updating an account.\n * @param {String|Array|Object} keyForUpdate Public key to update.\n * @param {Object} options Options to use for setting threshold and weight for multiSig.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountForUpdateWithPublicKey = function createAccountForUpdateWithPublicKey(address, keyForUpdate, options) {\n  return new AccountForUpdate(address, keyForUpdate, options);\n};\n/**\n * createAccountForUpdateWithLegacyKey creates AccountForUpdate instance with legacyKey.\n *\n * @method createAccountForUpdateWithLegacyKey\n * @param {String} address The address of account to update with the legacy key.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountForUpdateWithLegacyKey = function createAccountForUpdateWithLegacyKey(address) {\n  return new AccountForUpdate(address, 'legacyKey');\n};\n/**\n * createAccountForUpdateWithFailKey creates AccountForUpdate instance with failKey.\n *\n * @method createAccountForUpdateWithFailKey\n * @param {String} address The address of account to update with the fail key.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountForUpdateWithFailKey = function createAccountForUpdateWithFailKey(address) {\n  return new AccountForUpdate(address, 'failKey');\n};\n/**\n * isDecoupled determines whether or not it is decoupled based on the input value.\n *\n * @method isDecoupled\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @param {String} userInputAddress The address to use when determining whether it is decoupled.\n * @return {Boolean}\n */\n\n\nAccounts.prototype.isDecoupled = function isDecoupled(key, userInputAddress) {\n  const _this$getLegacyAccoun2 = this.getLegacyAccount(key),\n        legacyAccount = _this$getLegacyAccoun2.legacyAccount,\n        klaytnWalletKeyAddress = _this$getLegacyAccoun2.klaytnWalletKeyAddress;\n\n  const actualAddress = this._determineAddress(legacyAccount, klaytnWalletKeyAddress, userInputAddress);\n\n  return legacyAccount.address.toLowerCase() !== actualAddress.toLowerCase();\n};\n/**\n * getLegacyAccount extracts the private key from the input key and returns an account with the corresponding legacy account key.\n * If the input key is KlaytnWalletKey format, it returns klaytnWalletKeyAddress, which is the address extracted from KlaytnWalletKey.\n *\n * @method getLegacyAccount\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @return {Object}\n */\n\n\nAccounts.prototype.getLegacyAccount = function getLegacyAccount(key) {\n  const parsed = utils.parsePrivateKey(key);\n\n  if (!utils.isValidPrivateKey(parsed.privateKey)) {\n    throw new Error('Invalid private key');\n  }\n\n  const privateKey = utils.addHexPrefix(parsed.privateKey);\n\n  const account = this._addAccountFunctions(Account.fromObject(AccountLib.fromPrivate(privateKey)));\n\n  return {\n    legacyAccount: account,\n    klaytnWalletKeyAddress: parsed.address\n  };\n};\n/**\n * signTransaction signs to transaction with private key.\n * If there are signatures(feePayerSignatures if the fee payer signs) in tx entered as a parameter,\n * the signatures(feePayerSignatures if the fee payer signs) are appended.\n *\n * @method signTransaction\n * @param {String|Object} tx The transaction to sign.\n * @param {String|Array} privateKey The private key to use for signing.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.signTransaction = function signTransaction() {\n  const _this = this;\n\n  let isLegacy = false;\n  let isFeePayer = false;\n  let existedSenderSignatures = [];\n  let existedFeePayerSignatures = [];\n  let result;\n  let tx;\n  let privateKey;\n  let callback;\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  try {\n    const resolved = resolveArgsForSignTransaction(arguments);\n    tx = resolved.tx;\n    privateKey = resolved.privateKey;\n    callback = resolved.callback;\n  } catch (e) {\n    return handleError(e);\n  } // If the user signs an RLP encoded transaction, tx is of type string.\n\n\n  if (_.isString(tx)) {\n    tx = decodeFromRawTransaction(tx);\n  } // Validate tx object\n\n\n  const error = helpers.validateFunction.validateParams(tx);\n  if (error) return handleError(error);\n\n  if (tx.senderRawTransaction) {\n    if (tx.feePayerSignatures) {\n      existedFeePayerSignatures = existedFeePayerSignatures.concat(tx.feePayerSignatures);\n    }\n\n    try {\n      // Decode senderRawTransaction to get signatures of fee payer\n      const _splitFeePayer = splitFeePayer(tx.senderRawTransaction),\n            senderRawTransaction = _splitFeePayer.senderRawTransaction,\n            feePayer = _splitFeePayer.feePayer,\n            feePayerSignatures = _splitFeePayer.feePayerSignatures; // feePayer !== '0x' means that in senderRawTransaction there are feePayerSignatures\n\n\n      if (feePayer !== '0x') {\n        // The feePayer inside the tx object does not match the feePayer information contained in the senderRawTransaction.\n        if (feePayer.toLowerCase() !== tx.feePayer.toLowerCase()) {\n          return handleError(\"Invalid feePayer: The fee payer(\".concat(feePayer, \") included in the transaction does not match the fee payer(\").concat(tx.feePayer, \") you want to sign.\"));\n        }\n\n        existedFeePayerSignatures = existedFeePayerSignatures.concat(feePayerSignatures);\n      }\n\n      tx.senderRawTransaction = senderRawTransaction;\n      isFeePayer = true;\n    } catch (e) {\n      return handleError(e);\n    }\n  } else {\n    isLegacy = !!(tx.type === undefined || tx.type === 'LEGACY');\n\n    if (tx.signatures) {\n      // if there is existed signatures or feePayerSignatures, those should be preserved.\n      if (isLegacy) {\n        return handleError('Legacy transaction cannot be signed with multiple keys.');\n      }\n\n      existedSenderSignatures = existedSenderSignatures.concat(tx.signatures);\n    }\n  } // When privateKey is undefined, find Account from Wallet.\n\n\n  if (privateKey === undefined) {\n    try {\n      const account = this.wallet.getAccount(isFeePayer ? tx.feePayer : tx.from);\n\n      if (!account) {\n        return handleError('Failed to find get private key to sign. The account you want to use for signing must exist in caver.klay.accounts.wallet or you must pass the private key as a parameter.');\n      }\n\n      privateKey = this._getRoleKey(tx, account);\n    } catch (e) {\n      return handleError(e);\n    }\n  }\n\n  const privateKeys = _.isArray(privateKey) ? privateKey : [privateKey];\n\n  try {\n    for (let i = 0; i < privateKeys.length; i++) {\n      const parsed = utils.parsePrivateKey(privateKeys[i]);\n      privateKeys[i] = parsed.privateKey;\n      privateKeys[i] = utils.addHexPrefix(privateKeys[i]);\n\n      if (!utils.isValidPrivateKey(privateKeys[i])) {\n        return handleError('Invalid private key');\n      }\n    }\n  } catch (e) {\n    return handleError(e);\n  } // Attempting to sign with a decoupled account into a legacy type transaction should be rejected.\n\n\n  if (isLegacy) {\n    if (privateKeys.length > 1) {\n      return handleError('Legacy transaction cannot signed with multiple keys');\n    }\n\n    if (_this.isDecoupled(privateKeys[0], tx.from)) {\n      return handleError('A legacy transaction must be with a legacy account key');\n    }\n  }\n\n  function signed(txObject) {\n    try {\n      // Guarantee all property in transaction is hex.\n      txObject = helpers.formatters.inputCallFormatter(txObject);\n      const transaction = coverInitialTxValue(txObject);\n      const rlpEncoded = encodeRLPByTxType(transaction);\n      const messageHash = Hash.keccak256(rlpEncoded);\n      const sigs = isFeePayer ? existedFeePayerSignatures : existedSenderSignatures;\n\n      for (const p of privateKeys) {\n        const signature = AccountLib.makeSigner(Nat.toNumber(transaction.chainId || '0x1') * 2 + 35)(messageHash, p);\n\n        const _AccountLib$decodeSig = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig))),\n              _AccountLib$decodeSig2 = _slicedToArray(_AccountLib$decodeSig, 3),\n              v = _AccountLib$decodeSig2[0],\n              r = _AccountLib$decodeSig2[1],\n              s = _AccountLib$decodeSig2[2];\n\n        sigs.push([v, r, s]);\n      } // makeRawTransaction will return signatures and feePayerSignatures with duplicates removed.\n\n\n      const _makeRawTransaction = makeRawTransaction(rlpEncoded, sigs, transaction),\n            rawTransaction = _makeRawTransaction.rawTransaction,\n            signatures = _makeRawTransaction.signatures,\n            feePayerSignatures = _makeRawTransaction.feePayerSignatures;\n\n      result = {\n        messageHash,\n        v: sigs[0][0],\n        r: sigs[0][1],\n        s: sigs[0][2],\n        rawTransaction,\n        txHash: Hash.keccak256(rawTransaction),\n        senderTxHash: getSenderTxHash(rawTransaction)\n      };\n\n      if (isFeePayer) {\n        result.feePayerSignatures = feePayerSignatures;\n      } else {\n        result.signatures = signatures;\n      }\n    } catch (e) {\n      callback(e);\n      return Promise.reject(e);\n    }\n\n    callback(null, result);\n    return result;\n  }\n\n  if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n    return Promise.resolve(signed(tx));\n  } // When the feePayer signs a transaction, required information is only chainId.\n\n\n  if (isFeePayer) {\n    return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId]).then(function (args) {\n      if (isNot(args[0])) {\n        throw new Error(\"\\\"chainId\\\" couldn't be fetched: \".concat(JSON.stringify(args)));\n      }\n\n      return signed(_.extend(tx, {\n        chainId: args[0]\n      }));\n    });\n  } // Otherwise, get the missing info from the Klaytn Node\n\n\n  return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId, isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce]).then(function (args) {\n    if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n      throw new Error(\"One of the values \\\"chainId\\\", \\\"gasPrice\\\", or \\\"nonce\\\" couldn't be fetched: \".concat(JSON.stringify(args)));\n    }\n\n    return signed(_.extend(tx, {\n      chainId: args[0],\n      gasPrice: args[1],\n      nonce: args[2]\n    }));\n  });\n};\n/**\n * feePayerSignTransaction calls signTransaction, creating a format for feePayer to sign the transaction.\n * If there are feePayerSignatures in tx entered as a parameter, the signatures for fee payer are appended.\n *\n * @method feePayerSignTransaction\n * @param {Object|String} tx The transaction to sign.\n * @param {String} feePayer The address of fee payer.\n * @param {String|Array} privateKey The private key to use for signing.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.feePayerSignTransaction = function feePayerSignTransaction() {\n  const _this = this;\n\n  let tx;\n  let feePayer;\n  let privateKey;\n  let callback;\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  try {\n    const resolved = resolveArgsForFeePayerSignTransaction(arguments);\n    tx = resolved.tx;\n    feePayer = resolved.feePayer;\n    privateKey = resolved.privateKey;\n    callback = resolved.callback;\n  } catch (e) {\n    return handleError(e);\n  }\n\n  if (_.isString(tx)) {\n    return this.signTransaction({\n      senderRawTransaction: tx,\n      feePayer\n    }, privateKey, callback);\n  }\n\n  if (!tx.feePayer || tx.feePayer === '0x') {\n    tx.feePayer = feePayer;\n  }\n\n  if (!tx.senderRawTransaction) {\n    if (!tx.type || !tx.type.includes('FEE_DELEGATED')) {\n      return handleError(\"Failed to sign transaction with fee payer: invalid transaction type(\".concat(tx.type ? tx.type : 'LEGACY', \")\"));\n    }\n  }\n\n  const e = helpers.validateFunction.validateParams(tx);\n\n  if (e) {\n    return handleError(e);\n  }\n\n  if (tx.feePayer.toLowerCase() !== feePayer.toLowerCase()) {\n    return handleError('Invalid parameter: The address of fee payer does not match.');\n  }\n\n  if (tx.senderRawTransaction) {\n    return this.signTransaction(tx, privateKey, callback);\n  }\n\n  return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId, isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce]).then(function (args) {\n    const chainId = args[0];\n    const gasPrice = args[1];\n    const nonce = args[2];\n\n    if (isNot(chainId) || isNot(gasPrice) || isNot(nonce)) {\n      throw new Error(\"One of the values \\\"chainId\\\", \\\"gasPrice\\\", or \\\"nonce\\\" couldn't be fetched: \".concat(JSON.stringify(args)));\n    }\n\n    let transaction = _.extend(tx, {\n      chainId,\n      gasPrice,\n      nonce\n    });\n\n    transaction = helpers.formatters.inputCallFormatter(transaction);\n    transaction = coverInitialTxValue(transaction);\n    const rlpEncoded = encodeRLPByTxType(transaction);\n    const sig = transaction.signatures ? transaction.signatures : [['0x01', '0x', '0x']];\n\n    const _makeRawTransaction2 = makeRawTransaction(rlpEncoded, sig, transaction),\n          rawTransaction = _makeRawTransaction2.rawTransaction;\n\n    return _this.signTransaction({\n      senderRawTransaction: rawTransaction,\n      feePayer,\n      chainId\n    }, privateKey, callback);\n  });\n};\n/**\n * signTransactionWithHash signs to transaction hash with private key(s).\n *\n * @method signTransactionWithHash\n * @param {String} hash The hash of transaction to sign.\n * @param {String|Array} privateKeys The private key(s) to use for signing.\n * @param {String|Number} chainId The chain id of the network.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.signTransactionWithHash = function signTransactionWithHash() {\n  const _this = this;\n\n  let hash;\n  let privateKeys;\n  let chainId;\n  let callback;\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  try {\n    const resolved = resolveArgsForSignTransactionWithHash(arguments);\n    hash = resolved.hash;\n    chainId = resolved.chainId;\n    privateKeys = resolved.privateKeys;\n    callback = resolved.callback;\n  } catch (e) {\n    return handleError(e);\n  }\n\n  privateKeys = Array.isArray(privateKeys) ? privateKeys : [privateKeys];\n\n  function signWithHash(transactionHash, prvKeys, chain, callbackFunc) {\n    const result = [];\n    chain = utils.numberToHex(chain);\n\n    try {\n      for (const privateKey of prvKeys) {\n        const p = utils.addHexPrefix(utils.parsePrivateKey(privateKey).privateKey);\n\n        if (!utils.isValidPrivateKey(p)) {\n          return handleError(\"Failed to sign transaction with hash: Invalid private key \".concat(privateKey));\n        }\n\n        const signature = AccountLib.makeSigner(Nat.toNumber(chain || '0x1') * 2 + 35)(transactionHash, p);\n\n        const _AccountLib$decodeSig3 = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig))),\n              _AccountLib$decodeSig4 = _slicedToArray(_AccountLib$decodeSig3, 3),\n              v = _AccountLib$decodeSig4[0],\n              r = _AccountLib$decodeSig4[1],\n              s = _AccountLib$decodeSig4[2];\n\n        result.push(utils.transformSignaturesToObject([v, r, s]));\n      }\n    } catch (e) {\n      callbackFunc(e);\n      return Promise.reject(e);\n    }\n\n    callbackFunc(null, result);\n    return result;\n  }\n\n  return Promise.resolve(isNot(chainId) ? _this._klaytnCall.getChainId() : chainId).then(id => {\n    return signWithHash(hash, privateKeys, id, callback);\n  });\n};\n/**\n * getRawTransactionWithSignatures returns object which contains rawTransaction.\n *\n * @method getRawTransactionWithSignatures\n * @param {Object} tx The transaction object which contains signatures or feePayerSignatures.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.getRawTransactionWithSignatures = function getRawTransactionWithSignatures(tx, callback) {\n  const _this = this;\n\n  let result;\n\n  callback = callback || function () {};\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  if (!tx || !_.isObject(tx)) {\n    return handleError('Invalid parameter: The transaction must be defined as an object');\n  }\n\n  if (!tx.signatures && !tx.feePayerSignatures) {\n    return handleError('There are no signatures or feePayerSignatures defined in the transaction object.');\n  }\n\n  const error = helpers.validateFunction.validateParams(tx);\n  if (error) return handleError(error);\n\n  if (tx.senderRawTransaction) {\n    tx.feePayerSignatures = tx.feePayerSignatures || [['0x01', '0x', '0x']];\n    const decoded = decodeFromRawTransaction(tx.senderRawTransaction); // feePayer !== '0x' means that in senderRawTransaction there are feePayerSignatures\n\n    if (decoded.feePayer !== '0x' && !utils.isEmptySig(decoded.feePayerSignatures)) {\n      if (decoded.feePayer.toLowerCase() !== tx.feePayer.toLowerCase()) {\n        return handleError('Invalid feePayer');\n      }\n\n      tx.feePayerSignatures = tx.feePayerSignatures.concat(decoded.feePayerSignatures);\n    }\n\n    decoded.feePayer = tx.feePayer;\n    decoded.feePayerSignatures = tx.feePayerSignatures;\n\n    if (tx.signatures) {\n      decoded.signatures = decoded.signatures.concat(tx.signatures);\n    }\n\n    tx = decoded;\n  }\n\n  function signed(txObject) {\n    try {\n      // Guarantee all property in transaction is hex.\n      txObject = helpers.formatters.inputCallFormatter(txObject);\n      const transaction = coverInitialTxValue(txObject);\n      const rlpEncoded = encodeRLPByTxType(transaction);\n      let sigs = transaction.signatures ? transaction.signatures : ['0x01', '0x', '0x'];\n      if (!_.isArray(sigs[0])) sigs = [sigs];\n\n      const _makeRawTransaction3 = makeRawTransaction(rlpEncoded, sigs, transaction),\n            rawTransaction = _makeRawTransaction3.rawTransaction,\n            signatures = _makeRawTransaction3.signatures,\n            feePayerSignatures = _makeRawTransaction3.feePayerSignatures;\n\n      result = {\n        rawTransaction,\n        txHash: Hash.keccak256(rawTransaction),\n        senderTxHash: getSenderTxHash(rawTransaction)\n      };\n\n      if (signatures && !utils.isEmptySig(signatures)) {\n        result.signatures = signatures;\n      }\n\n      if (feePayerSignatures && !utils.isEmptySig(feePayerSignatures)) {\n        result.feePayerSignatures = feePayerSignatures;\n      }\n    } catch (e) {\n      callback(e);\n      return Promise.reject(e);\n    }\n\n    callback(null, result);\n    return result;\n  }\n\n  if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n    return Promise.resolve(signed(tx));\n  } // Otherwise, get the missing info from the Klaytn Node\n\n\n  return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId, isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce]).then(function (args) {\n    if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n      throw new Error(\"One of the values \\\"chainId\\\", \\\"gasPrice\\\", or \\\"nonce\\\" couldn't be fetched: \".concat(JSON.stringify(args)));\n    }\n\n    return signed(_.extend(tx, {\n      chainId: args[0],\n      gasPrice: args[1],\n      nonce: args[2]\n    }));\n  });\n};\n/**\n * combineSignatures combines RLP encoded raw transaction strings.\n * combineSignatures compares transaction before combining, and if values in field are not same, this throws error.\n * The comparison allows that the address of the fee payer is '0x'(default value) for some transactions while the other transactions have a specific fee payer. This is for the use case that some transactions do not have the fee payer's information.\n * In this case, feePayer field doesn't have to be compared with other transaction.\n *\n * @method combineSignatures\n * @param {Array} rawTransactions The array of raw transaction string to combine.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.combineSignatures = function combineSignatures(rawTransactions, callback) {\n  let decodedTx;\n  let senders = [];\n  let feePayers = [];\n  let feePayer;\n\n  callback = callback || function () {};\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  if (!_.isArray(rawTransactions)) {\n    return handleError('The parameter of the combineSignatures function must be an array of RLP encoded transaction strings.');\n  }\n\n  for (const raw of rawTransactions) {\n    const _extractSignatures = extractSignatures(raw),\n          senderSignatures = _extractSignatures.senderSignatures,\n          feePayerSignatures = _extractSignatures.feePayerSignatures,\n          decodedTransaction = _extractSignatures.decodedTransaction;\n\n    senders = senders.concat(senderSignatures);\n    feePayers = feePayers.concat(feePayerSignatures);\n\n    if (decodedTx) {\n      let isSame = true;\n      const keys = Object.keys(decodedTx);\n\n      for (const key of keys) {\n        if (key === 'v' || key === 'r' || key === 's' || key === 'signatures' || key === 'payerV' || key === 'payerR' || key === 'payerS' || key === 'feePayerSignatures') {\n          continue;\n        } // feePayer field can be '0x' when after sender signs to trasnaction.\n        // For handling this, if feePayer is '0x', don't compare with other transaction\n\n\n        if (key === 'feePayer') {\n          if (decodedTransaction[key] === '0x') {\n            continue;\n          } else {\n            // set feePayer letiable with valid feePayer address(not '0x')\n            feePayer = decodedTransaction[key];\n\n            if (decodedTx[key] === '0x') {\n              // set feePayer field to decodedTx for comparing feePayer address with other transactions\n              decodedTx[key] = decodedTransaction[key];\n            }\n          }\n        }\n\n        if (decodedTransaction[key] === undefined || decodedTx[key] !== decodedTransaction[key]) {\n          isSame = false;\n          break;\n        }\n      }\n\n      if (!isSame) {\n        return handleError('Failed to combineSignatures: Signatures that sign to different transaction cannot be combined.');\n      }\n    } else {\n      decodedTx = decodedTransaction;\n    }\n  }\n\n  const parsedTxObject = decodeFromRawTransaction(rawTransactions[0]);\n  parsedTxObject.signatures = senders;\n\n  if (feePayer) {\n    parsedTxObject.feePayer = feePayer;\n\n    if (feePayers.length > 0) {\n      parsedTxObject.feePayerSignatures = feePayers;\n    }\n  }\n\n  return this.getRawTransactionWithSignatures(parsedTxObject, callback);\n};\n/**\n * cav.klay.accounts.recoverTransaction('0xf86180808401ef364594f0109fc8df283027b6285cc889f5aa624eac1f5580801ca031573280d608f75137e33fc14655f097867d691d5c4c44ebe5ae186070ac3d5ea0524410802cdc025034daefcdfa08e7d2ee3f0b9d9ae184b2001fe0aff07603d9');\n * > \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\"\n */\n\n\nAccounts.prototype.recoverTransaction = function recoverTransaction(rawTx) {\n  if (utils.getTxTypeStringFromRawTransaction(rawTx) !== undefined) {\n    throw new Error('recoverTransaction only supports transactions of type \"LEGACY\".');\n  }\n\n  const values = RLP.decode(rawTx); // If the leading zero is trimmed, it will be filled with a valid length of '0'.\n\n  const arr = values.slice(7, 9).map(sig => {\n    sig = sig.replace('0x', '');\n\n    while (sig.length < 64) {\n      sig = \"0\".concat(sig);\n    }\n\n    return \"0x\".concat(sig);\n  });\n  arr.unshift(values[6]);\n  const signature = AccountLib.encodeSignature(arr);\n  const recovery = Bytes.toNumber(values[6]);\n  const extraData = recovery < 35 ? [] : [Bytes.fromNumber(recovery - 35 >> 1), '0x', '0x'];\n  const signingData = values.slice(0, 6).concat(extraData);\n  const signingDataHex = RLP.encode(signingData);\n  return AccountLib.recover(Hash.keccak256(signingDataHex), signature);\n};\n/**\n * Hashes the given message to be passed cav.klay.accounts.recover() function.\n * The data will be UTF-8 HEX decoded and enveloped as follows:\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message and hashed using keccak256.\n *\n * cav.klay.accounts.hashMessage(\"Hello World\")\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\n * // the below results in the same hash\n * cav.klay.accounts.hashMessage(caver.utils.utf8ToHex(\"Hello World\"))\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\n */\n\n\nAccounts.prototype.hashMessage = function hashMessage(data) {\n  const message = utils.isHexStrict(data) ? utils.hexToBytes(data) : data;\n  const messageBuffer = Buffer.from(message);\n  const preamble = \"\\x19Klaytn Signed Message:\\n\".concat(message.length);\n  const preambleBuffer = Buffer.from(preamble); // klayMessage is concatenated buffer (preambleBuffer + messageBuffer)\n\n  const klayMessage = Buffer.concat([preambleBuffer, messageBuffer]); // Finally, run keccak256 on klayMessage.\n\n  return Hash.keccak256(klayMessage);\n};\n/**\n * Signs arbitrary data.\n * This data is before UTF-8 HEX decoded and enveloped as follows:\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message.\n *\n * cav.klay.accounts.sign('Some data', '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\n * > {\n *     message: 'Some data',\n *     messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\n *     v: '0x1c',\n *     r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',\n *     s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',\n *     signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'\n *   }\n */\n\n\nAccounts.prototype.sign = function sign(data, privateKey) {\n  const parsed = utils.parsePrivateKey(privateKey);\n  privateKey = parsed.privateKey;\n\n  if (!utils.isValidPrivateKey(privateKey)) {\n    throw new Error('Invalid private key');\n  }\n\n  const messageHash = this.hashMessage(data);\n  const signature = AccountLib.sign(messageHash, privateKey);\n\n  const _AccountLib$decodeSig5 = AccountLib.decodeSignature(signature),\n        _AccountLib$decodeSig6 = _slicedToArray(_AccountLib$decodeSig5, 3),\n        v = _AccountLib$decodeSig6[0],\n        r = _AccountLib$decodeSig6[1],\n        s = _AccountLib$decodeSig6[2];\n\n  return {\n    message: data,\n    messageHash,\n    v,\n    r,\n    s,\n    signature\n  };\n};\n/**\n * preFixed - Boolean (optional, default: false):\n * If the last parameter is true,\n * the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message,\n * and assumed to be already prefixed.\n */\n\n\nAccounts.prototype.recover = function recover(message, signature, preFixed) {\n  const args = [].slice.apply(arguments);\n\n  if (_.isObject(message)) {\n    return this.recover(message.messageHash, AccountLib.encodeSignature([message.v, message.r, message.s]), true);\n  }\n\n  if (!preFixed) {\n    message = this.hashMessage(message);\n  }\n\n  if (args.length >= 4) {\n    preFixed = args.slice(-1)[0];\n    preFixed = _.isBoolean(preFixed) ? !!preFixed : false;\n    return this.recover(message, AccountLib.encodeSignature(args.slice(1, 4)), preFixed); // v, r, s\n  }\n  /**\n   * recover in Account module\n   * const recover = (hash, signature) => {\n   *   const vals = decodeSignature(signature);\n   *   const vrs = { v: Bytes.toNumber(vals[0]), r: vals[1].slice(2), s: vals[2].slice(2) };\n   *   const ecPublicKey = secp256k1.recoverPubKey(Buffer.from(hash.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n   *   const publicKey = \"0x\" + ecPublicKey.encode('hex', false).slice(2);\n   *   const publicHash = keccak256(publicKey);\n   *   const address = toChecksum(\"0x\" + publicHash.slice(-40));\n   *   return address;\n   * };\n   */\n\n\n  return AccountLib.recover(message, signature);\n}; // Taken from https://github.com/ethereumjs/ethereumjs-wallet\n\n\nAccounts.prototype.decrypt = function (v3Keystore, password, nonStrict) {\n  if (!_.isString(password)) {\n    throw new Error('No password given.');\n  }\n\n  const json = _.isObject(v3Keystore) ? v3Keystore : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore);\n\n  if (json.version !== 3 && json.version !== 4) {\n    console.warn('This is not a V3 or V4 wallet.'); // throw new Error('Not a valid V3 wallet');\n  }\n\n  if (json.version === 3 && !json.crypto) {\n    // crypto field should be existed in keystore version 3\n    throw new Error(\"Invalid keystore V3 format: 'crypto' is not defined.\");\n  }\n\n  if (json.crypto) {\n    if (json.keyring) {\n      throw new Error(\"Invalid key store format: 'crypto' can not be with 'keyring'\");\n    }\n\n    json.keyring = [json.crypto];\n    delete json.crypto;\n  }\n\n  if (_.isArray(json.keyring[0]) && json.keyring.length > 3) {\n    throw new Error('Invalid key store format');\n  }\n\n  let accountKey = {}; // AccountKeyRoleBased format\n\n  if (_.isArray(json.keyring[0])) {\n    const transactionKey = decryptKey(json.keyring[0]);\n    if (transactionKey) accountKey.transactionKey = transactionKey;\n    const updateKey = decryptKey(json.keyring[1]);\n    if (updateKey) accountKey.updateKey = updateKey;\n    const feePayerKey = decryptKey(json.keyring[2]);\n    if (feePayerKey) accountKey.feePayerKey = feePayerKey;\n  } else {\n    accountKey = decryptKey(json.keyring);\n  }\n\n  function decryptKey(encryptedArray) {\n    if (!encryptedArray || encryptedArray.length === 0) return undefined;\n    const decryptedArray = [];\n\n    for (const encrypted of encryptedArray) {\n      let derivedKey;\n      let kdfparams;\n      /**\n       * Supported kdf modules are the following:\n       * 1) pbkdf2\n       * 2) scrypt\n       */\n\n      if (encrypted.kdf === 'scrypt') {\n        kdfparams = encrypted.kdfparams; // FIXME: support progress reporting callback\n\n        derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n      } else if (encrypted.kdf === 'pbkdf2') {\n        kdfparams = encrypted.kdfparams;\n\n        if (kdfparams.prf !== 'hmac-sha256') {\n          throw new Error('Unsupported parameters to PBKDF2');\n        }\n\n        derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n      } else {\n        throw new Error('Unsupported key derivation scheme');\n      }\n\n      const ciphertext = Buffer.from(encrypted.ciphertext, 'hex');\n      const mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '');\n\n      if (mac !== encrypted.mac) {\n        throw new Error('Key derivation failed - possibly wrong password');\n      }\n\n      const decipher = cryp.createDecipheriv(encrypted.cipher, derivedKey.slice(0, 16), Buffer.from(encrypted.cipherparams.iv, 'hex'));\n      decryptedArray.push(\"0x\".concat(Buffer.from([...decipher.update(ciphertext), ...decipher.final()]).toString('hex')));\n    }\n\n    return decryptedArray.length === 1 ? decryptedArray[0] : decryptedArray;\n  }\n\n  return this.createWithAccountKey(json.address, accountKey);\n};\n/*\n    The fields of kdfparams are described below.\n\n    `dklen` is the desired length of the derived key\n    `salt` - A string of characters that modifies the hash to protect against Rainbow table attacks\n    `n` - CPU/memory cost parameter\n    `r` - The blocksize parameter, which fine-tunes sequential memory read size and performance. 8 is commonly used.\n    `p` - Parallelization parameter\n    `c` - the number of iterations desired\n */\n\n/**\n * encrypt encrypts an account and returns a key store v4 object.\n *\n * @method encrypt\n * @param {String} key The key parameter can be a raw key format(private key string, KlaytnWalletKey, array of private keys or object with keys by roles) or an instance of Account or AccountKey.\n * @param {String} password The password to be used for account encryption. The encrypted key store can be decrypted with this password.\n * @param {Object} options The options to use when encrypt an account.\n * @return {Object}\n */\n\n\nAccounts.prototype.encrypt = function (key, password, options) {\n  /**\n   * options can include below\n   * {\n   *   salt: ...,\n   *   iv: ...,\n   *   kdf: ...,\n   *   dklen: ...,\n   *   c: ...,\n   *   n: ...,\n   *   r: ...,\n   *   p: ...,\n   *   cipher: ...,\n   *   uuid: ...,\n   *   cipher: ...,\n   * }\n   */\n  options = options || {};\n  let address;\n  let account;\n\n  if (key instanceof Account) {\n    if (options.address && options.address !== key.address) {\n      throw new Error('Address in account is not matched with address in options object');\n    }\n\n    address = key.address;\n    account = key;\n  } else if (_.isString(key)) {\n    account = this.privateKeyToAccount(key, options.address);\n    address = account.address;\n  } else {\n    if (!options.address) {\n      throw new Error('The address must be defined inside the options object.');\n    }\n\n    address = options.address;\n  }\n\n  if (!account) account = this.createWithAccountKey(address, key);\n  let keyring;\n  let transactionKey;\n  let updateKey;\n  let feePayerKey;\n\n  switch (account.accountKeyType) {\n    case AccountKeyEnum.ACCOUNT_KEY_PUBLIC:\n    case AccountKeyEnum.ACCOUNT_KEY_MULTISIG:\n      keyring = encryptKey(account.keys, password, options);\n      break;\n\n    case AccountKeyEnum.ACCOUNT_KEY_ROLEBASED:\n      keyring = [];\n      transactionKey = encryptKey(account.transactionKey, password, options);\n      updateKey = encryptKey(account.updateKey, password, options);\n      feePayerKey = encryptKey(account.feePayerKey, password, options);\n      keyring.push(transactionKey);\n      keyring.push(updateKey);\n      keyring.push(feePayerKey);\n\n      for (let i = keyring.length - 1; i >= 0; i--) {\n        if (keyring[i].length !== 0) break;\n        keyring = keyring.slice(0, i);\n      }\n\n      break;\n\n    default:\n      throw new Error(\"Unsupported account key type: \".concat(account.accountKeyType));\n  }\n\n  return {\n    version: 4,\n    id: uuid.v4({\n      random: options.uuid || cryp.randomBytes(16)\n    }),\n    address: account.address.toLowerCase(),\n    keyring\n  };\n};\n/**\n * encryptV3 encrypts an account and returns a key store v3 object.\n *\n * @method encryptV3\n * @param {String} key The key parameter can be a normal private key(KlaytnWalletKey format also supported) or an instance of Account or AccountKeyPublic.\n * @param {String} password The password to be used for account encryption. The encrypted key store can be decrypted with this password.\n * @param {Object} options The options to use when encrypt an account.\n * @return {Object}\n */\n\n\nAccounts.prototype.encryptV3 = function (key, password, options) {\n  options = options || {};\n  let address;\n  let account;\n  const notSupportedType = 'Invalid parameter: encryptV3 only supports a single private key (also supports KlantnWalletKey format), or an instance of Account or AccountKeyPublic as a parameter. If you want to encrypt multiple keys, use caver.klay.accounts.encrypt which encrypts to keystore v4.';\n\n  if (key instanceof Account) {\n    if (options.address && options.address !== key.address) {\n      throw new Error('Address in account is not matched with address in options object');\n    }\n\n    if (key.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) throw new Error(notSupportedType);\n    address = key.address;\n    account = key;\n  } else if (_.isString(key)) {\n    account = this.privateKeyToAccount(key, options.address);\n    address = account.address;\n  } else if (Account.isAccountKey(key)) {\n    if (key.type !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) throw new Error(notSupportedType);\n\n    if (!options.address) {\n      throw new Error('The address must be defined inside the options object.');\n    }\n\n    address = options.address;\n  } else {\n    throw new Error(notSupportedType);\n  }\n\n  if (!account) account = this.createWithAccountKey(address, key);\n  const crypto = encryptKey(account.keys, password, options);\n  return {\n    version: 3,\n    id: uuid.v4({\n      random: options.uuid || cryp.randomBytes(16)\n    }),\n    address: account.address.toLowerCase(),\n    crypto: crypto[0]\n  };\n};\n\nAccounts.prototype.privateKeyToPublicKey = function (privateKey, compressed = false) {\n  const parsed = utils.parsePrivateKey(privateKey);\n  privateKey = parsed.privateKey;\n  privateKey = privateKey.slice(0, 2) === '0x' ? privateKey.slice(2) : privateKey;\n\n  if (privateKey.length !== 64) {\n    throw new Error('Received a invalid privateKey. The length of privateKey should be 64.');\n  }\n\n  const buffer = Buffer.from(privateKey, 'hex');\n  const ecKey = secp256k1.keyFromPrivate(buffer);\n  let publicKey;\n\n  if (!compressed) {\n    publicKey = \"0x\".concat(ecKey.getPublic(false, 'hex').slice(2));\n  } else {\n    publicKey = \"0x\".concat(ecKey.getPublic(true, 'hex'));\n  }\n\n  return publicKey;\n};\n\nAccounts.prototype.encodeRLPByTxType = encodeRLPByTxType;\n\nAccounts.prototype.setAccounts = function (accounts) {\n  this.wallet.clear();\n\n  for (let i = 0; i < accounts.wallet.length; i++) {\n    this.wallet.add(accounts.wallet[i]);\n  }\n\n  return this;\n};\n/* eslint-enable complexity */\n// Note: this is trying to follow closely the specs on\n\n/**\n  > Wallet {\n      0: {...}, // account by index\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},  // same account by address\n      \"0xf0109fc8df283027b6285cc889f5aa624eac1f55\": {...},  // same account by address lowercase\n      1: {...},\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...},\n      \"0xd0122fc8df283027b6285cc889f5aa624eac1d23\": {...},\n\n      add: function(){},\n      remove: function(){},\n      save: function(){},\n      load: function(){},\n      clear: function(){},\n\n      length: 2,\n  }\n *\n * Contains an in memory wallet with multiple accounts.\n * These accounts can be used when using cav.klay.sendTransaction().\n */\n\n\nfunction Wallet(accounts) {\n  this._accounts = accounts;\n  this.length = 0;\n  this.defaultKeyName = 'caverjs_wallet';\n}\n\nWallet.prototype._findSafeIndex = function (pointer) {\n  pointer = pointer || 0;\n\n  if (_.has(this, pointer)) {\n    return this._findSafeIndex(pointer + 1);\n  }\n\n  return pointer;\n};\n\nWallet.prototype._currentIndexes = function () {\n  const keys = Object.keys(this);\n  const indexes = keys.map(function (key) {\n    return parseInt(key);\n  }).filter(function (n) {\n    return n < 9e20;\n  });\n  return indexes;\n};\n\nWallet.prototype.create = function (numberOfAccounts, entropy) {\n  for (let i = 0; i < numberOfAccounts; ++i) {\n    this.add(this._accounts.create(entropy).privateKey);\n  }\n\n  return this;\n};\n/**\n * Adds an account using a private key or account object to the wallet.\n *\n * cav.klay.accounts.wallet.add({\n    privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n    address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\n    });\n    > {\n        index: 0,\n        address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\n        privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n        signTransaction: function(tx){...},\n        sign: function(data){...},\n        encrypt: function(password){...}\n    }\n */\n\n\nWallet.prototype.add = function (account, userInputAddress) {\n  let accountForWallet;\n  /**\n   * cav.klay.accounts.wallet.add('0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\n   *\n   * cav.klay.accounts.wallet.add({\n   *   privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n   *   address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\n   * });\n   */\n\n  if (Account.isAccountKey(account)) {\n    if (!userInputAddress) {\n      throw new Error('Address is not defined. Address cannot be determined from AccountKey');\n    }\n\n    accountForWallet = this._accounts.createWithAccountKey(userInputAddress, account);\n  } else if (account instanceof Account) {\n    accountForWallet = this._accounts.createWithAccountKey(account.address, account.accountKey);\n    accountForWallet.address = userInputAddress || account.address;\n  } else if (_.isObject(account) && account.address && account.privateKey) {\n    accountForWallet = this._accounts.privateKeyToAccount(account.privateKey, userInputAddress || account.address);\n  } else if (_.isString(account)) {\n    accountForWallet = this._accounts.privateKeyToAccount(account, userInputAddress);\n  } else {\n    const accountKey = this._accounts.createAccountKey(account);\n\n    if (!userInputAddress) {\n      throw new Error('Address is not defined. Address cannot be determined from AccountKey format');\n    }\n\n    accountForWallet = this._accounts.createWithAccountKey(userInputAddress, accountKey);\n  }\n\n  if (this[accountForWallet.address]) {\n    throw new Error(\"Account exists with \".concat(accountForWallet.address));\n  }\n\n  accountForWallet.index = this._findSafeIndex();\n  this[accountForWallet.index] = accountForWallet;\n  this[accountForWallet.address] = accountForWallet;\n  this[accountForWallet.address.toLowerCase()] = accountForWallet;\n  this[accountForWallet.address.toUpperCase()] = accountForWallet;\n\n  try {\n    this[utils.toChecksumAddress(accountForWallet.address)] = accountForWallet;\n  } catch (e) {}\n\n  this.length++;\n  return accountForWallet;\n};\n\nWallet.prototype.updatePrivateKey = function (privateKey, address) {\n  if (privateKey === undefined || address === undefined) {\n    throw new Error('To update the privatKey in wallet, need to set both privateKey and address.');\n  } // If privateKey parameter is not string type, return error\n\n\n  if (!_.isString(privateKey)) {\n    throw new Error('The private key used for the update is not a valid string.');\n  }\n\n  if (!utils.isAddress(address)) {\n    throw new Error(\"Invalid address : \".concat(address));\n  } // If failed to find account through address, return error\n\n\n  const accountExists = !!this[address];\n  if (!accountExists) throw new Error(\"Failed to find account with \".concat(address));\n  const account = this[address];\n\n  if (account.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n    throw new Error('Account using AccountKeyMultiSig or AccountKeyRoleBased must be updated using the caver.klay.accounts.updateAccountKey function.');\n  }\n\n  const parsed = utils.parsePrivateKey(privateKey);\n\n  if (!utils.isValidPrivateKey(parsed.privateKey)) {\n    throw new Error('Invalid private key');\n  }\n\n  if (parsed.address && parsed.address !== account.address) {\n    throw new Error('The address extracted from the private key does not match the address received as the input value.');\n  }\n\n  const newAccountKeyPublic = new AccountKeyPublic(parsed.privateKey);\n  this[account.index].accountKey = newAccountKeyPublic;\n  this[account.address].accountKey = newAccountKeyPublic;\n  this[account.address.toLowerCase()].accountKey = newAccountKeyPublic;\n  this[account.address.toUpperCase()].accountKey = newAccountKeyPublic;\n\n  try {\n    this[utils.toChecksumAddress(account.address)].accountKey = newAccountKeyPublic;\n  } catch (e) {}\n\n  return account;\n};\n\nWallet.prototype.updateAccountKey = function updateAccountKey(address, accountKey) {\n  if (address === undefined || accountKey === undefined) {\n    throw new Error('To update the accountKey in wallet, need to set both address and accountKey.');\n  }\n\n  if (!Account.isAccountKey(accountKey)) {\n    accountKey = this._accounts.createAccountKey(accountKey);\n  }\n\n  if (!utils.isAddress(address)) {\n    throw new Error(\"Invalid address : \".concat(address));\n  } // If failed to find account through address, return error\n\n\n  const accountExists = !!this[address];\n  if (!accountExists) throw new Error(\"Failed to find account with \".concat(address));\n  const account = this[address];\n  this[account.index].accountKey = accountKey;\n  this[account.address].accountKey = accountKey;\n  this[account.address.toLowerCase()].accountKey = accountKey;\n  this[account.address.toUpperCase()].accountKey = accountKey;\n\n  try {\n    this[utils.toChecksumAddress(account.address)].accountKey = accountKey;\n  } catch (e) {}\n\n  return account;\n};\n\nWallet.prototype.remove = function (addressOrIndex) {\n  const account = this[addressOrIndex];\n\n  if (account && account.address) {\n    // address\n    this[account.address].accountKey = null;\n    delete this[account.address];\n\n    if (this[account.address.toLowerCase()]) {\n      // address lowercase\n      this[account.address.toLowerCase()].accountKey = null;\n      delete this[account.address.toLowerCase()];\n    }\n\n    if (this[account.address.toUpperCase()]) {\n      // address uppercase\n      this[account.address.toUpperCase()].accountKey = null;\n      delete this[account.address.toUpperCase()];\n    }\n\n    try {\n      this[utils.toChecksumAddress(account.address)].accountKey = null;\n      delete this[utils.toChecksumAddress(account.address)];\n    } catch (e) {} // index\n\n\n    this[account.index].accountKey = null;\n    delete this[account.index];\n    this.length--;\n    return true;\n  }\n\n  return false;\n};\n\nWallet.prototype.clear = function () {\n  const _this = this;\n\n  const indexes = this._currentIndexes();\n\n  indexes.forEach(function (index) {\n    _this.remove(index);\n  });\n  return this;\n};\n/**\n * cav.klay.accounts.wallet.encrypt('test');\n    > [ { version: 3,\n        id: 'dcf8ab05-a314-4e37-b972-bf9b86f91372',\n        address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\n        crypto:\n         { ciphertext: '0de804dc63940820f6b3334e5a4bfc8214e27fb30bb7e9b7b74b25cd7eb5c604',\n           cipherparams: [Object],\n           cipher: 'aes-128-ctr',\n           kdf: 'scrypt',\n           kdfparams: [Object],\n           mac: 'b2aac1485bd6ee1928665642bf8eae9ddfbc039c3a673658933d320bac6952e3' } },\n      { version: 3,\n        id: '9e1c7d24-b919-4428-b10e-0f3ef79f7cf0',\n        address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\n        crypto:\n         { ciphertext: 'd705ebed2a136d9e4db7e5ae70ed1f69d6a57370d5fbe06281eb07615f404410',\n           cipherparams: [Object],\n           cipher: 'aes-128-ctr',\n           kdf: 'scrypt',\n           kdfparams: [Object],\n           mac: 'af9eca5eb01b0f70e909f824f0e7cdb90c350a802f04a9f6afe056602b92272b' } }\n    ]\n */\n\n\nWallet.prototype.encrypt = function (password, options) {\n  const _this = this;\n\n  const indexes = this._currentIndexes();\n\n  const accounts = indexes.map(function (index) {\n    return _this[index].encrypt(password, options);\n  });\n  return accounts;\n};\n/**\n * cav.klay.accounts.wallet.decrypt([\n    { version: 3,\n    id: '83191a81-aaca-451f-b63d-0c5f3b849289',\n    address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\n    crypto:\n     { ciphertext: '7d34deae112841fba86e3e6cf08f5398dda323a8e4d29332621534e2c4069e8d',\n       cipherparams: { iv: '497f4d26997a84d570778eae874b2333' },\n       cipher: 'aes-128-ctr',\n       kdf: 'scrypt',\n       kdfparams:\n        { dklen: 32,\n          salt: '208dd732a27aa4803bb760228dff18515d5313fd085bbce60594a3919ae2d88d',\n          n: 262144,\n          r: 8,\n          p: 1 },\n       mac: '0062a853de302513c57bfe3108ab493733034bf3cb313326f42cf26ea2619cf9' } },\n     { version: 3,\n    id: '7d6b91fa-3611-407b-b16b-396efb28f97e',\n    address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\n    crypto:\n     { ciphertext: 'cb9712d1982ff89f571fa5dbef447f14b7e5f142232bd2a913aac833730eeb43',\n       cipherparams: { iv: '8cccb91cb84e435437f7282ec2ffd2db' },\n       cipher: 'aes-128-ctr',\n       kdf: 'scrypt',\n       kdfparams:\n        { dklen: 32,\n          salt: '08ba6736363c5586434cd5b895e6fe41ea7db4785bd9b901dedce77a1514e8b8',\n          n: 262144,\n          r: 8,\n          p: 1 },\n       mac: 'd2eb068b37e2df55f56fa97a2bf4f55e072bef0dd703bfd917717d9dc54510f0' } }\n  ], 'test');\n  > Wallet {\n      0: {...},\n      1: {...},\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\n      ...\n  }\n */\n\n\nWallet.prototype.decrypt = function (encryptedWallet, password) {\n  const _this = this;\n\n  encryptedWallet.forEach(function (keystore) {\n    const account = _this._accounts.decrypt(keystore, password);\n\n    if (!account) {\n      throw new Error(\"Couldn't decrypt the keystore. Maybe wrong password?\");\n    }\n\n    const exist = !!_this[account.address];\n\n    if (!exist) {\n      _this.add(account);\n    }\n  });\n  return this;\n};\n\nWallet.prototype.save = function (password, keyName) {\n  /* eslint-disable-next-line no-undef */\n  localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encrypt(password)));\n  return true;\n};\n/**\n * cav.klay.accounts.wallet.load('test#!$', 'myWalletKey' || 'web3js_wallet');\n    > Wallet {\n        0: {...},\n        1: {...},\n        \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\n        \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\n        ...\n    }\n */\n\n\nWallet.prototype.load = function (password, keyName) {\n  /* eslint-disable-next-line no-undef */\n  let keystore = localStorage.getItem(keyName || this.defaultKeyName);\n\n  if (keystore) {\n    try {\n      keystore = JSON.parse(keystore);\n    } catch (e) {}\n  }\n\n  return this.decrypt(keystore || [], password);\n};\n\nif (typeof localStorage === 'undefined') {\n  delete Wallet.prototype.save;\n  delete Wallet.prototype.load;\n}\n\nWallet.prototype.getKlaytnWalletKey = function (addressOrIndex) {\n  const account = this[addressOrIndex];\n  if (!account) throw new Error('Failed to find account');\n  return genKlaytnWalletKeyStringFromAccount(account);\n};\n\nWallet.prototype.getAccount = function (input) {\n  if (_.isNumber(input)) {\n    if (this.length <= input) {\n      throw new Error(\"The index(\".concat(input, \") is out of range(Wallet length : \").concat(this.length, \").\"));\n    }\n\n    return this[input];\n  }\n\n  if (!_.isString(input)) {\n    throw new Error(\"Accounts in the Wallet can be searched by only index or address. :\".concat(input));\n  }\n\n  if (!utils.isAddress(input)) {\n    throw new Error(\"Failed to getAccount from Wallet: invalid address(\".concat(input, \")\"));\n  }\n\n  return this[input.toLowerCase()];\n};\n\nfunction genKlaytnWalletKeyStringFromAccount(account) {\n  if (account.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n    throw new Error('The account cannot be exported in KlaytnWalletKey format. Use caver.klay.accounts.encrypt or account.encrypt.');\n  }\n\n  let addressString = account.address;\n  let privateKey = account.privateKey;\n  privateKey = privateKey.slice(0, 2) === '0x' ? privateKey : \"0x\".concat(privateKey);\n  addressString = addressString.slice(0, 2) === '0x' ? addressString : \"0x\".concat(addressString);\n  return \"\".concat(privateKey, \"0x00\").concat(addressString);\n}\n\nmodule.exports = Accounts;","map":null,"metadata":{},"sourceType":"script"}