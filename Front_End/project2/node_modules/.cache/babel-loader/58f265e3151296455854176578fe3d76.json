{"ast":null,"code":"var _slicedToArray = require(\"/Users/heeje/Desktop/Projcet_A/Front_End/react-dapp/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar RLP = require(\"eth-lib/lib/rlp\");\n\nvar Bytes = require(\"eth-lib/lib/bytes\");\n\nvar utils = require('../../../../caver-utils');\n\nvar helpers = require('../../../../caver-core-helpers');\n\nconst _helpers$constants = helpers.constants,\n      ACCOUNT_CREATION_TYPE_TAG = _helpers$constants.ACCOUNT_CREATION_TYPE_TAG,\n      ACCOUNT_UPDATE_TYPE_TAG = _helpers$constants.ACCOUNT_UPDATE_TYPE_TAG,\n      ACCOUNT_KEY_NIL_TAG = _helpers$constants.ACCOUNT_KEY_NIL_TAG,\n      ACCOUNT_KEY_LEGACY_TAG = _helpers$constants.ACCOUNT_KEY_LEGACY_TAG,\n      ACCOUNT_KEY_PUBLIC_TAG = _helpers$constants.ACCOUNT_KEY_PUBLIC_TAG,\n      ACCOUNT_KEY_FAIL_TAG = _helpers$constants.ACCOUNT_KEY_FAIL_TAG,\n      ACCOUNT_KEY_WEIGHTED_MULTISIG_TAG = _helpers$constants.ACCOUNT_KEY_WEIGHTED_MULTISIG_TAG,\n      ACCOUNT_KEY_ROLE_BASED_TAG = _helpers$constants.ACCOUNT_KEY_ROLE_BASED_TAG,\n      FEE_DELEGATED_VALUE_TRANSFER_WITH_RATIO_TYPE_TAG = _helpers$constants.FEE_DELEGATED_VALUE_TRANSFER_WITH_RATIO_TYPE_TAG,\n      FEE_DELEGATED_ACCOUNT_UPDATE_TYPE_TAG = _helpers$constants.FEE_DELEGATED_ACCOUNT_UPDATE_TYPE_TAG,\n      FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO_TYPE_TAG = _helpers$constants.FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO_TYPE_TAG;\n\nfunction rlpEncodeForAccountCreation(transaction) {\n  let accountKey = resolveRawKeyToAccountKey(transaction);\n  return RLP.encode([RLP.encode([ACCOUNT_CREATION_TYPE_TAG, Bytes.fromNat(transaction.nonce), Bytes.fromNat(transaction.gasPrice), Bytes.fromNat(transaction.gas), transaction.to.toLowerCase(), Bytes.fromNat(transaction.value), transaction.from.toLowerCase(), Bytes.fromNat(transaction.humanReadable === true ? '0x1' : '0x0'), accountKey]), Bytes.fromNat(transaction.chainId || \"0x1\"), \"0x\", \"0x\"]);\n}\n\nfunction rlpEncodeForAccountUpdate(transaction) {\n  let accountKey = resolveRawKeyToAccountKey(transaction);\n  return RLP.encode([RLP.encode([ACCOUNT_UPDATE_TYPE_TAG, Bytes.fromNat(transaction.nonce), Bytes.fromNat(transaction.gasPrice), Bytes.fromNat(transaction.gas), transaction.from.toLowerCase(), accountKey]), Bytes.fromNat(transaction.chainId || \"0x1\"), \"0x\", \"0x\"]);\n}\n\nfunction rlpEncodeForFeeDelegatedAccountUpdate(transaction) {\n  if (transaction.feePayer) {\n    const typeDetacehdRawTransaction = '0x' + transaction.senderRawTransaction.slice(4);\n\n    const _utils$rlpDecode = utils.rlpDecode(typeDetacehdRawTransaction),\n          _utils$rlpDecode2 = _slicedToArray(_utils$rlpDecode, 6),\n          nonce = _utils$rlpDecode2[0],\n          gasPrice = _utils$rlpDecode2[1],\n          gas = _utils$rlpDecode2[2],\n          from = _utils$rlpDecode2[3],\n          accountKey = _utils$rlpDecode2[4],\n          _utils$rlpDecode2$ = _slicedToArray(_utils$rlpDecode2[5], 1),\n          _utils$rlpDecode2$$ = _slicedToArray(_utils$rlpDecode2$[0], 3),\n          v = _utils$rlpDecode2$$[0],\n          r = _utils$rlpDecode2$$[1],\n          s = _utils$rlpDecode2$$[2];\n\n    return RLP.encode([RLP.encode([FEE_DELEGATED_ACCOUNT_UPDATE_TYPE_TAG, Bytes.fromNat(nonce), Bytes.fromNat(gasPrice), Bytes.fromNat(gas), from.toLowerCase(), accountKey]), transaction.feePayer.toLowerCase(), Bytes.fromNat(transaction.chainId || \"0x1\"), \"0x\", \"0x\"]);\n  } else {\n    let accountKey = resolveRawKeyToAccountKey(transaction);\n    return RLP.encode([RLP.encode([FEE_DELEGATED_ACCOUNT_UPDATE_TYPE_TAG, Bytes.fromNat(transaction.nonce), Bytes.fromNat(transaction.gasPrice), Bytes.fromNat(transaction.gas), transaction.from.toLowerCase(), accountKey]), Bytes.fromNat(transaction.chainId || \"0x1\"), \"0x\", \"0x\"]);\n  }\n}\n\nfunction rlpEncodeForFeeDelegatedAccountUpdateWithRatio(transaction) {\n  if (transaction.feePayer) {\n    const typeDetacehdRawTransaction = '0x' + transaction.senderRawTransaction.slice(4);\n\n    const _utils$rlpDecode3 = utils.rlpDecode(typeDetacehdRawTransaction),\n          _utils$rlpDecode4 = _slicedToArray(_utils$rlpDecode3, 7),\n          nonce = _utils$rlpDecode4[0],\n          gasPrice = _utils$rlpDecode4[1],\n          gas = _utils$rlpDecode4[2],\n          from = _utils$rlpDecode4[3],\n          accountKey = _utils$rlpDecode4[4],\n          feeRatio = _utils$rlpDecode4[5],\n          _utils$rlpDecode4$ = _slicedToArray(_utils$rlpDecode4[6], 1),\n          _utils$rlpDecode4$$ = _slicedToArray(_utils$rlpDecode4$[0], 3),\n          v = _utils$rlpDecode4$$[0],\n          r = _utils$rlpDecode4$$[1],\n          s = _utils$rlpDecode4$$[2];\n\n    return RLP.encode([RLP.encode([FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO_TYPE_TAG, Bytes.fromNat(nonce), Bytes.fromNat(gasPrice), Bytes.fromNat(gas), from.toLowerCase(), accountKey, Bytes.fromNat(feeRatio)]), transaction.feePayer.toLowerCase(), Bytes.fromNat(transaction.chainId || \"0x1\"), \"0x\", \"0x\"]);\n  } else {\n    let accountKey = resolveRawKeyToAccountKey(transaction);\n    return RLP.encode([RLP.encode([FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO_TYPE_TAG, Bytes.fromNat(transaction.nonce), Bytes.fromNat(transaction.gasPrice), Bytes.fromNat(transaction.gas), transaction.from.toLowerCase(), accountKey, Bytes.fromNat(transaction.feeRatio)]), Bytes.fromNat(transaction.chainId || \"0x1\"), \"0x\", \"0x\"]);\n  }\n}\n\nfunction resolveRawKeyToAccountKey(transaction) {\n  if (transaction.multisig) {\n    const _transaction$multisig = transaction.multisig,\n          threshold = _transaction$multisig.threshold,\n          keys = _transaction$multisig.keys;\n    const encodedMultisigPublicKeys = keys.map(({\n      weight,\n      publicKey\n    }) => {\n      if (!weight) throw new Error('weight should be specified for multisig account');\n      if (!publicKey) throw new Error('publicKey should be specified for multisig account');\n      const xyPoints = utils.xyPointFromPublicKey(publicKey);\n\n      if (xyPoints !== undefined && xyPoints.length) {\n        // ACCOUNT_KEY_PUBLIC_TAG\n        const _xyPoints = _slicedToArray(xyPoints, 2),\n              pubX = _xyPoints[0],\n              pubY = _xyPoints[1];\n\n        return [Bytes.fromNat(utils.numberToHex(weight)), [pubX, pubY]];\n      } else {\n        throw new Error('invalid multisig public key');\n      }\n    });\n    return ACCOUNT_KEY_WEIGHTED_MULTISIG_TAG + RLP.encode([Bytes.fromNat(utils.numberToHex(threshold)), encodedMultisigPublicKeys]).slice(2);\n  }\n\n  if (transaction.failKey && transaction.publicKey) throw new Error('Ambiguous Account Key Type, `failKey` and `publicKey` cannot be used simultaneously');\n  if (!!transaction.failKey) return ACCOUNT_KEY_FAIL_TAG;\n\n  if (transaction.publicKey) {\n    const xyPoints = utils.xyPointFromPublicKey(transaction.publicKey); // 1. Check Account key type\n\n    if (xyPoints !== undefined && xyPoints.length) {\n      // ACCOUNT_KEY_PUBLIC_TAG\n      const _xyPoints2 = _slicedToArray(xyPoints, 2),\n            pubX = _xyPoints2[0],\n            pubY = _xyPoints2[1];\n\n      return ACCOUNT_KEY_PUBLIC_TAG + RLP.encode([pubX, pubY]).slice(2);\n    } else {\n      throw new Error('invalid public key');\n    }\n  } // Account Creation인 경우에는 RoleBaseKey에 Account Key Nil 넣으면 안됨. \n\n\n  if (transaction.roleTransactionKey || transaction.roleAccountUpdateKey || transaction.roleFeePayerKey) {\n    transaction.roleTransactionKey = transaction.roleTransactionKey ? resolveRawKeyToAccountKey(transaction.roleTransactionKey) : ACCOUNT_KEY_NIL_TAG;\n    transaction.roleAccountUpdateKey = transaction.roleAccountUpdateKey ? resolveRawKeyToAccountKey(transaction.roleAccountUpdateKey) : ACCOUNT_KEY_NIL_TAG;\n    transaction.roleFeePayerKey = transaction.roleFeePayerKey ? resolveRawKeyToAccountKey(transaction.roleFeePayerKey) : ACCOUNT_KEY_NIL_TAG;\n    return ACCOUNT_KEY_ROLE_BASED_TAG + RLP.encode([transaction.roleTransactionKey, transaction.roleAccountUpdateKey, transaction.roleFeePayerKey]).slice(2);\n  }\n\n  return ACCOUNT_KEY_NIL_TAG;\n}\n\nmodule.exports = {\n  rlpEncodeForAccountCreation,\n  rlpEncodeForAccountUpdate,\n  rlpEncodeForFeeDelegatedAccountUpdate,\n  rlpEncodeForFeeDelegatedAccountUpdateWithRatio\n};","map":null,"metadata":{},"sourceType":"script"}