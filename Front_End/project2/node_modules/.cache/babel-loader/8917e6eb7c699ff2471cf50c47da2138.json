{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar _ = require('underscore');\n\nvar core = require('../../../caver-core');\n\nvar Method = require('../../../caver-core-method');\n\nvar utils = require('../../../caver-utils');\n\nvar Subscription = require('../../../caver-core-subscriptions').subscription;\n\nvar formatters = require('../../../caver-core-helpers').formatters;\n\nvar errors = require('../../../caver-core-helpers').errors;\n\nvar abi = require('../../caver-klay-abi');\n/**\n * Should be called to create new contract instance\n *\n * @method Contract\n * @constructor\n * @param {Array} jsonInterface\n * @param {String} address\n * @param {Object} options\n */\n\n/**\n * 사용 예)\n * var myContract = new cav.klay.Contract([...], '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe', {\n *   from: '0x1234567890123456789012345678901234567891', // default from address\n *   gasPrice: '20000000000', // default gas price in wei, 20 gwei in this case\n *   data: '',(bytecode, 디플로이할 때.)\n *   gas: 200000, (가스 리밋)\n * });\n */\n\n\nvar Contract = function Contract(jsonInterface, address, options) {\n  var _this = this,\n      args = Array.prototype.slice.call(arguments);\n\n  if (!(this instanceof Contract)) {\n    throw new Error('Please use the \"new\" keyword to instantiate a cav.klay.contract() object!');\n  } // sets _requestmanager\n\n\n  core.packageInit(this, [this.constructor.currentProvider]);\n  this.clearSubscriptions = this._requestManager.clearSubscriptions;\n\n  if (!jsonInterface || !Array.isArray(jsonInterface)) {\n    throw new Error('You must provide the json interface of the contract when instantiating a contract object.');\n  } // create the options object\n\n\n  this.options = {}; // For Object.defineProperty setter / getter\n\n  let _from, _gasPrice, _gas, _data;\n\n  var lastArg = args[args.length - 1];\n\n  if (_.isObject(lastArg) && !_.isArray(lastArg)) {\n    options = lastArg;\n    /**\n     * _getOrSetDefaultOptions은 contract instance 만들 때\n     * 마지막 인자로 넘어오는 options를 어느정도 포맷팅 해주는 기능을 한다.\n     * 그렇게 포맷팅 해주고 this.options에 _.extend 를 통해 박아줌.\n     */\n\n    this.options = _.extend(this.options, this._getOrSetDefaultOptions(options));\n    /**\n     * address로 들어오는 argument가 String type이 아닌 Object type으로 들어왔을 때,\n     * address를 null로 해준다. (parameter reassign하는 전형적인 anti pattern이네.;)\n     */\n\n    if (_.isObject(address)) {\n      address = null;\n    }\n  } // set address\n\n\n  Object.defineProperty(this.options, 'address', {\n    set: function (value) {\n      if (value) {\n        _this._address = utils.toChecksumAddress(formatters.inputAddressFormatter(value));\n      }\n    },\n    get: function () {\n      return _this._address;\n    },\n    enumerable: true\n  });\n  /**\n   * 보통 ABI가 [] json 어레이 형태로 각 function들 혹은 event들이 정의되어 있다.\n   * 예)\n   * [\n      { \"inputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"constructor\" },\n      { \"payable\": true, \"stateMutability\": \"payable\", \"type\": \"fallback\" },\n      { \"anonymous\": false, \"inputs\": [ { \"indexed\": false, \"name\": \"genes\", \"type\": \"uint256\" }, { \"indexed\": false, \"name\": \"owner\", \"type\": \"address\" }, { \"indexed\": false, \"name\": \"id\", \"type\": \"uint256\" } ], \"name\": \"GaveStartKitty\", \"type\": \"event\" },\n      { \"constant\": true, \"inputs\": [], \"name\": \"getIsGivenStartingKitty\", \"outputs\": [ { \"name\": \"\", \"type\": \"bool\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\n      { \"constant\": false, \"inputs\": [ { \"name\": \"_type\", \"type\": \"uint8\" }, { \"name\": \"name\", \"type\": \"bytes32\" } ], \"name\": \"getStartingKitty\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }\n    ]\n   * 이 array에 있는 아이템들을 모두 돌면서 얘가 type이 function으로 되어있으면 abi 모듈의 enocdeFunctionSignature를,\n   * type이 event로 되어있으면 abi 모듈의 encodeEventSignature를 수행한다.\n   */\n  // add method and event signatures, when the jsonInterface gets set\n\n  Object.defineProperty(this.options, 'jsonInterface', {\n    set: function (value) {\n      _this.methods = {};\n      _this.events = {};\n      _this._jsonInterface = value.map(function (method) {\n        var func, funcName;\n        /**\n         * method.name이 없는 경우는,\n         * i) fallback 함수인 경우\n         * ii) constructor 함수인 경우\n         * 뿐이고 나머지 함수들에는 모두 method.name이 있다.\n         * method.name이 있는 경우는, 아이템에서 inputs까지 가져와서 조합해서\n         * utils의 _jsonInterfaceMethodToString 메서드를 통해\n         * inputs와 name을 조합한 string으로 만들어준다.\n         * 예)\n         * SomeMethod(uint256, string, bool)\n         */\n\n        if (method.name) {\n          funcName = utils._jsonInterfaceMethodToString(method);\n        } // function\n\n\n        if (method.type === 'function') {\n          /**\n           * function signature란, 앞의 funcName을 통해\n           * keccak256을 돌리고 남은 4byte(8자리)만 slice하는 것을 의미한다.\n           * cf) 정확히는 '0x' 문자열까지 포함해서 10자리\n           */\n          method.signature = abi.encodeFunctionSignature(funcName);\n          func = _this._createTxObject.bind({\n            method: method,\n            parent: _this\n          }); // add method only if not one already exists\n\n          /**\n           * method.name이 중복되지 않을 경우 바로 _this.methods[method.name]에\n           * 위에서 _createTxObject를 통해 만든 func를 달아준다.\n           */\n\n          if (!_this.methods[method.name]) {\n            _this.methods[method.name] = func;\n          } else {\n            /**\n             * 중복된 method.name이 존재할 경우,\n             * cascadeFunc라는 것을 달아주는데,\n             * cascadeFunc는, 기존에 존재하던 method를\n             * nextMethod에 달아준 것을 의미한다.\n             * 즉, 'nextMethod'의 유무가 cascadeFunc와 일반 func를 구분짓는\n             * 기준이다.\n             */\n            var cascadeFunc = _this._createTxObject.bind({\n              method: method,\n              parent: _this,\n              nextMethod: _this.methods[method.name]\n            });\n\n            _this.methods[method.name] = cascadeFunc;\n          }\n          /**\n           * method를 이름(method.name) 외에도 signature 기준으로 달아준다.\n           */\n          // definitely add the method based on its signature\n\n\n          _this.methods[method.signature] = func; // add method by name\n\n          /**\n           * funcName, 즉, 이름으로도 달아준다.\n           * 예) SomeMethod(uint256, string, bool)\n           */\n\n          _this.methods[funcName] = func;\n          /**\n           * 이를 통해\n           * i) method.signature를 기준으로도 달리고\n           * ii) method.name을 기준으로도 달리고\n           * iii) funcName을 기준으로도 달리게 된다.\n           * 동일한 func라는 함수가.\n           */\n          // event\n        } else if (method.type === 'event') {\n          /**\n           * abi 모듈을 통해 eventSignature를 만들어주고, method.signature에 달아준다.\n           */\n          method.signature = abi.encodeEventSignature(funcName);\n          /**\n           * ??\n           * 이벤트 binding을 해준다.\n           */\n\n          var event = _this._on.bind(_this, method.signature); // add method only if not already exists\n\n          /**\n           * i) 중복된 method.name이 없을 때,\n           * ii) _this.events[method.name].name라는 값이 'bound '일 때,\n           * _this.events[method.name]에 해당 event를 달아준다.\n           */\n\n\n          if (!_this.events[method.name] || _this.events[method.name].name === 'bound ') _this.events[method.name] = event; // definitely add the method based on its signature\n\n          /**\n           * method를 signature 기준으로 달아준다.\n           */\n\n          _this.events[method.signature] = event; // add event by name\n\n          /**\n           * method를 funcName을 기준으로도 달아준다.\n           */\n\n          _this.events[funcName] = event;\n        }\n\n        return method;\n      }); // add allEvents\n\n      /**\n       * 기본적으로 allEvents라는 것을 contractInstance에 붙여준다.\n       */\n\n      _this.events.allEvents = _this._on.bind(_this, 'allevents');\n      return _this._jsonInterface;\n    },\n    get: function () {\n      return _this._jsonInterface;\n    },\n    enumerable: true\n  }); // get default account from the Class\n\n  var defaultAccount = this.constructor.defaultAccount;\n  var defaultBlock = this.constructor.defaultBlock || 'latest';\n  Object.defineProperty(this, 'defaultAccount', {\n    get: function () {\n      return defaultAccount;\n    },\n    set: function (val) {\n      if (val) {\n        defaultAccount = utils.toChecksumAddress(formatters.inputAddressFormatter(val));\n      }\n\n      return val;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, 'defaultBlock', {\n    get: function () {\n      return defaultBlock;\n    },\n    set: function (val) {\n      if (!utils.isValidBlockNumberCandidate(val)) {\n        throw new Error('Invalid default block number.');\n        return;\n      }\n\n      defaultBlock = val;\n      return val;\n    },\n    enumerable: true\n  }); // Check for setting options property.\n\n  Object.defineProperty(this.options, 'from', {\n    set: function (value) {\n      if (value) {\n        _this._from = utils.toChecksumAddress(formatters.inputAddressFormatter(value));\n      }\n    },\n    get: function () {\n      return _this._from;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'gasPrice', {\n    set: function (value) {\n      if (value) {\n        if (!utils.isValidNSHSN(value)) throw errors.invalidGasPrice();\n        _this._gasPrice = value;\n      }\n    },\n    get: function () {\n      return _this._gasPrice;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'gas', {\n    set: function (value) {\n      if (value) {\n        if (!utils.isValidNSHSN(value)) throw errors.invalidGasLimit();\n        _this._gas = value;\n      }\n    },\n    get: function () {\n      return _this._gas;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'data', {\n    set: function (value) {\n      if (value) {\n        if (!utils.isHexStrict(value)) throw errors.invalidData();\n        _this._data = value;\n      }\n    },\n    get: function () {\n      return _this._data;\n    },\n    enumerable: true\n  }); // properties\n\n  this.methods = {};\n  this.events = {};\n  this._address = null;\n  this._jsonInterface = []; // set getter/setter properties\n\n  this.options.address = address;\n  this.options.jsonInterface = jsonInterface;\n};\n/**\n * provider를 설정해주고, accounts를 _klayAccounts에 달아준다.\n */\n\n\nContract.setProvider = function (provider, accounts) {\n  // Contract.currentProvider = provider;\n  core.packageInit(this, [provider]);\n  this._klayAccounts = accounts;\n};\n\nContract.prototype.addAccounts = function (accounts) {\n  this._klayAccounts = accounts;\n};\n/**\n * Get the callback and modiufy the array if necessary\n *\n * @method _getCallback\n * @param {Array} args\n * @return {Function} the callback\n */\n\n/**\n * 받은 인자들 중 가장 마지막 값이 'function' type이면 콜백 함수이기 때문에,\n * 그거를 pop해서 가져온다.\n */\n\n\nContract.prototype._getCallback = function getCallback(args) {\n  if (args && _.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Checks that no listener with name \"newListener\" or \"removeListener\" is added.\n *\n * @method _checkListener\n * @param {String} type\n * @param {String} event\n * @return {Object} the contract instance\n */\n\n/**\n * 사용 예)\n * this._checkListener('newListener', subOptions.event.name, subOptions.callback);\n * this._checkListener('removeListener', subOptions.event.name, subOptions.callback);\n * 사용처가 딱 위에 저것밖에 없는데, \"newListener\"와 \"removeListener\"라는 이벤트 이름은\n * reserved name처럼 쓰고 있기 때문에, newListener나 removeListener라는 이벤트 이름과\n * 겹치면 에러를 뱉는 기능을 함수이다.\n */\n\n\nContract.prototype._checkListener = function (type, event) {\n  if (event === type) {\n    throw new Error('The event \"' + type + '\" is a reserved event name, you can\\'t use it.');\n  }\n};\n/**\n * Use default values, if options are not available\n *\n * @method _getOrSetDefaultOptions\n * @param {Object} options the options gived by the user\n * @return {Object} the options with gaps filled by defaults\n */\n\n/**\n * _getOrSetDefaultOptions\n * 현재 contract instance에 설정된 options들을\n * i) 그대로 가져오거나\n * ii) parameter로 넘긴 options로 대체해주는\n * 작업을 해주는 함수이다.\n *\n * gasPrice나 from은 특별히 var를 이용해서 작업해주는 라인이 초반에 있는데,\n * 이는 gasPrice나 from은 추가적인 포맷이 필요해서 그렇게 하는 것이다.\n *\n * || 을 통해서 정말로 값이 있는 것만 options에 새로 설정해주기 때문에,\n * options에 아무 parameter를 주지 않으면,\n * 위에서 말한 i)의 기능, \"그대로 가져오는\" 기능을 수행한다.\n *\n * options에 들어오는 값의 형태는 다음과 같다.\n * {\n *   from: ...,\n *   data: ...,\n *   gasPrice: ...,\n *   gas: ...,\n * }\n *\n * cf)\n * 사실, 이 함수에는 this.options에 직접 값을 박아주는 라인이 없어서,\n * 이 함수를 호출하는것만으로 this.options가 바뀌지 않기 때문에,\n * this.options = _.extend(this.options, this._getOrSetDefaultOptions(options));\n * 이런 형태로 _.extend를 통해 기존 this.options에 달아주는 형태로 사용해야 진짜 this.options가 바뀐다\n * 즉, 단순 이 함수만 호출한다고 해서 this.options에 값이 바뀌는 것은 아니다.\n */\n\n\nContract.prototype._getOrSetDefaultOptions = function getOrSetDefaultOptions(options) {\n  var gasPrice = options.gasPrice ? String(options.gasPrice) : null;\n  var from = options.from ? utils.toChecksumAddress(formatters.inputAddressFormatter(options.from)) : null;\n  options.data = options.data || this.options.data;\n  options.from = from || this.options.from;\n  options.gasPrice = gasPrice || this.options.gasPrice; // If options.gas isn't set manually, use options.gasLimit, this.options.gas instead.\n\n  if (typeof options.gas === 'undefined') {\n    options.gas = options.gasLimit || this.options.gas;\n  } // TODO replace with only gasLimit?\n\n\n  delete options.gasLimit;\n  return options;\n};\n/**\n * Should be used to encode indexed params and options to one final object\n *\n * @method _encodeEventABI\n * @param {Object} event\n * @param {Object} options\n * @return {Object} everything combined together and encoded\n */\n\n/**\n * _encodeEventABI\n * 1. options에 들어오는 값의 형태는 다음과 같다.\n * options = {\n *   filter: {...},\n *   topics: [...],\n * }\n *   cf. topics\n *   - This allows you to manually set the topics for the event filter.\n *   - If given the filter property and event signature, (topic[0]) will not\n *   - be set automatically.\n *\n * 2. event에 들어오는 값의 형태는 다음과 같다.\n * {\n *   anonymous: Bool,\n *   signature:\n *   name: String,\n *   inputs: [...],\n * }\n * cf) signature\n * - The signature’s hash of the event is one of the topics,\n * - unless you used the anonymous specifier to declare the event.\n * - This would mean filtering for anonymous, specific events by name is not possible.\n * - keccak256(\"burned(address,uint)\") = 0x0970ce1235167a71...\n */\n\n\nContract.prototype._encodeEventABI = function (event, options) {\n  options = options || {};\n  var filter = options.filter || {},\n      result = {};\n  /**\n   * parameter로 들어온 options에\n   * 'fromBlock', 'toBlock'이 존재하면\n   * 각각\n   * result['fromBlock']과\n   * result['toBlock']에 inputBlockNumberFormatter를 통해 포맷을 해준다.\n   */\n\n  ['fromBlock', 'toBlock'].filter(function (f) {\n    return options[f] !== undefined;\n  }).forEach(function (f) {\n    result[f] = formatters.inputBlockNumberFormatter(options[f]);\n  }); // use given topics\n\n  /**\n   * options에 topics값이 있다면, topics를 그 값으로 달아준다.\n   */\n\n  if (_.isArray(options.topics)) {\n    result.topics = options.topics; // create topics based on filter\n  } else {\n    /**\n     * options에 topics값이 없다면, 일단 빈 배열을 생성하고\n     * event.name이 'ALLEVENTS'가 아니라면,\n     * 1) event inputs로 들어온 놈 중 'indexed'가 true인 값만 필터하고\n     * 2) 걔네 중 filter[i.name]에 값이 있으면, caver-klay-abi 모듈을 통해 paramter를 encode한다.\n     * 3) map 함수가 끝나고 그렇게 encode된 값들이 'indexedTopics'라는 값에 담기게 되고,\n     * result.topics에 concat으로 달아준다.\n     */\n    result.topics = []; // add event signature\n\n    if (event && !event.anonymous && event.name !== 'ALLEVENTS') {\n      result.topics.push(event.signature);\n    } // add event topics (indexed arguments)\n\n\n    if (event.name !== 'ALLEVENTS') {\n      var indexedTopics = event.inputs.filter(i => i.indexed === true).map(i => {\n        var value = filter[i.name];\n        if (!value) return null; // TODO: https://github.com/ethereum/web3.js/issues/344\n\n        if (_.isArray(value)) {\n          return value.map(v => abi.encodeParameter(i.type, v));\n        }\n\n        return abi.encodeParameter(i.type, value);\n      });\n      result.topics = result.topics.concat(indexedTopics);\n    }\n    /**\n     * 위의 topics 값 달아주는 과정을 거쳤는데도 result.topics가 빈배열이라면\n     * 그냥 메모리에서 삭제해준다\n     */\n\n\n    if (!result.topics.length) delete result.topics;\n  }\n  /**\n   * this.options.address에 값이 있다면, LowerCase로 바꿔서 result.address에 달아준다.\n   */\n\n\n  if (this.options.address) {\n    result.address = this.options.address.toLowerCase();\n  }\n\n  return result;\n};\n/**\n * Should be used to decode indexed params and options\n *\n * @method _decodeEventABI\n * @param {Object} data\n * @return {Object} result object with decoded indexed && not indexed params\n */\n\n/**\n * _decodeEventABI\n * parameter인 data로 들어오는 값의 형태는 다음과 같다.\n * {\n *   data: String,\n *   topics: [...],\n * }\n */\n\n\nContract.prototype._decodeEventABI = function (data) {\n  /**\n   * 주로 _decodeEventABI.bind(...) bind 해서 쓰는 형태라\n   * bind에 event를 달기 때문에, 명시적으로 'event'라는 이름으로 자기 컨텍스트 이름을 선언했다.\n   * event는\n   * {\n   *   name: String,\n   *   inputs: [...],\n   *   jsonInterface: [...] 형태이다.\n   * }\n   */\n  var event = this;\n  data.data = data.data || '';\n  data.topics = data.topics || [];\n  var result = formatters.outputLogFormatter(data); // if allEvents get the right event\n\n  if (event.name === 'ALLEVENTS') {\n    event = event.jsonInterface.find(function (intf) {\n      return intf.signature === data.topics[0];\n    }) || {\n      anonymous: true\n    };\n  } // create empty inputs if none are present (e.g. anonymous events on allEvents)\n\n\n  event.inputs = event.inputs || [];\n  /**\n   * event가 anonymous라면, topics 그대로 argTopics로 주고,\n   * anonymous로 설정되어있지 않으면 맨앞에꺼 하나 떼서 나머지들만 준다.\n   * @todo 왜?\n   * => 맨 앞에 있는 애는 event signature이고 (얘도 어쨌든 topic)이니까,\n   * => 그 다음부터 오는 애들은 indexedTopics 이기 때문에, argTopics라는 이름으로 따로 떼어주는 것.\n   */\n\n  var argTopics = event.anonymous ? data.topics : data.topics.slice(1);\n  /**\n   * 본격적으로 결과값 셋팅해주는 부분.\n   * result.returnValues, result.event, result.signature, result.raw(data와 topics)\n   * 를 셋팅해준다.\n   */\n\n  result.returnValues = abi.decodeLog(event.inputs, data.data, argTopics);\n  delete result.returnValues.__length__; // add name\n\n  result.event = event.name; // add signature\n\n  /**\n   * @todo event가 anonymous라는 뜻은 signature가 없다는 뜻으로 이해하면 되나?\n   */\n\n  result.signature = event.anonymous || !data.topics[0] ? null : data.topics[0]; // move the data and topics to \"raw\"\n\n  result.raw = {\n    data: result.data,\n    topics: result.topics\n  };\n  delete result.data;\n  delete result.topics;\n  return result;\n};\n/**\n * Encodes an ABI for a method, including signature or the method.\n * Or when constructor encodes only the constructor parameters.\n *\n * @method _encodeMethodABI\n * @param {Mixed} args the arguments to encode\n * @param {String} the encoded ABI\n */\n\n/**\n * _encodeMethodABI\n * _encodeMethodABI는 txObject에 bind되어서 사용된다.\n *\n */\n\n\nContract.prototype._encodeMethodABI = function _encodeMethodABI() {\n  /**\n   * this context에서 methodSignature와 args를 가져온다.\n   */\n  var methodSignature = this._method.signature,\n      args = this.arguments || [];\n  /**\n   * 일단 signature라는 값을 false로 초기화 하고,\n   * paramsABI라는 값을 만들어주는 과정을 시행한다. (filter 한번, map 두번)\n   * @todo paramsABI라는 값의 정체는?\n   */\n\n  var signature = false,\n      paramsABI = this._parent.options.jsonInterface.filter(function (json) {\n    /**\n     * _parent에 options에 붙은 jsonInterface를 돌면서,\n     * i) methodSignature가 constructor이면서 json type과 methodSignature가 동일한 경우\n     * ii) json signature와 methodSignature가 동일한 경우 && 이면서 json type이 'function'인 경우\n     * iii) json signature와 methodSignature에서 '0x'라는 스트링을 뺐을 때가 동일한 경우 && 이면서 json type이 'function'인 경우\n     * iv) json name과 methodSignature가 동일한 경우 && 이면서 json type이 'function'인 경우\n     * 에 대해서만 값을 filter로 추려준다.\n     */\n    return methodSignature === 'constructor' && json.type === methodSignature || (json.signature === methodSignature || json.signature === methodSignature.replace('0x', '') || json.name === methodSignature) && json.type === 'function';\n  }).map(function (json) {\n    /**\n     * jsonABI의 inputs값이 배열이면 그 length를 뱉어주고, 없으면 0 으로 초기화.\n     */\n    var inputLength = _.isArray(json.inputs) ? json.inputs.length : 0;\n    /**\n     * ABI에서 정의되어 있는 length와 실제로 method encode 시 내가 준 argument랑\n     * 숫자 차이가 나면, 에러를 뱉는다.\n     */\n\n    if (inputLength !== args.length) {\n      throw new Error('The number of arguments is not matching the methods required number. You need to pass ' + inputLength + ' arguments.');\n    }\n    /**\n     * 처음에 false라는 값으로 초기화했던 signature라는 값을, json.signature로\n     * 덮어준다.\n     */\n\n\n    if (json.type === 'function') {\n      signature = json.signature;\n    }\n    /**\n     * ABI에 inputs가 배열로서 존재하면 (json.inputs가 배열이라면)\n     * json.inputs를 map을 돌면서 type만 쏙 빼줘서 다시 다음 map으로 넘긴다.\n     * uint256, bytes32, address 이런 것들이 type이다.\n     * 이런 식의 형태로 다음 map을 돌게 된다. ['uint256', 'bytes32', 'address']\n     */\n\n\n    return _.isArray(json.inputs) ? json.inputs : [];\n  }).map(function (inputs) {\n    /**\n     * @todo abi 모듈에서 encodeParameters에 대한 기능을 먼저 보고 확인해보는 것으로.\n     */\n    return abi.encodeParameters(inputs, args).replace('0x', '');\n  })[0] || ''; // @todo 흠 이렇게 map으로 다 돌아서 배열만들어준 후 가장 첫번째 아이템만 뱉어준다?\n  // return constructor\n\n  /**\n   * methodSignature가 constructor인 경우이면서 deployData가 존재하지 않는 경우에는 에러를 뱉는다.\n   * @todo deployData가 존재한다면 deployData와 paramsABI 스트링을 합쳐준 값을 리턴한다.? 이 값이 뭐지?\n   */\n\n  if (methodSignature === 'constructor') {\n    if (!this._deployData) throw new Error('The contract has no contract data option set. This is necessary to append the constructor parameters.');\n    return this._deployData + paramsABI; // return method\n  } else {\n    /**\n     * methodSignature가 'constructor'가 아니라면,\n     * signature가 있다면 signature와 paramsABI를 붙인 값. (즉 스트링)\n     * signature가 없다면 그냥 paramsABI만 리턴 해준다.\n     */\n    var returnValue = signature ? signature + paramsABI : paramsABI;\n    /**\n     * 위의 과정은 사실상 this._method.name에 박혀있는것을 JSON ABI 돌면서 찾아준다음에 꽂는 기능인데,\n     * 위의 기능을 수행했는데도 paramsABI를 못찾았다는 것은, ABI에 실제로 this._method.name에 해당하는 값이\n     * 없다는 뜻이 된다. 이 경우에는 못찾았다는 에러를 뱉는다.\n     */\n\n    if (!returnValue) {\n      throw new Error('Couldn\\'t find a matching contract method named \"' + this._method.name + '\".');\n    } else {\n      /**\n       * 위의 과정을 돌면서 paramsABI를 찾은 경우에는 returnValue를 리턴해준다.\n       */\n      return returnValue;\n    }\n  }\n};\n/**\n * Decode method return values\n *\n * @method _decodeMethodReturn\n * @param {Array} outputs\n * @param {String} returnValues\n * @return {Object} decoded output return values\n */\n\n/**\n * _decodeMethodReturn\n * Array로 넘어온 outputs와 String으로 넘어온 returnValues에 대해서 decode해주는 메서드이다.\n */\n\n\nContract.prototype._decodeMethodReturn = function (outputs, returnValues) {\n  /**\n   * returnValues가 parameter로 넘어오지 않았다면 그냥 null을 리턴해준다.\n   */\n  if (!returnValues) {\n    return null;\n  }\n  /**\n   * returnValues라는 string이 2보다 길다면, 앞에 두 문자열을 떼준다.\n   */\n\n\n  returnValues = returnValues.length >= 2 ? returnValues.slice(2) : returnValues;\n  /**\n   * abi 모듈의 decodeParameters를 통해 outputs와 returnValues를 decode해준다.\n   */\n\n  var result = abi.decodeParameters(outputs, returnValues);\n  /**\n   * __length__라는 것은 abi 모듈의 decodeParamters를 돌고나면 생기는 것 같다.\n   * 여튼, result가 1의 길이를 가진다면, result의 첫 번째 아이템을 리턴해준다.\n   * result는 'decode output return values'로, Object의 형태를 띤다.\n   */\n\n  if (result.__length__ === 1) {\n    return result[0];\n  } else {\n    /**\n     * result.__length__가 1이 아니라면 result 그대로 리턴해준다.\n     */\n    delete result.__length__;\n    return result;\n  }\n};\n/**\n * Deploys a contract and fire events based on its state: transactionHash, receipt\n *\n * All event listeners will be removed, once the last possible event is fired (\"error\", or \"receipt\")\n *\n * @method deploy\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\n\n/**\n * parameter로 들어오는 options의 형태는 다음과 같다.\n * options = {\n *   arguments: [...],\n *   data: ...,\n *\n * }\n */\n\n\nContract.prototype.deploy = function (options, callback) {\n  options = options || {};\n  /**\n   * options.arguments에 값이 있다면 그대로 쓰고, 없으면 빈 배열로 초기화.\n   */\n\n  options.arguments = options.arguments || [];\n  options = this._getOrSetDefaultOptions(options); // return error, if no \"data\" is specified\n\n  /**\n   * deploy를 시도하려고 하는데 data가 없다는 것은 잘못된 것이기 때문에 에러를 뱉는다.\n   */\n\n  if (!options.data) {\n    return utils._fireError(new Error('No \"data\" specified in neither the given options, nor the default options.'), null, null, callback);\n  }\n\n  var constructor = _.find(this.options.jsonInterface, function (method) {\n    return method.type === 'constructor';\n  }) || {};\n  constructor.signature = 'constructor';\n  return this._createTxObject.apply({\n    method: constructor,\n    parent: this,\n    deployData: options.data,\n    _klayAccounts: this.constructor._klayAccounts\n  }, options.arguments);\n};\n/**\n * Gets the event signature and outputformatters\n *\n * @method _generateEventOptions\n * @param {Object} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event options object\n */\n\n/**\n * _on과 getPastEvents의 submethod로 쓰이는 함수이다.\n */\n\n\nContract.prototype._generateEventOptions = function () {\n  var args = Array.prototype.slice.call(arguments); // get the callback\n\n  /**\n   * 보통 contract instance에 있는 event 관련 함수를 부르는 형태는\n   * contractInstance.getPastEvents('MyEvent', {\n   *   filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23\n   *   fromBlock: 0,\n  *    toBlock: 'latest',\n   * }, function(error, events){ console.log(events) })\n   * 이런 식으로,\n   * 첫 번째 parameter는 eventName,\n   * 두 번째 parameter는 event option,\n   * 세 번째 (마지막) parameter는 callback 함수 형태로 나오기 때문에,\n   * getCallback 같은 함수는 사실상 마지막에 달려있는 argument를 빼내는 기능을 하는 것이라 볼 수 있다.\n   * 여튼, getCallback 메서드를 통해 args에 달려있는 마지막 콜백을 pop으로 빼낸다.\n   */\n\n  var callback = this._getCallback(args); // get the options\n\n  /**\n   * callback이 빠진 후 args.length - 1에 있는게 보통 options 인데,\n   * 이게 isObject 조건을 충족한다면, 확실하게 options라고 생각할 수 있으므로\n   * pop을 해서 빼내고, 만약 없다면, 빈 object로 options를 초기화해준다.\n   */\n\n\n  var options = _.isObject(args[args.length - 1]) ? args.pop() : {};\n  /**\n   * event 찾아서\n   * {\n   *   name: ...,\n   *   jsonInterface: ...,\n   * }\n   * 형태화 해주는 과정.\n   *\n   * args[0]은 즉, 확실하게, 'eventName'을 말한다. 얘는 optional한 parameter가 아니기 때문.\n   */\n\n  var event = _.isString(args[0]) ? args[0] : 'allevents';\n  event = event.toLowerCase() === 'allevents' ? {\n    name: 'ALLEVENTS',\n    jsonInterface: this.options.jsonInterface // 우리가 넘겨주는 ABI 배열(엄청 긴거)\n\n  } : this.options.jsonInterface.find(function (json) {\n    // 그 ABI 배열안에서 find로 우리가 eventName parameter에 주었던 스트링을 찾음.\n    // json.name (이름으로 찾거나)\n    // json.signature (시그니쳐, 즉 헥스 값으로 찾거나)\n    return json.type === 'event' && (json.name === event || json.signature === '0x' + event.replace('0x', ''));\n  });\n  /**\n   * 위의 event를 찾고 이를\n   * { name: ..., jsonInterface: ... } 형태로 만든 과정을 거쳤는데도,\n   * event가 존재하지 않는다면, 컨트랙트 ABI 상에 event type이 없는 것이기 때문에,\n   * 에러를 뱉어준다.\n   * @todo 근데 이 에러가 뜨는 순간이 있긴한가? event에 args[0]에 값 없으면 무조건 'allevents' 값으로 초기화시켜주고,\n   * { name: 'ALLEVENTS', jsonInterface: this.options.jsonInterface }로 값 만들어주는데?\n   * => event parameter에 string을 넣긴 넣었는데 ABI에 실제로 없는 이벤트인 경우 에러가 뜰 것임.\n   */\n\n  if (!event) {\n    throw new Error('Event \"' + event.name + '\" doesn\\'t exist in this contract.');\n  }\n  /**\n   * contract instance에 address가 안 달려있으면 address를 달아달라고 에러를 뱉는다.\n   */\n\n\n  if (!utils.isAddress(this.options.address)) {\n    throw new Error('This contract object doesn\\'t have address set yet, please set an address first.');\n  }\n  /**\n   * params는 event와 options를 통해 encodeEventABI를 한 형태이고,\n   * event는 'allevents'인 경우\n   * {\n   *   name: 'allevents',\n   *   jsonInterface: ...\n   * }\n   * 의 형태,\n   * 그 외의 경우는 ABI에서 가져온 event의 jsoninterface.\n   * 형태를 가진다.\n   */\n\n\n  return {\n    params: this._encodeEventABI(event, options),\n    event: event,\n    callback: callback\n  };\n};\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n *\n * @method clone\n * @return {Object} the event subscription\n */\n\n/**\n * new로 현재 constructor에 붙어있는 options 그대로 다시한번 construct해서 instance 새로 만드는 함수이다.\n */\n\n\nContract.prototype.clone = function () {\n  return new this.constructor(this.options.jsonInterface, this.options.address, this.options);\n};\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n * (Subscribes to an event and unsubscribes immediately after the first event or error. Will only fire for a single event.)\n *\n *\n * @method once\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event subscription\n *\n * myContract.once('MyEvent', {\n      filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23\n      fromBlock: 0\n  }, function(error, event){ console.log(event); });\n\n  // event output example\n  > {\n      returnValues: {\n          myIndexedParam: 20,\n          myOtherIndexedParam: '0x123456789...',\n          myNonIndexParam: 'My String'\n      },\n      raw: {\n          data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n          topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\n      },\n      event: 'MyEvent',\n      signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      logIndex: 0,\n      transactionIndex: 0,\n      transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n      blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      blockNumber: 1234,\n      address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\n  }\n */\n\n\nContract.prototype.once = function (event, options, callback) {\n  var args = Array.prototype.slice.call(arguments); // get the callback\n\n  callback = this._getCallback(args);\n\n  if (!callback) {\n    throw new Error('Once requires a callback as the second parameter.');\n  } // don't allow fromBlock\n\n\n  if (options) delete options.fromBlock; // don't return as once shouldn't provide \"on\"\n  // 단순히 _on에 콜백에 바로 unsubscribe해주는 것이 once다.\n\n  this._on(event, options, function (err, res, sub) {\n    // once이기 때문에 바로 unsubscribe.\n    sub.unsubscribe();\n\n    if (_.isFunction(callback)) {\n      callback(err, res, sub);\n    }\n  });\n\n  return undefined;\n};\n/**\n * Adds event listeners and creates a subscription.\n *\n * @method _on\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event subscription\n */\n\n\nContract.prototype._on = function () {\n  var subOptions = this._generateEventOptions.apply(this, arguments); // prevent the event \"newListener\" and \"removeListener\" from being overwritten\n\n\n  this._checkListener('newListener', subOptions.event.name, subOptions.callback);\n\n  this._checkListener('removeListener', subOptions.event.name, subOptions.callback); // TODO check if listener already exists? and reuse subscription if options are the same.\n  // create new subscription\n  // 결국, subscribe해주는 역할은 Subscription instance에서 한다.\n\n\n  var subscription = new Subscription({\n    subscription: {\n      params: 1,\n      inputFormatter: [formatters.inputLogFormatter],\n      outputFormatter: this._decodeEventABI.bind(subOptions.event),\n      // DUBLICATE, also in caver-klay\n      subscriptionHandler: function (output) {\n        this.emit('data', output);\n        if (_.isFunction(this.callback)) this.callback(null, output, this);\n      }\n    },\n    type: 'klay',\n    requestManager: this._requestManager\n  });\n  subscription.subscribe('logs', subOptions.params, subOptions.callback || function () {});\n  return subscription;\n};\n/**\n * Get past events from contracts\n *\n * @method getPastEvents\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the promievent\n */\n\n/**\n * 'klay_getLogs'를 보낼 수 있는 json rpc 콜 기능을 하는 함수이다.\n * 1) new Method 로 json rpc method 형태로 값을 만들어주고,\n * 2) setRequestManager로 requestmanager를 붙여주고,\n * 3) Method 인스턴스에 붙어있는 buildCall을 통해 call을 가져와서\n * 4) 마지막으로 call을 불러준다.\n *\n * myContract.getPastEvents('MyEvent', {\n      filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23\n      fromBlock: 0,\n      toBlock: 'latest'\n  }, function(error, events){ console.log(events); })\n  .then(function(events){\n      console.log(events) // same results as the optional callback above\n  });\n\n  > [{\n      returnValues: {\n          myIndexedParam: 20,\n          myOtherIndexedParam: '0x123456789...',\n          myNonIndexParam: 'My String'\n      },\n      raw: {\n          data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n          topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\n      },\n      event: 'MyEvent',\n      signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      logIndex: 0,\n      transactionIndex: 0,\n      transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n      blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      blockNumber: 1234,\n      address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\n  },{\n      ...\n  }]\n */\n\n\nContract.prototype.getPastEvents = function () {\n  var subOptions = this._generateEventOptions.apply(this, arguments);\n\n  var getPastLogs = new Method({\n    name: 'getPastLogs',\n    call: 'klay_getLogs',\n    params: 1,\n    inputFormatter: [formatters.inputLogFormatter],\n    outputFormatter: this._decodeEventABI.bind(subOptions.event)\n  });\n  getPastLogs.setRequestManager(this._requestManager);\n  var call = getPastLogs.buildCall();\n  /**\n   * call만 빼내고 getPastLogs는 null로 해준다.\n   * @todo 굳이 이렇게 해주는 이유는?\n   */\n\n  getPastLogs = null;\n  return call(subOptions.params, subOptions.callback);\n};\n/**\n * returns the an object with call, send, estimate functions\n *\n * @method _createTxObject\n * @returns {Object} an object with functions to call the methods\n */\n\n/**\n * txObject를 만들어주는 과정인데,\n * 보통\n * func = _this._createTxObject.bind({\n       method: method,\n       parent: _this\n   });\n   이런 식으로 this를 bind 해줘서 만들어주기 때문에\n   parent는 Contract instance를 가리키고,\n   method는 ABI에서 빼낸 그 method이다.\n */\n\n\nContract.prototype._createTxObject = function _createTxObject() {\n  var args = Array.prototype.slice.call(arguments);\n  var txObject = {};\n  /**\n   * _executeMethod에 bind할 때, 'call', 'send', 'estimate'를 같이 보낼 수 있는데,\n   * 얘네가 우리가 정말 그 메서드 call하거나 send할 때 쓰이는 그것들이다.\n   */\n\n  if (this.method.type === 'function') {\n    txObject.call = this.parent._executeMethod.bind(txObject, 'call');\n    txObject.call.request = this.parent._executeMethod.bind(txObject, 'call', true); // to make batch requests\n  }\n  /**\n   * txObject에 .send() 이걸 해줘야 진짜 send가 되는 것임.\n   */\n\n\n  txObject.send = this.parent._executeMethod.bind(txObject, 'send');\n  txObject.send.request = this.parent._executeMethod.bind(txObject, 'send', true); // to make batch requests\n\n  txObject.encodeABI = this.parent._encodeMethodABI.bind(txObject);\n  txObject.estimateGas = this.parent._executeMethod.bind(txObject, 'estimate');\n\n  if (args && this.method.inputs && args.length !== this.method.inputs.length) {\n    if (this.nextMethod) {\n      return this.nextMethod.apply(null, args);\n    }\n\n    throw errors.InvalidNumberOfParams(args.length, this.method.inputs.length, this.method.name);\n  }\n\n  txObject.arguments = args || [];\n  txObject._method = this.method;\n  txObject._parent = this.parent;\n  txObject._klayAccounts = this.parent.constructor._klayAccounts || this._klayAccounts;\n\n  if (this.deployData) {\n    txObject._deployData = this.deployData;\n  }\n\n  return txObject;\n};\n/**\n * Generates the options for the execute call\n *\n * @method _processExecuteArguments\n * @param {Array} args\n * @param {Promise} defer\n */\n\n\nContract.prototype._processExecuteArguments = function _processExecuteArguments(args, defer) {\n  var processedArgs = {};\n  processedArgs.type = args.shift(); // get the callback\n\n  processedArgs.callback = this._parent._getCallback(args); // get block number to use for call\n\n  if (processedArgs.type === 'call' && args[args.length - 1] !== true && (_.isString(args[args.length - 1]) || isFinite(args[args.length - 1]))) processedArgs.defaultBlock = args.pop(); // get the options\n\n  processedArgs.options = _.isObject(args[args.length - 1]) ? args.pop() : {}; // get the generateRequest argument for batch requests\n\n  processedArgs.generateRequest = args[args.length - 1] === true ? args.pop() : false;\n  processedArgs.options = this._parent._getOrSetDefaultOptions(processedArgs.options);\n  processedArgs.options.data = this.encodeABI(); // add contract address\n\n  if (!this._deployData && !utils.isAddress(this._parent.options.address)) throw new Error('This contract object doesn\\'t have address set yet, please set an address first.');\n  if (!this._deployData) // default address로 to를 설정\n    processedArgs.options.to = this._parent.options.address; // return error, if no \"data\" is specified\n  // execute call을 위해서는 options.data은 당연히 있어야 함. (estiamteGas, call, sendTransaction할 때 당연히 있어야 하는 것.)\n  // @todo 이거로 어떤 함수를 부를 지 판단하는건가?\n\n  if (!processedArgs.options.data) return utils._fireError(new Error('Couldn\\'t find a matching contract method, or the number of parameters is wrong.'), defer.eventEmitter, defer.reject, processedArgs.callback);\n  return processedArgs;\n};\n/**\n * Executes a call, transact or estimateGas on a contract function\n *\n * @method _executeMethod\n * @param {String} type the type this execute function should execute\n * @param {Boolean} makeRequest if true, it simply returns the request parameters, rather than executing it\n */\n\n/**\n * call, sendTransaction, estimateGas 관장하는 가장 코어가 되는 internal 메서드\n */\n\n\nContract.prototype._executeMethod = function _executeMethod() {\n  var _this = this,\n      args = this._parent._processExecuteArguments.call(this, Array.prototype.slice.call(arguments), defer),\n      // array형태의 argument를 object화 해줌.\n  defer = utils.promiEvent(args.type !== 'send'),\n      klayAccounts = _this.constructor._klayAccounts || _this._klayAccounts; // Not allow to specify options.gas to 0.\n\n\n  if (args.options && args.options.gas === 0) {\n    throw errors.notAllowedZeroGas();\n  }\n  /**\n   * _processExecuteArguments를 거치고 난 후 args의 형태는 다음과 같다.\n   * {\n   *   type: ..., // 'call' || 'estimate' || 'send'\n   *   defaultBlock: ...,\n   *   callback: ...,\n   *   options: {\n   *     from: ...,\n   *     value: ...,\n   *     ...,\n   *   }\n   * }\n   */\n  // simple return request for batch requests\n\n\n  if (args.generateRequest) {\n    var payload = {\n      params: [formatters.inputCallFormatter.call(this._parent, args.options)],\n      callback: args.callback\n    };\n\n    if (args.type === 'call') {\n      payload.params.push(formatters.inputDefaultBlockNumberFormatter.call(this._parent, args.defaultBlock));\n      payload.method = 'klay_call';\n      payload.format = this._parent._decodeMethodReturn.bind(null, this._method.outputs);\n    } else {\n      payload.method = 'klay_sendTransaction';\n    }\n\n    return payload;\n  } else {\n    switch (args.type) {\n      case 'estimate':\n        var estimateGas = new Method({\n          name: 'estimateGas',\n          call: 'klay_estimateGas',\n          params: 1,\n          inputFormatter: [formatters.inputCallFormatter],\n          outputFormatter: utils.hexToNumber,\n          requestManager: _this._parent._requestManager,\n          accounts: klayAccounts,\n          // is klay.accounts (necessary for wallet signing)\n          defaultAccount: _this._parent.defaultAccount,\n          defaultBlock: _this._parent.defaultBlock\n        }).createFunction();\n        return estimateGas(args.options, args.callback);\n\n      case 'call':\n        // TODO check errors: missing \"from\" should give error on deploy and send, call ?\n        var call = new Method({\n          name: 'call',\n          call: 'klay_call',\n          params: 2,\n          inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter],\n          // add output formatter for decoding\n          outputFormatter: function (result) {\n            return _this._parent._decodeMethodReturn(_this._method.outputs, result);\n          },\n          requestManager: _this._parent._requestManager,\n          accounts: klayAccounts,\n          // is klay.accounts (necessary for wallet signing)\n          defaultAccount: _this._parent.defaultAccount,\n          defaultBlock: _this._parent.defaultBlock\n        }).createFunction();\n        return call(args.options, args.defaultBlock, args.callback);\n\n      case 'send':\n        // return error, if no \"from\" is specified\n        if (!utils.isAddress(args.options.from)) {\n          return utils._fireError(new Error('No \"from\" address specified in neither the given options, nor the default options.'), defer.eventEmitter, defer.reject, args.callback);\n        }\n\n        if (_.isBoolean(this._method.payable) && !this._method.payable && args.options.value && args.options.value > 0) {\n          return utils._fireError(new Error('Can not send value to non-payable contract method or constructor'), defer.eventEmitter, defer.reject, args.callback);\n        } // make sure receipt logs are decoded\n\n\n        var extraFormatters = {\n          receiptFormatter: function (receipt) {\n            if (_.isArray(receipt.logs)) {\n              // decode logs\n              var events = _.map(receipt.logs, function (log) {\n                return _this._parent._decodeEventABI.call({\n                  name: 'ALLEVENTS',\n                  jsonInterface: _this._parent.options.jsonInterface\n                }, log);\n              }); // make log names keys\n\n\n              receipt.events = {};\n              var count = 0;\n              events.forEach(function (ev) {\n                if (ev.event) {\n                  // if > 1 of the same event, don't overwrite any existing events\n                  if (receipt.events[ev.event]) {\n                    if (Array.isArray(receipt.events[ev.event])) {\n                      receipt.events[ev.event].push(ev);\n                    } else {\n                      receipt.events[ev.event] = [receipt.events[ev.event], ev];\n                    }\n                  } else {\n                    receipt.events[ev.event] = ev;\n                  }\n                } else {\n                  receipt.events[count] = ev;\n                  count++;\n                }\n              });\n              delete receipt.logs;\n            }\n\n            return receipt;\n          },\n          contractDeployFormatter: function (receipt) {\n            var newContract = _this._parent.clone();\n\n            newContract.options.address = receipt.contractAddress;\n            return newContract;\n          }\n        };\n        var sendTransaction = new Method({\n          name: 'sendTransaction',\n          call: 'klay_sendTransaction',\n          params: 1,\n          inputFormatter: [formatters.inputTransactionFormatter],\n          requestManager: _this._parent._requestManager,\n          accounts: _this.constructor._klayAccounts || _this._klayAccounts,\n          // is klay.accounts (necessary for wallet signing)\n          defaultAccount: _this._parent.defaultAccount,\n          defaultBlock: _this._parent.defaultBlock,\n          extraFormatters: extraFormatters\n        }).createFunction();\n        return sendTransaction(args.options, args.callback);\n    }\n  }\n};\n\nmodule.exports = Contract;","map":null,"metadata":{},"sourceType":"script"}