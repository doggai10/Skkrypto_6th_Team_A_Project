{"ast":null,"code":"var _slicedToArray = require(\"/Users/heeje/Desktop/Projcet_A/Front_End/react-dapp/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\n/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Add '0x' hex string when private key does not contain '0x' in privateKeyToAccount  2018-11\n * Change preamble message, defaultKeyName 2018-11\n */\nvar _ = require(\"underscore\");\n\nvar core = require('../../../caver-core');\n\nvar Method = require('../../../caver-core-method');\n\nvar Promise = require('any-promise'); // account, hash, rlp, nat, bytes library will be used from 'eth-lib' temporarily.\n\n\nvar Account = require(\"eth-lib/lib/account\");\n\nvar Hash = require(\"eth-lib/lib/hash\");\n\nvar RLP = require(\"eth-lib/lib/rlp\");\n\nvar Nat = require(\"eth-lib/lib/nat\");\n\nvar Bytes = require(\"eth-lib/lib/bytes\");\n\nvar cryp = typeof global === 'undefined' ? require('crypto-browserify') : require('crypto');\n\nvar scryptsy = require('scrypt.js');\n\nvar uuid = require('uuid');\n\nvar utils = require('../../../caver-utils');\n\nvar helpers = require('../../../caver-core-helpers');\n\nconst _require = require('./makeRawTransaction'),\n      encodeRLPByTxType = _require.encodeRLPByTxType,\n      makeRawTransaction = _require.makeRawTransaction;\n\nvar elliptic = require('elliptic');\n\nvar secp256k1 = new elliptic.ec('secp256k1');\n\nconst rpc = require('../../../caver-rtm').rpc;\n/**\n * underscore 메서드 이용해서 undefined거나 null인 경우 판단.\n * undefined나 null인 경우를 'Not' 이라고 해석한다.\n */\n\n\nvar isNot = function (value) {\n  return _.isUndefined(value) || _.isNull(value);\n};\n\nfunction coverInitialTxValue(tx) {\n  if (typeof tx !== 'object') throw 'Invalid transaction';\n  tx.to = tx.to || '0x';\n  tx.data = tx.data || '0x';\n  tx.value = tx.value || '0x';\n  tx.chainId = utils.numberToHex(tx.chainId);\n  return tx;\n}\n\nvar Accounts = function Accounts(...args) {\n  var _this = this; // sets _requestmanager\n\n\n  core.packageInit(this, args); // remove unecessary core functions\n\n  delete this.BatchRequest;\n  delete this.extend;\n  /**\n   * net_version, klay_gasPrice, klay_getTransactionCount json rpc 콜 날릴 수 있는\n   * 메서드를 Account instance에 붙여준다.\n   */\n\n  var _klaytnCall = [rpc.getChainId, rpc.getGasPrice, rpc.getTransactionCount]; // attach methods to this._klaytnCall\n\n  this._klaytnCall = {};\n\n  _.each(_klaytnCall, function (method) {\n    method.attachToObject(_this._klaytnCall);\n    method.setRequestManager(_this._requestManager);\n  });\n\n  this.wallet = new Wallet(this);\n};\n/**\n * Generates an account object with private key and public key.\n * 보통 {\n *   privateKey: ...,\n *   address: ...,\n * }\n * 만 존재하는 object에 signTransaction, sign, encrypt 메서드 달아주는 함수이다.\n */\n\n\nAccounts.prototype._addAccountFunctions = function (account) {\n  var _this = this; // add sign functions\n\n\n  account.signTransaction = function signTransaction(tx, callback) {\n    return _this.signTransaction(tx, account.privateKey, callback);\n  };\n\n  account.sign = function sign(data) {\n    return _this.sign(data, account.privateKey);\n  };\n\n  account.encrypt = function encrypt(password, options) {\n    return _this.encrypt(account.privateKey, password, options);\n  };\n\n  return account;\n};\n/**\n * cf) Accounts와 Account는 다른 모듈이다.\n * Account (외부모듈)의 create 함수를 이용해서 account를 만들어 준 뒤에,\n * _addAccountFunctions를 통해 signTransaction, sign, encrypt 메서드를 붙여준다.\n * _addAccountFunctions가 리턴하는 것은 저런 메서드가 붙은 account이기 때문에\n * return this._addAccountFunctions 해줘도 상관없는 것임.\n *\n * entropy라는 랜덤 스트링을 주면 외부모듈 Account가 account 만들 때 영향을 준다고 함.\n * Account.create의 결과값은 다음과 같은 형태이다.\n * {\n *   address: address,\n *   privateKey: privateKey\n * }\n *\n */\n\n\nAccounts.prototype.create = function create(entropy) {\n  return this._addAccountFunctions(Account.create(entropy || utils.randomHex(32)));\n};\n/**\n * 외부모듈 Account의 fromPrivate 메서드를 이용하면 privatekey를 parameter로 주어서\n * account를 만들 수 있다.\n * Account 모듈의 fromPrivate 메서드 자체가 account 만드는 메서드임.\n * cav.klay.accounts.privateKeyToAccount('0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709');\n  > {\n      address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\n      privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n      signTransaction: function(tx){...},\n      sign: function(data){...},\n      encrypt: function(password){...}\n  }\n */\n\n\nAccounts.prototype.privateKeyToAccount = function privateKeyToAccount(privateKey) {\n  if (!utils.isValidPrivateKey(privateKey)) throw new Error('Invalid private key');\n\n  if (privateKey.slice(0, 2) !== '0x') {\n    privateKey = \"0x\".concat(privateKey);\n  }\n\n  return this._addAccountFunctions(Account.fromPrivate(privateKey));\n};\n/**\n * transaction 을 sign하는 메서드이다.\n * 당연히 sign을 해야하기 때문에 privateKey를 paramater로 넘겨줘야 한다.\n *\n * 사용 예)\n * cav.klay.accounts.signTransaction({\n      to: '0xF0109fC8DF283027b6285cc889F5aA624EaC1F55',\n      value: '1000000000',\n      gas: 2000000,\n      gasPrice: '234567897654321',\n      nonce: 0,\n      chainId: 1\n    }, '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318')\n    .then(console.log);\n    > return 값의 형태\n    {\n      messageHash: '0x6893a6ee8df79b0f5d64a180cd1ef35d030f3e296a5361cf04d02ce720d32ec5',\n      r: '0x9ebb6ca057a0535d6186462bc0b465b561c94a295bdb0621fc19208ab149a9c',\n      s: '0x440ffd775ce91a833ab410777204d5341a6f9fa91216a6f3ee2c051fea6a0428',\n      v: '0x25',\n      rawTransaction: '0xf86a8086d55698372431831e848094f0109fc8df283027b6285cc889f5aa624eac1f55843b9aca008025a009ebb6ca057a0535d6186462bc0b465b561c94a295bdb0621fc19208ab149a9ca0440ffd775ce91a833ab410777204d5341a6f9fa91216a6f3ee2c051fea6a0428'\n    }\n\n    messageHash - String: The hash of the given message.\n    r - String: First 32 bytes of the signature\n    s - String: Next 32 bytes of the signature\n    v - String: Recovery value + 27\n    rawTransaction - String: The RLP encoded transaction, ready to be send using\n */\n\n\nAccounts.prototype.signTransaction = function signTransaction(tx, privateKey, callback) {\n  var _this = this,\n      error = false,\n      result;\n\n  callback = callback || function () {};\n\n  if (!utils.isValidPrivateKey(privateKey)) throw new Error('Invalid private key');\n  privateKey = privateKey.startsWith('0x') ? privateKey : '0x' + privateKey;\n  /**\n   * transaction을 sign하기 위해 사용되는 메서드인데, tx가 없으면,\n   * 당연히 에러를 뱉는다.\n   * callback을 이용해 error를 뱉고, Promise.reject로 error를 담아주어\n   * 후에 .catch로 잡을 수 있게끔 한다.\n   */\n\n  if (!tx) {\n    error = new Error('No transaction object given!');\n    callback(error);\n    return Promise.reject(error);\n  }\n  /**\n   * 본격적으로 transaction sign 하는 함수이다.\n   * 'gas'나 'gasLimit'으로 gas가 설정되어 있지 않다면, 에러를 뱉고,\n   * nonce나 gas, gasPrice, chainId가 음수인 경우는 에러이기 때문에 이 때도 에러를 뱉는다.\n   */\n\n\n  function signed(tx) {\n    if (!tx.senderRawTransaction) {\n      // If `to` field of transaction is missing, it means a contract creation tx.\n      // For contract creation, `data` field should be specified.\n      // @TODO:\n      // UPDATE:\n      // Account Update Tx type doesn't have `to` field and `data` field simultaneously,\n      // So `(!tx.to && !tx.data)` this logic should be ignored.\n      // if (!tx.to && !tx.data) {\n      //   error = new Error('contract creation without any data provided')\n      // }\n      if (!tx.gas && !tx.gasLimit) {\n        error = new Error('\"gas\" is missing');\n      }\n\n      if (tx.nonce < 0 || tx.gas < 0 || tx.gasPrice < 0 || tx.chainId < 0) {\n        error = new Error('Gas, gasPrice, nonce or chainId is lower than 0');\n      } // TODO: restore this code after humanreadable account demo scenario\n      // signed transationc 경우, klaytn devnet 지정된 가스비가 아닐 경우 오류 발생\n      // if (tx.gasPrice != helpers.constants.VALID_GAS_PRICE) {\n      //     error = new Error('GasPrice should be a 25Gpeb(25000000000)');\n      // }\n\n    }\n\n    if (error) {\n      callback(error);\n      return Promise.reject(error);\n    }\n\n    try {\n      // Guarantee all property in transaction is hex.\n      tx = helpers.formatters.inputCallFormatter(tx);\n      const transaction = coverInitialTxValue(tx);\n      const rlpEncoded = encodeRLPByTxType(transaction);\n      const messageHash = Hash.keccak256(rlpEncoded);\n      const signature = Account.makeSigner(Nat.toNumber(transaction.chainId || \"0x1\") * 2 + 35)(messageHash, privateKey);\n\n      const _Account$decodeSignat = Account.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig))),\n            _Account$decodeSignat2 = _slicedToArray(_Account$decodeSignat, 3),\n            v = _Account$decodeSignat2[0],\n            r = _Account$decodeSignat2[1],\n            s = _Account$decodeSignat2[2];\n\n      const rawTransaction = makeRawTransaction(rlpEncoded, [v, r, s], transaction);\n      result = {\n        messageHash: messageHash,\n        v: v,\n        r: r,\n        s: s,\n        rawTransaction: rawTransaction,\n        txHash: Hash.keccak256(rawTransaction)\n      };\n    } catch (e) {\n      callback(e);\n      return Promise.reject(e);\n    }\n\n    callback(null, result);\n    return result;\n  } // Resolve immediately if nonce, chainId and price are provided\n  // nonce, chainId, price가 tx에 들어있다면, 바로 signed 함수를 Promise.resolve로 해서\n  // 후에 .then으로 잡을 수 있게끔 해준다.\n\n\n  if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n    return Promise.resolve(signed(tx));\n  } // Otherwise, get the missing info from the Klaytn Node\n\n  /**\n   * nonce, chainId, gasPrice중 하나라도 정보가 없는 경우에 이 쪽으로 들어오게 되는데,\n   * 없는 항목에 대해서 _klaytnCall 을 통해 가져온다.\n   * 아 이래서, Accounts 모듈에서 getChainId, getGasPrice, getTransactionCount를 메서드로 등록\n   * 했던 것이었구나.\n   */\n\n\n  return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId, isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from || _this.privateKeyToAccount(privateKey).address) : tx.nonce]).then(function (args) {\n    if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n      throw new Error('One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn\\'t be fetched: ' + JSON.stringify(args));\n    } // signed 함수에 tx에 chainId, gasPrice, nonce extend해서 콜한다.\n\n\n    return signed(_.extend(tx, {\n      chainId: args[0],\n      gasPrice: args[1],\n      nonce: args[2]\n    }));\n  });\n};\n\nAccounts.prototype.signTransactionWithSignature = function signTransactionWithSignature(tx, callback) {\n  var _this = this,\n      error = false,\n      result;\n\n  callback = callback || function () {};\n  /**\n   * transaction을 sign하기 위해 사용되는 메서드인데, tx가 없으면,\n   * 당연히 에러를 뱉는다.\n   * callback을 이용해 error를 뱉고, Promise.reject로 error를 담아주어\n   * 후에 .catch로 잡을 수 있게끔 한다.\n   */\n\n\n  if (!tx) {\n    error = new Error('No transaction object given!');\n    callback(error);\n    return Promise.reject(error);\n  }\n\n  if (!tx.signature) {\n    error = new Error('No tx signature given!');\n    callback(error);\n    return Promise.reject(error);\n  }\n  /**\n   * 본격적으로 transaction sign 하는 함수이다.\n   * 'gas'나 'gasLimit'으로 gas가 설정되어 있지 않다면, 에러를 뱉고,\n   * nonce나 gas, gasPrice, chainId가 음수인 경우는 에러이기 때문에 이 때도 에러를 뱉는다.\n   */\n\n\n  function signed(tx) {\n    if (!tx.senderRawTransaction) {\n      if (!tx.gas && !tx.gasLimit) error = new Error('\"gas\" is missing');\n      if (tx.nonce < 0 || tx.gas < 0 || tx.gasPrice < 0 || tx.chainId < 0) error = new Error('Gas, gasPrice, nonce or chainId is lower than 0');\n    }\n\n    if (error) {\n      callback(error);\n      return Promise.reject(error);\n    }\n\n    try {\n      // Guarantee all property in transaction is hex.\n      tx = helpers.formatters.inputCallFormatter(tx);\n      const transaction = coverInitialTxValue(tx);\n      const rlpEncoded = encodeRLPByTxType(transaction);\n      const messageHash = Hash.keccak256(rlpEncoded);\n      let sig;\n\n      if (_.isArray(transaction.signature)) {\n        sig = transaction.signature.map(_sig => utils.resolveSignature(_sig));\n      } else {\n        sig = utils.resolveSignature(transaction.signature);\n      }\n\n      const rawTransaction = makeRawTransaction(rlpEncoded, sig, transaction);\n      result = {\n        messageHash: messageHash,\n        signature: sig,\n        rawTransaction: rawTransaction,\n        txHash: Hash.keccak256(rawTransaction)\n      };\n    } catch (e) {\n      callback(e);\n      return Promise.reject(e);\n    }\n\n    callback(null, result);\n    return result;\n  } // Resolve immediately if nonce, chainId and price are provided\n  // nonce, chainId, price가 tx에 들어있다면, 바로 signed 함수를 Promise.resolve로 해서\n  // 후에 .then으로 잡을 수 있게끔 해준다.\n\n\n  if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n    return Promise.resolve(signed(tx));\n  } // Otherwise, get the missing info from the Klaytn Node\n\n  /**\n   * nonce, chainId, gasPrice중 하나라도 정보가 없는 경우에 이 쪽으로 들어오게 되는데,\n   * 없는 항목에 대해서 _klaytnCall 을 통해 가져온다.\n   * 아 이래서, Accounts 모듈에서 getChainId, getGasPrice, getTransactionCount를 메서드로 등록\n   * 했던 것이었구나.\n   */\n\n\n  return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId, isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from) : tx.nonce]).then(function (args) {\n    if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n      throw new Error('One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn\\'t be fetched: ' + JSON.stringify(args));\n    } // signed 함수에 tx에 chainId, gasPrice, nonce extend해서 콜한다.\n\n\n    return signed(_.extend(tx, {\n      chainId: args[0],\n      gasPrice: args[1],\n      nonce: args[2]\n    }));\n  });\n};\n/**\n * rlpEncode된 rawTransaction을 parameter로 넘겨주고,\n * 이 transaction을 sign한 ethereum address를 리턴해주는 메서드이다.\n *\n * rawTx - String: The RLP encoded transaction.\n *\n * 사용 예 )\n * cav.klay.accounts.recoverTransaction('0xf86180808401ef364594f0109fc8df283027b6285cc889f5aa624eac1f5580801ca031573280d608f75137e33fc14655f097867d691d5c4c44ebe5ae186070ac3d5ea0524410802cdc025034daefcdfa08e7d2ee3f0b9d9ae184b2001fe0aff07603d9');\n * > \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\"\n */\n\n\nAccounts.prototype.recoverTransaction = function recoverTransaction(rawTx) {\n  // encode된 rawTx를 rlp decode해서 풀어준다.\n  var values = RLP.decode(rawTx); // decode해서 풀었으면, [6], [7], [8] 인덱스에 각각 v, r, s가 있는데 얘네를 이용해서\n  // Account 모듈의 encodeSignaute를 이용해서 signature를 만들어준다.\n  // 즉 encode된 rawTx를 decode해서 signature를 빼는게 이 메서드의 핵심과정임.\n\n  var signature = Account.encodeSignature(values.slice(6, 9)); // hex값으로 존재하는 v를 Bytes 모듈의 toNumber 메서드를 이용해서 integer로 바꿔준다.\n  // 앞으로 걔를 recovery 라고 부른다. (즉, recovery란 hex 값의 v를 integer로 바꾼 값.)\n\n  var recovery = Bytes.toNumber(values[6]); // 그렇게 나온 recovery 가 35 보다 작으면 빈 배열(extraData가 없다는 의미),\n  // 35 이상이면 거기서 - 35 하고 >> 1 시프트 연산한 값과,\n  // '0x', '0x' 를 추가적으로 넣어서 총 3개의 아이템이 담긴 배열을 extraData라는 값으로 한다.\n\n  var extraData = recovery < 35 ? [] : [Bytes.fromNumber(recovery - 35 >> 1), \"0x\", \"0x\"]; // signingData는 eztraData values에서 [6], [7], [8]을 붙여준다.\n  // 물론 recovery가 35 이상인 경우만 붙이게 될 것이다. 35 미만이면 extraData가 빈배열이기때문.\n\n  var signingData = values.slice(0, 6).concat(extraData); // 위에서 만든 signingData를 RLP encode한다.\n\n  var signingDataHex = RLP.encode(signingData); // Hash.keccak256(signingDataHex) 는 즉, rlp encode된 애를 keccak256을 돌린애다, 즉 위에서 본 hash임\n  // 걔를 signature와 같이 Account 모듈의 recover 메서드로 넘기면 이 transaction을 sign한\n  // address를 추출해낼수 있다.\n\n  return Account.recover(Hash.keccak256(signingDataHex), signature);\n};\n/**\n * Hashes the given message to be passed cav.klay.accounts.recover() function.\n * The data will be UTF-8 HEX decoded and enveloped as follows:\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message and hashed using keccak256.\n *\n * cav.klay.accounts.hashMessage(\"Hello World\")\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\n * // the below results in the same hash\n * cav.klay.accounts.hashMessage(caver.utils.utf8ToHex(\"Hello World\"))\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\n */\n\n\nAccounts.prototype.hashMessage = function hashMessage(data) {\n  const message = utils.isHexStrict(data) ? utils.hexToBytes(data) : data;\n  const messageBuffer = Buffer.from(message);\n  const preamble = \"\\x19Klaytn Signed Message:\\n\" + message.length;\n  const preambleBuffer = Buffer.from(preamble); // klayMessage is concatenated buffer (preambleBuffer + messageBuffer)\n\n  const klayMessage = Buffer.concat([preambleBuffer, messageBuffer]); // Finally, run keccak256 on klayMessage.\n\n  return Hash.keccak256(klayMessage);\n};\n/**\n * Signs arbitrary data.\n * This data is before UTF-8 HEX decoded and enveloped as follows:\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message.\n *\n * 사용 예)\n * cav.klay.accounts.sign('Some data', '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\n * > {\n *     message: 'Some data',\n *     messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\n *     v: '0x1c',\n *     r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',\n *     s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',\n *     signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'\n *   }\n */\n\n\nAccounts.prototype.sign = function sign(data, privateKey) {\n  if (!utils.isValidPrivateKey(privateKey)) throw new Error('Invalid private key');\n  const messageHash = this.hashMessage(data);\n  /**\n   * 외부모듈 Account의 makeSigner(27)을 해준 게 Account.sign이다\n   * makeSigner => addToV => (messageHash, privateKey) => { ... }\n   * addToV라는 parameter는 말그대로 'V에 더해줄 값' 이라 생각하면 될 듯.\n   * const sign = makeSigner(27); // v=27|28 instead of 0|1...\n   */\n\n  const signature = Account.sign(messageHash, privateKey);\n  /**\n   * 바로 윗 라인에서 한 Account.sign이 return encodeSignature(...)으로 끝나는 함수이기 때문에\n   * 결국 여기서 v, r, s를 빼내려면 decode를 해야한다.\n   * decodeSignature 형태\n   * const decodeSignature = hex => [Bytes.slice(64, Bytes.length(hex), hex), Bytes.slice(0, 32, hex), Bytes.slice(32, 64, hex)];\n   * Bytes.slice로 64 ~ 끝까지 끊은걸 v\n   * Bytes.slice로 0 ~ 32까지 끊은걸 r\n   * Bytes.slice로 32 ~ 64까지 끊은걸 s\n   */\n\n  const _Account$decodeSignat3 = Account.decodeSignature(signature),\n        _Account$decodeSignat4 = _slicedToArray(_Account$decodeSignat3, 3),\n        v = _Account$decodeSignat4[0],\n        r = _Account$decodeSignat4[1],\n        s = _Account$decodeSignat4[2];\n\n  return {\n    message: data,\n    messageHash,\n    v,\n    r,\n    s,\n    signature\n  };\n};\n/**\n * preFixed - Boolean (optional, default: false):\n * If the last parameter is true,\n * the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message,\n * and assumed to be already prefixed.\n */\n\n\nAccounts.prototype.recover = function recover(message, signature, preFixed) {\n  var args = [].slice.apply(arguments);\n  /**\n   * paramater를 object 형태로 받을 수 있다.\n   * object 형태로 들어오면 this(Accounts) 모듈에 있는 recover를 사용한다. (재귀)\n   * Assume message already prefixed, when `message` parameter type is object.\n   */\n\n  if (_.isObject(message)) {\n    return this.recover(message.messageHash, Account.encodeSignature([message.v, message.r, message.s]), true);\n  } // prefixed는 기본적으로 false가 기본이다. prefixed가 따로 설정되어 있지 않으면\n  // \"\\x19Klaytn Signed Message:\\n\" + message.length + message 를 붙여주고\n  // keccak256 돌리는 this.hashMessage로 들어가게 된다.\n\n\n  if (!preFixed) {\n    message = this.hashMessage(message);\n  }\n  /**\n   * signature를 하나로 던지는게 아니라, v, r, s로 나누어서 던질 때\n   * message, v, r, s\n   * cav.klay.accounts.recover('Some data', '0x1c', '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd', '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029');\n   * > \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\"\n   */\n\n\n  if (args.length >= 4) {\n    // 마지막 인자 뽑는 방법. args.slice(-1)[0]\n    preFixed = args.slice(-1)[0]; // preFixed가 따로 parameter로 넘어왔다면 boolean 값일 것이기 때문에, !!preFixed로 넘기고,\n    // 그게 boolean이 아니라면 parameter로 넘어오지않았다는 말이기 때문에 default 값인 false로.\n\n    preFixed = _.isBoolean(preFixed) ? !!preFixed : false; // parameter가 message, v, r, s 형태로 들어오면 this(Accounts)에 있는 recover를 사용한다.(결국 재귀)\n\n    return this.recover(message, Account.encodeSignature(args.slice(1, 4)), preFixed); // v, r, s\n  } // message, signature로 들어왔을 때 Account 모듈의 recover 사용.\n\n  /**\n   * Account 모듈의 recover\n   * const recover = (hash, signature) => {\n   *   const vals = decodeSignature(signature);\n   *   const vrs = { v: Bytes.toNumber(vals[0]), r: vals[1].slice(2), s: vals[2].slice(2) };\n   *   const ecPublicKey = secp256k1.recoverPubKey(new Buffer(hash.slice(2), \"hex\"), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n   *   const publicKey = \"0x\" + ecPublicKey.encode(\"hex\", false).slice(2);\n   *   const publicHash = keccak256(publicKey);\n   *   const address = toChecksum(\"0x\" + publicHash.slice(-40));\n   *   return address;\n   * };\n   */\n\n\n  return Account.recover(message, signature);\n}; // Taken from https://github.com/ethereumjs/ethereumjs-wallet\n\n\nAccounts.prototype.decrypt = function (v3Keystore, password, nonStrict) {\n  if (!_.isString(password)) {\n    throw new Error('No password given.');\n  }\n  /**\n   * v3KeyStore parameter가 object로 바로 들어오면 그대로 가져다 쓰되,\n   * JSON 으로 싸져있으면 parse해서 꺼내서 쓴다.\n   */\n\n\n  var json = _.isObject(v3Keystore) ? v3Keystore : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore); // keyStore version이 3인 경우에만 지원한다.\n\n  if (json.version !== 3) {\n    console.warn('This is not a V3 wallet.'); // throw new Error('Not a valid V3 wallet');\n  }\n\n  var derivedKey;\n  var kdfparams;\n  /**\n   * 지원하는 kdf은 단 두 개\n   * 1) pbkdf2\n   * 2) scrypt\n   */\n\n  if (json.crypto.kdf === 'scrypt') {\n    kdfparams = json.crypto.kdfparams; // FIXME: support progress reporting callback\n\n    derivedKey = scryptsy(new Buffer(password), new Buffer(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n  } else if (json.crypto.kdf === 'pbkdf2') {\n    kdfparams = json.crypto.kdfparams;\n\n    if (kdfparams.prf !== 'hmac-sha256') {\n      throw new Error('Unsupported parameters to PBKDF2');\n    }\n\n    derivedKey = cryp.pbkdf2Sync(new Buffer(password), new Buffer(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n  } else {\n    throw new Error('Unsupported key derivation scheme');\n  }\n  /**\n   * ciphertext를 byte화\n   */\n\n\n  var ciphertext = new Buffer(json.crypto.ciphertext, 'hex');\n  /**\n   * mac은\n   * 1) derivedKey를 index 16부터 16자리 짜르고,\n   * 2) ciphertext concat하고\n   * 3) '0x' 스트링 제거\n   * 4) keccak256 돌린\n   * 값이다. (결국 위에서 만든 derivedKey와 json으로 가져온 ciphertext만으로 만들 수 있는 값임.)\n   * json.crypto.mac에 붙어있었던 값과 derivedKey, ciphertext을 통해서 새로 만든 mac값과 비교했을 때\n   * 같은 값이면, password가 올바르다고 생각할 수 있음.\n   */\n\n  var mac = utils.sha3(Buffer.concat([derivedKey.slice(16, 32), ciphertext])).replace('0x', '');\n\n  if (mac !== json.crypto.mac) {\n    throw new Error('Key derivation failed - possibly wrong password');\n  }\n\n  var decipher = cryp.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), new Buffer(json.crypto.cipherparams.iv, 'hex'));\n  var seed = '0x' + Buffer.concat([decipher.update(ciphertext), decipher.final()]).toString('hex');\n  return this.privateKeyToAccount(seed);\n};\n/**\n * Encrypts a private key to the web3 keystore v3 standard.\n * private key를 password를 이용해 encrypt하는 메서드이다.\n * cav.klay.accounts.encrypt(privateKey, password);\n * cav.klay.accounts.encrypt('0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318', 'test!')\n    > {\n        version: 3,\n        id: '04e9bcbb-96fa-497b-94d1-14df4cd20af6',\n        address: '2c7536e3605d9c16a7a3d7b1898e529396a65c23',\n        crypto: {\n            ciphertext: 'a1c25da3ecde4e6a24f3697251dd15d6208520efc84ad97397e906e6df24d251',\n            cipherparams: { iv: '2885df2b63f7ef247d753c82fa20038a' },\n            cipher: 'aes-128-ctr',\n            kdf: 'scrypt',\n            kdfparams: {\n                dklen: 32,\n                salt: '4531b3c174cc3ff32a6a7a85d6761b410db674807b2d216d022318ceee50be10',\n                n: 262144,\n                r: 8,\n                p: 1\n            },\n            mac: 'b8b010fff37f9ae5559a352a185e86f9b9c1d7f7a9f1bd4e82a5dd35468fc7f6'\n        }\n    }\n\n    `dklen` is the desired length of the derived key\n    `salt` - A string of characters that modifies the hash to protect against Rainbow table attacks\n    `n` - CPU/memory cost parameter\n    `r` - The blocksize parameter, which fine-tunes sequential memory read size and performance. 8 is commonly used.\n    `p` - Parallelization parameter\n    `c` - the number of iterations desired\n\n    geth 상위 디렉터리에 있는 keystore 파일이 생긴 형태와 동일하다.\n    {\n      \"address\":\"9e1023dbce2d6304f5011a4db56a8ed7ba271650\",\n      \"crypto\":{\"cipher\":\"aes-128-ctr\",\n      \"ciphertext\":\"0f1158156a26e5135e107522639bb2b549acf159a12097c02fc2d73b97841000\",\n      \"version\":3,\n      \"cipherparams\":{\"iv\":\"e15c86e8797c37bffd2ebfa68a532595\"},\n      \"kdf\":\"scrypt\",\n      \"kdfparams\":{\n        \"dklen\":32,\n        \"n\":262144,\n        \"p\":1,\n        \"r\":8,\n        \"salt\":\"e7c4605ad8200e0d93cd67f9d82fb9971e1a2763b22362017c2927231c2a733a\"\n      },\n      \"mac\":\"d2ad144ef6060ac01d711d691ff56e11d4deffc85a08de0dde27c28c23959251\"},\n      \"id\":\"dfde6a32-4b0e-404f-8b9f-2b18f279fe21\",\n    }\n */\n\n\nAccounts.prototype.encrypt = function (privateKey, password, options) {\n  if (!utils.isValidPrivateKey(privateKey)) throw new Error('Invalid private key');\n  var account = this.privateKeyToAccount(privateKey);\n  /**\n   * options에\n   * {\n   *   salt: ...,\n   *   iv: ...,\n   *   kdf: ...,\n   *   dklen: ...,\n   *   c: ...,\n   *   n: ...,\n   *   r: ...,\n   *   p: ...,\n   *   cipher: ...,\n   *   uuid: ...,\n   *   cipher: ...,\n   * }\n   * 이런 것들을 넣을 수 있는데, keystore에 들어가는 것을 특정한 값으로 강제해줄 수 있다.\n   */\n\n  options = options || {};\n  var salt = options.salt || cryp.randomBytes(32);\n  var iv = options.iv || cryp.randomBytes(16);\n  var derivedKey;\n  var kdf = options.kdf || 'scrypt';\n  var kdfparams = {\n    dklen: options.dklen || 32,\n    salt: salt.toString('hex')\n  };\n  /**\n   * kdf 종류는 딱 두개만 지원한다. (derivedkey를 얻는 방식)\n   * 1) pbkdf2\n   * 2) scrypt - scrypt가 기본값이다.\n   */\n\n  if (kdf === 'pbkdf2') {\n    kdfparams.c = options.c || 262144;\n    kdfparams.prf = 'hmac-sha256';\n    derivedKey = cryp.pbkdf2Sync(new Buffer(password), salt, kdfparams.c, kdfparams.dklen, 'sha256');\n  } else if (kdf === 'scrypt') {\n    // FIXME: support progress reporting callback\n    kdfparams.n = options.n || 4096; // 2048 4096 8192 16384\n\n    kdfparams.r = options.r || 8;\n    kdfparams.p = options.p || 1;\n    derivedKey = scryptsy(new Buffer(password), salt, kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n  } else {\n    throw new Error('Unsupported kdf');\n  }\n\n  var cipher = cryp.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);\n\n  if (!cipher) {\n    throw new Error('Unsupported cipher');\n  }\n\n  var ciphertext = Buffer.concat([cipher.update(new Buffer(account.privateKey.replace('0x', ''), 'hex')), cipher.final()]);\n  var mac = utils.sha3(Buffer.concat([derivedKey.slice(16, 32), new Buffer(ciphertext, 'hex')])).replace('0x', '');\n  return {\n    version: 3,\n    id: uuid.v4({\n      random: options.uuid || cryp.randomBytes(16)\n    }),\n    address: account.address.toLowerCase().replace('0x', ''),\n    crypto: {\n      ciphertext: ciphertext.toString('hex'),\n      cipherparams: {\n        iv: iv.toString('hex')\n      },\n      cipher: options.cipher || 'aes-128-ctr',\n      kdf: kdf,\n      kdfparams: kdfparams,\n      mac: mac.toString('hex')\n    }\n  };\n};\n\nAccounts.prototype.privateKeyToPublicKey = function (privateKey) {\n  const buffer = new Buffer(privateKey.slice(2), \"hex\");\n  const ecKey = secp256k1.keyFromPrivate(buffer);\n  const publicKey = \"0x\" + ecKey.getPublic(false, 'hex').slice(2);\n  return publicKey;\n};\n\nAccounts.prototype.encodeRLPByTxType = encodeRLPByTxType;\n\nAccounts.prototype.setAccounts = function (accounts) {\n  this.wallet.clear();\n\n  for (let i = 0; i < accounts.wallet.length; i++) {\n    this.wallet.add(accounts.wallet[i]);\n  }\n\n  return this;\n};\n/* eslint-enable complexity */\n// Note: this is trying to follow closely the specs on\n\n/**\n * Account 모듈의 this.wallet으로 들어가는 Wallet 모듈.\n * 특이하게 Account 모듈은 Wallet 모듈의 this._accounts로 들어간다.\n *\n * cav.klay.accounts.wallet 이런식으로 가져올 수 있는데,\n    > Wallet {\n        0: {...}, // account by index\n        \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},  // same account by address\n        \"0xf0109fc8df283027b6285cc889f5aa624eac1f55\": {...},  // same account by address lowercase\n        1: {...},\n        \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...},\n        \"0xd0122fc8df283027b6285cc889f5aa624eac1d23\": {...},\n\n        add: function(){},\n        remove: function(){},\n        save: function(){},\n        load: function(){},\n        clear: function(){},\n\n        length: 2,\n    }\n *\n * Contains an in memory wallet with multiple accounts.\n * These accounts can be used when using cav.klay.sendTransaction().\n * @todo length는 내가 memory에 가지고 있는 account들의 갯수인가?\n * @todo defaultKeyName은 뭐지?\n */\n\n\nfunction Wallet(accounts) {\n  this._accounts = accounts;\n  this.length = 0;\n  this.defaultKeyName = \"caverjs_wallet\";\n}\n/**\n * 결국 wallet instance에 account붙일 index찾는 메서드인데,\n * recursion을 이용해 pointer 0부터 찾는다.\n */\n\n\nWallet.prototype._findSafeIndex = function (pointer) {\n  pointer = pointer || 0;\n\n  if (_.has(this, pointer)) {\n    return this._findSafeIndex(pointer + 1);\n  } else {\n    return pointer;\n  }\n};\n/**\n * Wallet instance에 붙어있는 object의 key들을 다 가져온다음에,\n * map으로 parseInt 멕여주고,\n * filter로 9e20 미만인 애들만 뽑아준다.\n * @todo int로 9e20이 900000000000000000000 인데 이게 뭘까\n */\n\n\nWallet.prototype._currentIndexes = function () {\n  var keys = Object.keys(this);\n  var indexes = keys.map(function (key) {\n    return parseInt(key);\n  }).filter(function (n) {\n    return n < 9e20;\n  });\n  return indexes;\n};\n/**\n * Generates one or more accounts in the wallet.\n * If wallets already exist they will not be overridden.\n * Account 모듈의 create 메서드를 이용해서 privateKey를 쏙 빼주고,\n * 그것을 Wallet 모듈의 add 메서드로 넘긴다.\n * 즉, Wallet 모듈의 add 메서드는 privateKey를 직접적으로 받는 메서드인 것이다.\n */\n\n\nWallet.prototype.create = function (numberOfAccounts, entropy) {\n  for (var i = 0; i < numberOfAccounts; ++i) {\n    this.add(this._accounts.create(entropy).privateKey);\n  }\n\n  return this;\n};\n/**\n * Adds an account using a private key or account object to the wallet.\n *\n * 사용 예 )\n * cav.klay.accounts.wallet.add({\n    privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n    address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\n    });\n    > {\n        index: 0,\n        address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\n        privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n        signTransaction: function(tx){...},\n        sign: function(data){...},\n        encrypt: function(password){...}\n    }\n * 결국 wallet.add라는 작업은, privateKey만 혹은 address까지 같이 있을 때,\n * 그 object에 index, sign, signTransaction, encrypt 붙여준뒤에\n * wallet instance에서 찾을 수 있게 indexing해주는 것이다.\n */\n\n\nWallet.prototype.add = function (account, targetAddressRaw) {\n  /**\n   * account parameter가 올 수 있는 형태 1) privateKey string 단독으로 오는 경우.\n   * 예) cav.klay.accounts.wallet.add('0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\n   */\n  if (_.isString(account)) {\n    account = this._accounts.privateKeyToAccount(account);\n  }\n  /**\n   * account parameter 가 올 수 있는 형태 2) privateKey, address 같이 달린 object로 오는 경우.\n   * cav.klay.accounts.wallet.add({\n   *   privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n   *   address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\n   * });\n   *\n   * 만약 Wallet instance에 account.address가 안붙어 있으면\n   * _findSafeIndex 통해서\n   * this[account.index]에도 붙이고,\n   * this[account.address]에도 붙이고,\n   * this[account.address.toLowerCase()]에도 붙여준다.\n   * 총 account를 조회할 수 있는 방법이 세 가지 인 것.\n   */\n\n\n  if (targetAddressRaw) {\n    // utils.humanReadableStringToHexAddress('toshi') === '0x746f736869000000000000000000000000000000'\n    const isHumanReadable = targetAddressRaw.indexOf('0x') === -1;\n    account.address = isHumanReadable ? utils.humanReadableStringToHexAddress(targetAddressRaw) : targetAddressRaw;\n    const accountAlreadyExists = !!this[account.address];\n    if (accountAlreadyExists) return this[account.address];\n    account.index = this._findSafeIndex();\n    this[account.index] = account;\n    this[targetAddressRaw] = account; // this['toshi']\n\n    this[account.address] = account; // this['0x746f736869000000000000000000000000000000']\n\n    this[account.address.toLowerCase()] = account;\n    this.length++;\n  } else {\n    const accountAlreadyExists = !!this[account.address];\n    if (accountAlreadyExists) return this[account.address];\n    account = this._accounts.privateKeyToAccount(account.privateKey);\n    account.index = this._findSafeIndex();\n    this[account.index] = account;\n    this[account.address] = account;\n    this[account.address.toLowerCase()] = account;\n    this.length++;\n    return account;\n  }\n};\n/**\n * Wallet instance에 있는 account는 add될 때,\n * address를 key로도 달리고,\n * index를 key로도 달리기 때문에, 그거 참조해서 delete를 통해 안에 property들 삭제해주고\n * length도 하나 깎아준다.\n * privateKey를 다 null처리.\n */\n\n\nWallet.prototype.remove = function (addressOrIndex) {\n  var account = this[addressOrIndex];\n\n  if (account && account.address) {\n    try {\n      // humanreadable string\n      const humanReadableString = utils.hexToUtf8(account.address);\n\n      if (this[humanReadableString]) {\n        this[humanReadableString].privateKey = null;\n        delete this[humanReadableString];\n      }\n    } catch (e) {} // address\n\n\n    this[account.address].privateKey = null;\n    delete this[account.address];\n\n    if (this[account.address.toLowerCase()]) {\n      // address lowercase\n      this[account.address.toLowerCase()].privateKey = null;\n      delete this[account.address.toLowerCase()];\n    } // index\n\n\n    this[account.index].privateKey = null;\n    delete this[account.index];\n    this.length--;\n    return true;\n  } else {\n    return false;\n  }\n};\n/**\n * 특정 address나 index에 있는 account만 지우는게 아니라 모조리 날리고 싶을 때\n * indexes를 돌면서 _this.remove 콜.\n */\n\n\nWallet.prototype.clear = function () {\n  var _this = this;\n\n  var indexes = this._currentIndexes();\n\n  indexes.forEach(function (index) {\n    _this.remove(index);\n  });\n  return this;\n};\n/**\n * Wallet instance에 달려있는 모든 account들 password로 encrypt\n * 여기 _this[index].encrypt는 Wallet instance의 encrypt가 아니라,\n * _addAccountFunctions 돌리면서 붙은 그 encrypt 이다. (kdf 나오는 진짜 코어의 그것.)\n * account.encrypt = function encrypt(password, options) {\n *   return _this.encrypt(account.privateKey, password, options);\n * };\n *\n * 사용 예)\n * cav.klay.accounts.wallet.encrypt('test');\n    > [ { version: 3,\n        id: 'dcf8ab05-a314-4e37-b972-bf9b86f91372',\n        address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\n        crypto:\n         { ciphertext: '0de804dc63940820f6b3334e5a4bfc8214e27fb30bb7e9b7b74b25cd7eb5c604',\n           cipherparams: [Object],\n           cipher: 'aes-128-ctr',\n           kdf: 'scrypt',\n           kdfparams: [Object],\n           mac: 'b2aac1485bd6ee1928665642bf8eae9ddfbc039c3a673658933d320bac6952e3' } },\n      { version: 3,\n        id: '9e1c7d24-b919-4428-b10e-0f3ef79f7cf0',\n        address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\n        crypto:\n         { ciphertext: 'd705ebed2a136d9e4db7e5ae70ed1f69d6a57370d5fbe06281eb07615f404410',\n           cipherparams: [Object],\n           cipher: 'aes-128-ctr',\n           kdf: 'scrypt',\n           kdfparams: [Object],\n           mac: 'af9eca5eb01b0f70e909f824f0e7cdb90c350a802f04a9f6afe056602b92272b' } }\n    ]\n */\n\n\nWallet.prototype.encrypt = function (password, options) {\n  var _this = this;\n\n  var indexes = this._currentIndexes();\n\n  var accounts = indexes.map(function (index) {\n    return _this[index].encrypt(password, options);\n  });\n  return accounts;\n};\n/**\n * Decrypts keystore v3 objects.\n * keystore array를 돌면서 decrypt한다.\n * 사용 예)\n * cav.klay.accounts.wallet.decrypt([\n    { version: 3,\n    id: '83191a81-aaca-451f-b63d-0c5f3b849289',\n    address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\n    crypto:\n     { ciphertext: '7d34deae112841fba86e3e6cf08f5398dda323a8e4d29332621534e2c4069e8d',\n       cipherparams: { iv: '497f4d26997a84d570778eae874b2333' },\n       cipher: 'aes-128-ctr',\n       kdf: 'scrypt',\n       kdfparams:\n        { dklen: 32,\n          salt: '208dd732a27aa4803bb760228dff18515d5313fd085bbce60594a3919ae2d88d',\n          n: 262144,\n          r: 8,\n          p: 1 },\n       mac: '0062a853de302513c57bfe3108ab493733034bf3cb313326f42cf26ea2619cf9' } },\n     { version: 3,\n    id: '7d6b91fa-3611-407b-b16b-396efb28f97e',\n    address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\n    crypto:\n     { ciphertext: 'cb9712d1982ff89f571fa5dbef447f14b7e5f142232bd2a913aac833730eeb43',\n       cipherparams: { iv: '8cccb91cb84e435437f7282ec2ffd2db' },\n       cipher: 'aes-128-ctr',\n       kdf: 'scrypt',\n       kdfparams:\n        { dklen: 32,\n          salt: '08ba6736363c5586434cd5b895e6fe41ea7db4785bd9b901dedce77a1514e8b8',\n          n: 262144,\n          r: 8,\n          p: 1 },\n       mac: 'd2eb068b37e2df55f56fa97a2bf4f55e072bef0dd703bfd917717d9dc54510f0' } }\n  ], 'test');\n  > Wallet {\n      0: {...},\n      1: {...},\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\n      ...\n  }\n */\n\n\nWallet.prototype.decrypt = function (encryptedWallet, password) {\n  var _this = this; // forEach로 keystore object 하나씩 돌면서 _this.add로 wallet instance에 추가해줌.\n\n\n  encryptedWallet.forEach(function (keystore) {\n    var account = _this._accounts.decrypt(keystore, password);\n\n    if (account) {\n      _this.add(account);\n    } else {\n      throw new Error('Couldn\\'t decrypt accounts. Password wrong?');\n    }\n  });\n  return this;\n};\n/**\n * 아직 encrypt되지 않은 password와 keyName을 parameter로 받는데,\n * localStorage에 keyName과 password를 encrypt해서 저장한다.\n * 당연히 localStorage를 쓰기 때문에 Browser Only이다.\n *\n * 여기서 keyName은 위에서 봤던 \"web3js_wallet\"가 default로 지정되어있던 그것이다.\n * \"web3js_wallet\"가 default기 때문에, keyName은 optional한 parameter이다.\n * 즉, cav.klay.accounts.wallet.save('test#!$') 이렇게 호출해도 상관 없다.\n * this.encrypt는 Account들 encrypt한 정보, 즉 keystore에 들어가는 정보들을 encrypt한다.\n */\n\n\nWallet.prototype.save = function (password, keyName) {\n  localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encrypt(password)));\n  return true;\n};\n/**\n * localStorage에서 keyName 기준으로 가져오는 메서드이다.\n * @todo 근데 뭘 decrypt하는거지? parameter로 password가 오는데?\n * => keystore에 있던 Account를 decrypt하는 것이었다.\n *\n * 사용 예)\n * cav.klay.accounts.wallet.load('test#!$', 'myWalletKey' || 'web3js_wallet');\n    > Wallet {\n        0: {...},\n        1: {...},\n        \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\n        \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\n        ...\n    }\n */\n\n\nWallet.prototype.load = function (password, keyName) {\n  var keystore = localStorage.getItem(keyName || this.defaultKeyName);\n\n  if (keystore) {\n    try {\n      keystore = JSON.parse(keystore);\n    } catch (e) {}\n  }\n\n  return this.decrypt(keystore || [], password);\n};\n/**\n * localStorage가 없다는 것은 browser 환경에서 불러지지 않았다는 뜻이기 때문에,\n * save, load가 실질적으로 기능을 못한다. 따라서 삭제해준다.\n */\n\n\nif (typeof localStorage === 'undefined') {\n  delete Wallet.prototype.save;\n  delete Wallet.prototype.load;\n}\n\nmodule.exports = Accounts;","map":null,"metadata":{},"sourceType":"script"}