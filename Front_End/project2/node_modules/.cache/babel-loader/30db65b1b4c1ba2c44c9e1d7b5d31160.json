{"ast":null,"code":"/*\n    Copyright 2018 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst RLP = require('eth-lib/lib/rlp');\n\nconst Hash = require('eth-lib/lib/hash');\n\nconst utils = require('../../../caver-utils');\n\nconst {\n  rlpEncodeForLegacyTransaction,\n  rlpEncodeForValueTransfer,\n  rlpEncodeForValueTransferMemo,\n  rlpEncodeForFeeDelegatedValueTransferMemoWithRatio,\n  rlpEncodeForFeeDelegatedValueTransfer,\n  rlpEncodeForFeeDelegatedValueTransferWithRatio,\n  rlpEncodeForFeeDelegatedValueTransferMemo,\n  rlpEncodeForAccountUpdate,\n  rlpEncodeForContractDeploy,\n  rlpEncodeForContractExecution,\n  rlpEncodeForFeeDelegatedAccountUpdate,\n  rlpEncodeForFeeDelegatedAccountUpdateWithRatio,\n  rlpEncodeForFeeDelegatedSmartContractDeploy,\n  rlpEncodeForFeeDelegatedSmartContractDeployWithRatio,\n  rlpEncodeForFeeDelegatedSmartContractExecution,\n  rlpEncodeForFeeDelegatedSmartContractExecutionWithRatio,\n  rlpEncodeForCancel,\n  rlpEncodeForFeeDelegatedCancel,\n  rlpEncodeForFeeDelegatedCancelWithRatio,\n  rlpEncodeForChainDataAnchoring,\n  parseAccountKey\n} = require('./transactionType');\n\nconst creationNotSupportError = 'ACCOUNT_CREATION transaction type is not supported yet.';\n\nfunction encodeRLPByTxType(transaction) {\n  transaction.type = transaction.senderRawTransaction ? utils.getTxTypeStringFromRawTransaction(transaction.senderRawTransaction) : transaction.type;\n\n  switch (transaction.type) {\n    case 'ACCOUNT_CREATION':\n      throw new Error(creationNotSupportError);\n\n    case 'ACCOUNT_UPDATE':\n      return rlpEncodeForAccountUpdate(transaction);\n\n    case 'FEE_DELEGATED_ACCOUNT_UPDATE':\n      return rlpEncodeForFeeDelegatedAccountUpdate(transaction);\n\n    case 'FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO':\n      return rlpEncodeForFeeDelegatedAccountUpdateWithRatio(transaction);\n\n    case 'VALUE_TRANSFER':\n      return rlpEncodeForValueTransfer(transaction);\n\n    case 'VALUE_TRANSFER_MEMO':\n      return rlpEncodeForValueTransferMemo(transaction);\n\n    case 'FEE_DELEGATED_VALUE_TRANSFER':\n      return rlpEncodeForFeeDelegatedValueTransfer(transaction);\n\n    case 'FEE_DELEGATED_VALUE_TRANSFER_WITH_RATIO':\n      return rlpEncodeForFeeDelegatedValueTransferWithRatio(transaction);\n\n    case 'FEE_DELEGATED_VALUE_TRANSFER_MEMO':\n      return rlpEncodeForFeeDelegatedValueTransferMemo(transaction);\n\n    case 'FEE_DELEGATED_VALUE_TRANSFER_MEMO_WITH_RATIO':\n      return rlpEncodeForFeeDelegatedValueTransferMemoWithRatio(transaction);\n\n    case 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY':\n      return rlpEncodeForFeeDelegatedSmartContractDeploy(transaction);\n\n    case 'SMART_CONTRACT_DEPLOY':\n      return rlpEncodeForContractDeploy(transaction);\n\n    case 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY_WITH_RATIO':\n      return rlpEncodeForFeeDelegatedSmartContractDeployWithRatio(transaction);\n\n    case 'SMART_CONTRACT_EXECUTION':\n      return rlpEncodeForContractExecution(transaction);\n\n    case 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION':\n      return rlpEncodeForFeeDelegatedSmartContractExecution(transaction);\n\n    case 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION_WITH_RATIO':\n      return rlpEncodeForFeeDelegatedSmartContractExecutionWithRatio(transaction);\n\n    case 'CANCEL':\n      return rlpEncodeForCancel(transaction);\n\n    case 'FEE_DELEGATED_CANCEL':\n      return rlpEncodeForFeeDelegatedCancel(transaction);\n\n    case 'FEE_DELEGATED_CANCEL_WITH_RATIO':\n      return rlpEncodeForFeeDelegatedCancelWithRatio(transaction);\n\n    case 'CHAIN_DATA_ANCHORING':\n      return rlpEncodeForChainDataAnchoring(transaction);\n\n    case 'LEGACY':\n    default:\n      return rlpEncodeForLegacyTransaction(transaction);\n  }\n} // case1) sig === [v, r, s]\n// case2) sig ===\n\n\nfunction makeRawTransaction(rlpEncoded, sig, transaction) {\n  const decodedValues = RLP.decode(rlpEncoded);\n  let rawTx;\n  transaction.type = transaction.senderRawTransaction ? utils.getTxTypeStringFromRawTransaction(transaction.senderRawTransaction) : transaction.type;\n\n  switch (transaction.type) {\n    case 'ACCOUNT_CREATION':\n      throw new Error(creationNotSupportError);\n\n    case 'VALUE_TRANSFER':\n    case 'VALUE_TRANSFER_MEMO':\n    case 'ACCOUNT_UPDATE':\n    case 'SMART_CONTRACT_DEPLOY':\n    case 'SMART_CONTRACT_EXECUTION':\n    case 'CANCEL':\n    case 'CHAIN_DATA_ANCHORING':\n      return _combineSenderRawTransaction(rlpEncoded, sig);\n\n    case 'FEE_DELEGATED_VALUE_TRANSFER':\n    case 'FEE_DELEGATED_VALUE_TRANSFER_WITH_RATIO':\n    case 'FEE_DELEGATED_VALUE_TRANSFER_MEMO':\n    case 'FEE_DELEGATED_VALUE_TRANSFER_MEMO_WITH_RATIO':\n    case 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY':\n    case 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY_WITH_RATIO':\n    case 'FEE_DELEGATED_CANCEL':\n    case 'FEE_DELEGATED_CANCEL_WITH_RATIO':\n    case 'FEE_DELEGATED_ACCOUNT_UPDATE':\n    case 'FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO':\n    case 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION':\n    case 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION_WITH_RATIO':\n      {\n        if (transaction.senderRawTransaction) {\n          const decoded = decodeFromRawTransaction(transaction.senderRawTransaction);\n          return _combineFeePayerRawTransaction(rlpEncoded, sig, transaction, decoded.signatures);\n        }\n\n        if (transaction.feePayer && transaction.feePayer !== '0x' && transaction.feePayerSignatures) {\n          return _combineFeePayerRawTransaction(rlpEncoded, transaction.feePayerSignatures, transaction, sig);\n        }\n\n        return _combineSenderRawTransaction(rlpEncoded, sig);\n      }\n\n    case 'LEGACY':\n    default:\n      rawTx = decodedValues.slice(0, 6).concat(sig[0]);\n      return {\n        rawTransaction: RLP.encode(rawTx),\n        signatures: sig[0],\n        feePayerSignatures: undefined\n      };\n  }\n}\n\nfunction _combineSenderRawTransaction(rlpEncoded, sig) {\n  const decodedValues = RLP.decode(rlpEncoded);\n  const [data] = decodedValues;\n  let [txType, ...rawTx] = RLP.decode(data);\n  if (!Array.isArray(sig[0])) sig = [sig];\n  sig = refineSignatures(sig);\n  rawTx = [...rawTx, sig]; // set default feepayer's information in rawTx\n\n  const typeString = utils.getTxTypeStringFromRawTransaction(txType);\n  if (typeString !== undefined && typeString.includes('FEE_DELEGATED')) rawTx = [...rawTx, '0x', [['0x01', '0x', '0x']]];\n  return {\n    rawTransaction: txType + RLP.encode(rawTx).slice(2),\n    signatures: sig,\n    feePayerSignatures: undefined\n  };\n}\n\nfunction _combineFeePayerRawTransaction(rlpEncoded, feePayerSignatures, transaction, senderSignature) {\n  const decodedValues = RLP.decode(rlpEncoded);\n  const [data] = decodedValues;\n  let [txType, ...rawTx] = RLP.decode(data);\n  if (!Array.isArray(feePayerSignatures[0])) feePayerSignatures = [feePayerSignatures];\n  senderSignature = refineSignatures(senderSignature);\n  feePayerSignatures = refineSignatures(feePayerSignatures);\n  rawTx = [...rawTx, senderSignature, transaction.feePayer.toLowerCase(), feePayerSignatures];\n  return {\n    rawTransaction: txType + RLP.encode(rawTx).slice(2),\n    signatures: senderSignature,\n    feePayerSignatures\n  };\n} // refineSignatures removes duplication and empty signatures\n\n\nfunction refineSignatures(sigArray) {\n  const set = new Set();\n  let result = [];\n\n  for (const sig of sigArray) {\n    if (sig.length > 0 && !utils.isEmptySig(sig)) {\n      const sigString = sig.join('');\n\n      if (!set.has(sigString)) {\n        set.add(sigString, true);\n        result.push(sig);\n      }\n    }\n  }\n\n  if (result.length === 0) result = [['0x01', '0x', '0x']];\n  return result;\n}\n\nfunction extractSignatures(rawTransaction) {\n  let senderSignatures = [];\n  let feePayerSignatures = [];\n\n  const decoded = _decodeFromRawTransaction(rawTransaction);\n\n  senderSignatures = senderSignatures.concat(decoded.signatures);\n\n  if (decoded.feePayerSignatures) {\n    feePayerSignatures = feePayerSignatures.concat(decoded.feePayerSignatures);\n  }\n\n  return {\n    senderSignatures,\n    feePayerSignatures,\n    decodedTransaction: decoded\n  };\n}\n\nfunction splitFeePayer(rawTransaction) {\n  const typeString = utils.getTxTypeStringFromRawTransaction(rawTransaction);\n  if (!typeString || !typeString.includes('FEE_DELEGATED')) throw new Error(`Failed to split fee payer: not a fee delegated transaction type('${typeString || 'LEGACY'}')`);\n  const txType = rawTransaction.slice(0, 4);\n  const decodedValues = RLP.decode(utils.addHexPrefix(rawTransaction.slice(4)));\n  const detachFeePayer = decodedValues.splice(0, decodedValues.length - 2);\n  detachFeePayer.push('0x');\n  detachFeePayer.push([['0x01', '0x', '0x']]);\n  return {\n    senderRawTransaction: txType + RLP.encode(detachFeePayer).slice(2),\n    feePayer: decodedValues[0],\n    feePayerSignatures: decodedValues[1]\n  };\n}\n\nfunction decodeFromRawTransaction(rawTransaction, type) {\n  let decodeResult = _decodeFromRawTransaction(rawTransaction, type);\n\n  switch (decodeResult.type) {\n    case 'ACCOUNT_UPDATE':\n    case 'FEE_DELEGATED_ACCOUNT_UPDATE':\n    case 'FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO':\n      {\n        decodeResult = parseAccountKey(decodeResult);\n      }\n  }\n\n  return decodeResult;\n}\n\nfunction _decodeFromRawTransaction(rawTransaction, type) {\n  let typeString = type;\n\n  if (typeString === undefined || typeString !== 'LEGACY') {\n    typeString = utils.getTxTypeStringFromRawTransaction(rawTransaction);\n\n    if (typeString === undefined) {\n      typeString = 'LEGACY';\n    } else {\n      rawTransaction = `0x${rawTransaction.slice(4)}`;\n    }\n  }\n\n  switch (typeString) {\n    case 'LEGACY':\n      {\n        const [nonce, gasPrice, gas, to, value, data, v, r, s] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          to,\n          value,\n          data,\n          v,\n          r,\n          s,\n          signatures: [v, r, s]\n        };\n      }\n\n    case 'VALUE_TRANSFER':\n      {\n        const [nonce, gasPrice, gas, to, value, from, signatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          to,\n          value,\n          from,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures\n        };\n      }\n\n    case 'FEE_DELEGATED_VALUE_TRANSFER':\n      {\n        const [nonce, gasPrice, gas, to, value, from, signatures, feePayer, feePayerSignatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          to,\n          value,\n          from,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures,\n          feePayer,\n          payerV: feePayerSignatures[0][0],\n          payerR: feePayerSignatures[0][1],\n          payerS: feePayerSignatures[0][2],\n          feePayerSignatures\n        };\n      }\n\n    case 'FEE_DELEGATED_VALUE_TRANSFER_WITH_RATIO':\n      {\n        const [nonce, gasPrice, gas, to, value, from, feeRatio, signatures, feePayer, feePayerSignatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          to,\n          value,\n          from,\n          feeRatio,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures,\n          feePayer,\n          payerV: feePayerSignatures[0][0],\n          payerR: feePayerSignatures[0][1],\n          payerS: feePayerSignatures[0][2],\n          feePayerSignatures\n        };\n      }\n\n    case 'VALUE_TRANSFER_MEMO':\n      {\n        const [nonce, gasPrice, gas, to, value, from, data, signatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          to,\n          value,\n          from,\n          data,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures\n        };\n      }\n\n    case 'FEE_DELEGATED_VALUE_TRANSFER_MEMO':\n      {\n        const [nonce, gasPrice, gas, to, value, from, data, signatures, feePayer, feePayerSignatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          to,\n          value,\n          from,\n          data,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures,\n          feePayer,\n          payerV: feePayerSignatures[0][0],\n          payerR: feePayerSignatures[0][1],\n          payerS: feePayerSignatures[0][2],\n          feePayerSignatures\n        };\n      }\n\n    case 'FEE_DELEGATED_VALUE_TRANSFER_MEMO_WITH_RATIO':\n      {\n        const [nonce, gasPrice, gas, to, value, from, data, feeRatio, signatures, feePayer, feePayerSignatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          to,\n          value,\n          from,\n          data,\n          feeRatio,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures,\n          feePayer,\n          payerV: feePayerSignatures[0][0],\n          payerR: feePayerSignatures[0][1],\n          payerS: feePayerSignatures[0][2],\n          feePayerSignatures\n        };\n      }\n\n    case 'ACCOUNT_CREATION':\n      {\n        throw new Error(creationNotSupportError);\n      }\n\n    case 'ACCOUNT_UPDATE':\n      {\n        const [nonce, gasPrice, gas, from, accountKey, signatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          from,\n          accountKey,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures\n        };\n      }\n\n    case 'FEE_DELEGATED_ACCOUNT_UPDATE':\n      {\n        const [nonce, gasPrice, gas, from, accountKey, signatures, feePayer, feePayerSignatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          from,\n          accountKey,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures,\n          feePayer,\n          payerV: feePayerSignatures[0][0],\n          payerR: feePayerSignatures[0][1],\n          payerS: feePayerSignatures[0][2],\n          feePayerSignatures\n        };\n      }\n\n    case 'FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO':\n      {\n        const [nonce, gasPrice, gas, from, accountKey, feeRatio, signatures, feePayer, feePayerSignatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          from,\n          accountKey,\n          feeRatio,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures,\n          feePayer,\n          payerV: feePayerSignatures[0][0],\n          payerR: feePayerSignatures[0][1],\n          payerS: feePayerSignatures[0][2],\n          feePayerSignatures\n        };\n      }\n\n    case 'SMART_CONTRACT_DEPLOY':\n      {\n        const [nonce, gasPrice, gas, to, value, from, data, humanReadable, codeFormat, signatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          to,\n          value,\n          from,\n          data,\n          humanReadable: humanReadable === '0x01',\n          codeFormat,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures\n        };\n      }\n\n    case 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY':\n      {\n        const [nonce, gasPrice, gas, to, value, from, data, humanReadable, codeFormat, signatures, feePayer, feePayerSignatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          to,\n          value,\n          from,\n          data,\n          humanReadable: humanReadable === '0x01',\n          codeFormat,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures,\n          feePayer,\n          payerV: feePayerSignatures[0][0],\n          payerR: feePayerSignatures[0][1],\n          payerS: feePayerSignatures[0][2],\n          feePayerSignatures\n        };\n      }\n\n    case 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY_WITH_RATIO':\n      {\n        const [nonce, gasPrice, gas, to, value, from, data, humanReadable, feeRatio, codeFormat, signatures, feePayer, feePayerSignatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          to,\n          value,\n          from,\n          data,\n          humanReadable: humanReadable === '0x01',\n          feeRatio,\n          codeFormat,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures,\n          feePayer,\n          payerV: feePayerSignatures[0][0],\n          payerR: feePayerSignatures[0][1],\n          payerS: feePayerSignatures[0][2],\n          feePayerSignatures\n        };\n      }\n\n    case 'SMART_CONTRACT_EXECUTION':\n      {\n        const [nonce, gasPrice, gas, to, value, from, data, signatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          to,\n          value,\n          from,\n          data,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures\n        };\n      }\n\n    case 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION':\n      {\n        const [nonce, gasPrice, gas, to, value, from, data, signatures, feePayer, feePayerSignatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          to,\n          value,\n          from,\n          data,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures,\n          feePayer,\n          payerV: feePayerSignatures[0][0],\n          payerR: feePayerSignatures[0][1],\n          payerS: feePayerSignatures[0][2],\n          feePayerSignatures\n        };\n      }\n\n    case 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION_WITH_RATIO':\n      {\n        const [nonce, gasPrice, gas, to, value, from, data, feeRatio, signatures, feePayer, feePayerSignatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          to,\n          value,\n          from,\n          data,\n          feeRatio,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures,\n          feePayer,\n          payerV: feePayerSignatures[0][0],\n          payerR: feePayerSignatures[0][1],\n          payerS: feePayerSignatures[0][2],\n          feePayerSignatures\n        };\n      }\n\n    case 'CANCEL':\n      {\n        const [nonce, gasPrice, gas, from, signatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          from,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures\n        };\n      }\n\n    case 'FEE_DELEGATED_CANCEL':\n      {\n        const [nonce, gasPrice, gas, from, signatures, feePayer, feePayerSignatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          from,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures,\n          feePayer,\n          payerV: feePayerSignatures[0][0],\n          payerR: feePayerSignatures[0][1],\n          payerS: feePayerSignatures[0][2],\n          feePayerSignatures\n        };\n      }\n\n    case 'FEE_DELEGATED_CANCEL_WITH_RATIO':\n      {\n        const [nonce, gasPrice, gas, from, feeRatio, signatures, feePayer, feePayerSignatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          from,\n          feeRatio,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures,\n          feePayer,\n          payerV: feePayerSignatures[0][0],\n          payerR: feePayerSignatures[0][1],\n          payerS: feePayerSignatures[0][2],\n          feePayerSignatures\n        };\n      }\n\n    case 'CHAIN_DATA_ANCHORING':\n      {\n        const [nonce, gasPrice, gas, from, data, signatures] = RLP.decode(rawTransaction);\n        return {\n          type: typeString,\n          nonce,\n          gasPrice,\n          gas,\n          from,\n          data: data,\n          v: signatures[0][0],\n          r: signatures[0][1],\n          s: signatures[0][2],\n          signatures\n        };\n      }\n  }\n}\n\nfunction overwriteSignature(rawTransaction, txObj, signature, feePayerSignature) {\n  if (signature === undefined) {\n    signature = [txObj.v, txObj.r, txObj.s];\n  }\n\n  if (txObj.type.includes('FEE_DELEGATED') && feePayerSignature === undefined) {\n    feePayerSignature = [txObj.payerV, txObj.payerR, txObj.payerS];\n  }\n\n  if (txObj.type === 'LEGACY') {\n    let decodeLegacy = RLP.decode(rawTransaction);\n    decodeLegacy = decodeLegacy.slice(0, 6).concat(signature);\n    return RLP.encode(decodeLegacy);\n  }\n\n  const type = rawTransaction.slice(0, 4);\n  const typeDetached = `0x${rawTransaction.slice(4)}`;\n  const data = RLP.decode(typeDetached);\n\n  if (txObj.type.includes('FEE_DELEGATED')) {\n    data[data.length - 3] = [signature];\n    data[data.length - 1] = [feePayerSignature];\n  } else {\n    data[data.length - 1] = [signature];\n  }\n\n  return type + RLP.encode(data).slice(2);\n}\n\nfunction getSenderTxHash(rawTransaction) {\n  const typeString = utils.getTxTypeStringFromRawTransaction(rawTransaction);\n  if (typeString === undefined || !typeString.includes('FEE_DELEGATED')) return Hash.keccak256(rawTransaction);\n  const type = rawTransaction.slice(0, 4);\n  const typeDetached = `0x${rawTransaction.slice(4)}`;\n  const data = RLP.decode(typeDetached);\n  return Hash.keccak256(type + RLP.encode(data.slice(0, data.length - 2)).slice(2));\n}\n\nmodule.exports = {\n  encodeRLPByTxType,\n  makeRawTransaction,\n  decodeFromRawTransaction,\n  overwriteSignature,\n  getSenderTxHash,\n  splitFeePayer,\n  extractSignatures\n};","map":null,"metadata":{},"sourceType":"script"}