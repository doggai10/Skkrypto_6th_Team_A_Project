{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst _ = require('lodash');\n\nconst AccountLib = require('eth-lib/lib/account');\n\nconst utils = require('../../../caver-utils/src');\n\nconst PrivateKey = require('./privateKey');\n\nconst _require = require('./keyringHelper'),\n      KEY_ROLE = _require.KEY_ROLE,\n      isMultipleKeysFormat = _require.isMultipleKeysFormat,\n      isRoleBasedKeysFormat = _require.isRoleBasedKeysFormat;\n\nconst _require2 = require('./keyringHelper'),\n      decryptKey = _require2.decryptKey;\n\nconst SingleKeyring = require('./singleKeyring');\n\nconst MultipleKeyring = require('./multipleKeyring');\n\nconst RoleBasedKeyring = require('./roleBasedKeyring');\n\nconst SignatureData = require('./signatureData');\n/**\n * representing a KeyringFactory which supports create functions for Keyring(SingleKeyring/MultipleKeyring/RoleBasedKeyring)\n * @class\n */\n\n\nclass KeyringFactory {\n  /**\n   * generates a keyring instance\n   *\n   * `caver.wallet.keyring.generate()`\n   *\n   * @param {string} [entropy] A random string to increase entropy.\n   * @return {SingleKeyring}\n   */\n  static generate(entropy) {\n    const random = AccountLib.create(entropy || utils.randomHex(32));\n    return KeyringFactory.createWithSingleKey(random.address, random.privateKey);\n  }\n  /**\n   * generates a single private key string\n   *\n   * `caver.wallet.keyring.generateSingleKey()`\n   *\n   * @param {string} [entropy] A random string to increase entropy.\n   * @return {String}\n   */\n\n\n  static generateSingleKey(entropy) {\n    return AccountLib.create(entropy || utils.randomHex(32)).privateKey;\n  }\n  /**\n   * generates an array of private key strings\n   *\n   * `caver.wallet.keyring.generateMultipleKeys()`\n   *\n   * @param {number} num A length of keys.\n   * @param {string} [entropy] A random string to increase entropy.\n   * @return {Array.<String>}\n   */\n\n\n  static generateMultipleKeys(num, entropy) {\n    if (num === undefined || !_.isNumber(num) || _.isString(num)) {\n      throw new Error(\"To generate random multiple private keys, the number of keys should be defined.\");\n    }\n\n    const randomKeys = [];\n\n    for (let i = 0; i < num; i++) {\n      randomKeys.push(AccountLib.create(entropy || utils.randomHex(32)).privateKey);\n    }\n\n    return randomKeys;\n  }\n  /**\n   * generates an array in which keys to be used for each role are defined as an array.\n   *\n   * `caver.wallet.keyring.generateRoleBasedKeys()`\n   *\n   * @param {Array.<number>} numArr An array containing the number of keys for each role.\n   * @param {string} [entropy] A random string to increase entropy.\n   * @return {Array.<Array.<String>>}\n   */\n\n\n  static generateRoleBasedKeys(numArr, entropy) {\n    if (numArr === undefined || !_.isArray(numArr) || _.isString(numArr)) {\n      throw new Error(\"To generate random role-based private keys, an array containing the number of keys for each role should be defined.\");\n    }\n\n    if (numArr.length > KEY_ROLE.roleLast) {\n      throw new Error(\"Unsupported role. The length of array should be less than \".concat(KEY_ROLE.roleLast, \".\"));\n    }\n\n    const randomKeys = [[], [], []];\n\n    for (let i = 0; i < numArr.length; i++) {\n      for (let j = 0; j < numArr[i]; j++) {\n        randomKeys[i].push(AccountLib.create(entropy || utils.randomHex(32)).privateKey);\n      }\n    }\n\n    return randomKeys;\n  }\n  /**\n   * creates a keyring instance with parameters\n   *\n   * `caver.wallet.keyring.create('0x${address in hex}', '0x{private key}')`\n   * `caver.wallet.keyring.create('0x${address in hex}', ['0x{private key}', '0x{private key}'])`\n   * `caver.wallet.keyring.create('0x${address in hex}', [['0x{private key}', '0x{private key}'], ['0x{private key}'], ['0x{private key}', '0x{private key}']])`\n   *\n   * @param {string} address An address of keyring.\n   * @param {string|Array.<string>|Array.<Array.<string>>} key Private key(s) to use in keyring.\n   * @return {AbstractKeyring}\n   */\n\n\n  static create(address, key) {\n    if (_.isString(key)) return KeyringFactory.createWithSingleKey(address, key);\n    if (isMultipleKeysFormat(key)) return KeyringFactory.createWithMultipleKey(address, key);\n    if (isRoleBasedKeysFormat(key)) return KeyringFactory.createWithRoleBasedKey(address, key);\n    throw new Error(\"Unsupported key type: \".concat(typeof key));\n  }\n  /**\n   * creates a keyring instance from a private key string. KlaytnWalletKey format also can be handled.\n   *\n   * @param {string} privateKey The key parameter can be either normal private key or KlaytnWalletKey format.\n   * @return {SingleKeyring}\n   */\n\n\n  static createFromPrivateKey(privateKey) {\n    if (!_.isString(privateKey)) throw new Error(\"Invalid format of parameter. 'privateKey' should be in format of string\");\n    if (utils.isKlaytnWalletKey(privateKey)) return KeyringFactory.createFromKlaytnWalletKey(privateKey);\n    const acct = AccountLib.fromPrivate(utils.addHexPrefix(privateKey));\n    return KeyringFactory.createWithSingleKey(acct.address, acct.privateKey);\n  }\n  /**\n   * creates a keyring instance from a KlaytnWalletKey string.\n   *\n   * @param {string} klaytnWalletKey A key string in KlaytnWalletKey format.\n   * @return {SingleKeyring}\n   */\n\n\n  static createFromKlaytnWalletKey(klaytnWalletKey) {\n    if (!_.isString(klaytnWalletKey)) throw new Error(\"Invalid format of parameter. 'klaytnWalletKey' should be in format of string\");\n\n    if (!utils.isKlaytnWalletKey(klaytnWalletKey)) {\n      throw new Error(\"Invalid KlaytnWalletKey: \".concat(klaytnWalletKey));\n    }\n\n    const parsed = utils.parsePrivateKey(klaytnWalletKey);\n    return KeyringFactory.createWithSingleKey(parsed.address, parsed.privateKey);\n  }\n  /**\n   * creates a keyring instance from an address and a private key string.\n   *\n   * @param {string} address An address of keyring.\n   * @param {string} key A private key string.\n   * @return {SingleKeyring}\n   */\n\n\n  static createWithSingleKey(address, key) {\n    if (!_.isString(key)) throw new Error(\"Invalid format of parameter. Use 'fromMultipleKey' or 'fromRoleBasedKey' for two or more keys.\");\n    if (utils.isKlaytnWalletKey(key)) throw new Error(\"Invalid format of parameter. Use 'fromKlaytnWalletKey' to create Keyring from KlaytnWalletKey.\");\n    return new SingleKeyring(address, key);\n  }\n  /**\n   * creates a keyring instance from an address and multiple private key strings.\n   *\n   * @param {string} address An address of keyring.\n   * @param {Array.<string>} keyArray An array of private key strings.\n   * @return {MultipleKeyring}\n   */\n\n\n  static createWithMultipleKey(address, keyArray) {\n    if (!isMultipleKeysFormat(keyArray)) throw new Error(\"Invalid format of parameter. 'keyArray' should be an array of private key strings.\");\n    return new MultipleKeyring(address, keyArray);\n  }\n  /**\n   * creates a keyring instance from an address and an array in which keys to be used for each role are defined as an array.\n   *\n   * @param {string} address An address of keyring.\n   * @param {Array.<Array.<string>>} roledBasedKeyArray A two-dimensional array containing arrays of private key strings for each role.\n   * @return {RoleBasedKeyring}\n   */\n\n\n  static createWithRoleBasedKey(address, roledBasedKeyArray) {\n    if (!isRoleBasedKeysFormat(roledBasedKeyArray)) throw new Error(\"Invalid format of parameter. 'roledBasedKeyArray' should be in the form of an array defined as an array for the keys to be used for each role.\");\n    return new RoleBasedKeyring(address, roledBasedKeyArray);\n  }\n  /**\n   * decrypts a keystore v3 or v4 JSON and returns keyring instance.\n   *\n   * @param {object} keystore The encrypted keystore to decrypt.\n   * @param {string} password The password to use for decryption.\n   * @return {AbstractKeyring}\n   */\n\n\n  static decrypt(keystore, password) {\n    const json = _.isObject(keystore) ? keystore : JSON.parse(keystore);\n    if (json.version !== 3 && json.version !== 4) console.warn('This is not a V3 or V4 wallet.');\n\n    if (json.version === 3 && !json.crypto) {\n      throw new Error(\"Invalid keystore V3 format: 'crypto' is not defined.\");\n    } else if (json.version === 4 && !json.keyring) {\n      throw new Error(\"Invalid keystore V4 format: 'keyring' is not defined.\");\n    }\n\n    if (json.crypto) {\n      if (json.keyring) throw new Error(\"Invalid key store format: 'crypto' and 'keyring' cannot be defined together.\");\n      json.keyring = [json.crypto];\n      delete json.crypto;\n    } // AccountKeyRoleBased format\n\n\n    if (_.isArray(json.keyring[0])) {\n      const keys = [];\n      const transactionKey = decryptKey(json.keyring[KEY_ROLE.roleTransactionKey], password);\n      transactionKey ? keys.push(transactionKey) : keys.push([]);\n      const updateKey = decryptKey(json.keyring[KEY_ROLE.roleAccountUpdateKey], password);\n      updateKey ? keys.push(updateKey) : keys.push([]);\n      const feePayerKey = decryptKey(json.keyring[KEY_ROLE.roleFeePayerKey], password);\n      feePayerKey ? keys.push(feePayerKey) : keys.push([]);\n      return KeyringFactory.createWithRoleBasedKey(json.address, keys);\n    }\n\n    let decrypted = decryptKey(json.keyring, password);\n    decrypted = _.isArray(decrypted) ? decrypted : [decrypted];\n    if (decrypted.length === 1) return KeyringFactory.createWithSingleKey(json.address, decrypted[0]);\n    return KeyringFactory.createWithMultipleKey(json.address, decrypted);\n  } // /**\n  //  * encrypts a keyring and returns a keystore v4 object.\n  //  *\n  //  * @param {string|Array.<string>|Array.<string>|Keyring} key The key parameter can be an instance of Keyring, a normal private key(KlaytnWalletKey format also supported),\n  //  *                                                           an array of private key strings, or a two-dimensional array containing arrays of private key strings for each role,\n  //  * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n  //  * @param {object} options The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n  //  * @return {object}\n  //  */\n  // static encrypt(key, password, options = {}) {\n  //     let keyring\n  //     if (_.isArray(key)) {\n  //         if (options.address === undefined)\n  //             throw new Error(`The address must be defined inside the options object to encrypt multiple keys.`)\n  //         if (isRoleBasedKeysFormat(key)) {\n  //             keyring = KeyringFactory.createWithRoleBasedKey(options.address, key)\n  //         } else if (isMultipleKeysFormat(key)) {\n  //             keyring = KeyringFactory.createWithMultipleKey(options.address, key)\n  //         } else {\n  //             throw new Error(`Invalid key format.`)\n  //         }\n  //     } else if (key instanceof AbstractKeyring) {\n  //         keyring = key\n  //     } else if (_.isString(key)) {\n  //         if (options.address) {\n  //             if (utils.isKlaytnWalletKey(key)) {\n  //                 keyring = KeyringFactory.createFromKlaytnWalletKey(key)\n  //                 if (keyring.address.toLowerCase() !== options.address.toLowerCase()) {\n  //                     throw new Error(\n  //                         `The address defined in options(${options.address}) does not match the address of KlaytnWalletKey(${keyring.address}) entered as a parameter.`\n  //                     )\n  //                 }\n  //             } else {\n  //                 keyring = KeyringFactory.createWithSingleKey(options.address, key)\n  //             }\n  //         } else {\n  //             keyring = KeyringFactory.createFromPrivateKey(key)\n  //         }\n  //     } else {\n  //         throw new Error(`Invalid key format.`)\n  //     }\n  //     return keyring.encrypt(password, options)\n  // }\n  // /**\n  //  * encrypts a keyring and returns a keystore v3 object.\n  //  *\n  //  * @param {string|Keyring} key The key parameter can be a normal private key(KlaytnWalletKey format also supported) or an instance of Keyring.\n  //  * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\n  //  * @param {object} options The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n  //  * @return {object}\n  //  */\n  // static encryptV3(key, password, options = {}) {\n  //     if (!_.isString(key) && !(key instanceof Keyring)) {\n  //         throw new Error(`Invalid parameter. key should be a private key string, KlaytnWalletKey or instance of Keyring`)\n  //     }\n  //     let keyring\n  //     if (key instanceof Keyring) {\n  //         keyring = key\n  //     } else if (options.address) {\n  //         if (utils.isKlaytnWalletKey(key)) {\n  //             keyring = KeyringFactory.createFromKlaytnWalletKey(key)\n  //             if (keyring.address.toLowerCase() !== options.address.toLowerCase()) {\n  //                 throw new Error(\n  //                     `The address defined in options(${options.address}) does not match the address of KlaytnWalletKey(${keyring.address}) entered as a parameter.`\n  //                 )\n  //             }\n  //         } else {\n  //             keyring = KeyringFactory.createWithSingleKey(options.address, key)\n  //         }\n  //     } else {\n  //         keyring = KeyringFactory.createFromPrivateKey(key)\n  //     }\n  //     return keyring.encryptV3(password, options)\n  // }\n\n\n}\n\nKeyringFactory.privateKey = PrivateKey;\nKeyringFactory.singleKeyring = SingleKeyring;\nKeyringFactory.multipleKeyring = MultipleKeyring;\nKeyringFactory.roleBasedKeyring = RoleBasedKeyring;\nKeyringFactory.role = KEY_ROLE;\nKeyringFactory.signatureData = SignatureData;\nmodule.exports = KeyringFactory;","map":null,"metadata":{},"sourceType":"script"}