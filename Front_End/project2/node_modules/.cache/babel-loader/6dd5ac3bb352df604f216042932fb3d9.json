{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar _ = require('underscore');\n\nvar errors = require('../../caver-core-helpers').errors;\n\nconst middleware = require('../../caver-middleware');\n/**\n * Jsonrpc library\n * 이 라이브러리를 통해 수행하는 기능은 세 가지 이다.\n * 1) Jsonrpc.toPayload 블록체인에 메시지를 보낼 때 method와 parameter를 jsonrpc 규약에 맞는 메시지로 변형해준다.\n * 2) Jsonrpc.isValidResponse jsonrpc 규약에 맞는 메시지 형식인지 확인한다.\n * 3) Jsonrpc.toBatchPayload 블록체인에 batch로 메시지를 보낼 때 사용된다.\n * 위 기능들은 RequestManager에서는 .send, .sendBatch에서 사용된다.\n *\n */\n\n\nvar Jsonrpc = require('./jsonrpc.js');\n/**\n * BatchManager library\n * BatchManager는 json rpc 메시지를 batch 형식으로 보낼수 있게끔 도와주는 라이브러리이다.\n * 위 기능은 RequestManager에서 따로 함수를 파서 사용되는건 아니고, 그냥 RequestManager에 모듈로서 붙어있는 형태이다.\n * ex) RequestManager.BatchManager\n */\n\n\nvar BatchManager = require('./batch.js');\n/**\n * RequestManager의 constructor 함수인데, provider를 parameter로 받는다.\n * 기능은 다음과 같다.\n * 1) 각 값들 초기화 - provider는 null로, providers는 초기에 지정된 providers로,\n *    subscriptions는 빈 object로\n * 2) 받은 provider를 .setProvider라는 함수를 불러서 이 RequestManager instance의 provider로 사용한다.\n */\n\n\nvar RequestManager = function RequestManager(provider, net) {\n  this.provider = null;\n  this.providers = RequestManager.providers;\n  this.setProvider(provider, net);\n  this.subscriptions = {};\n};\n/**\n * 기본적으로 RequestManager.providers에서 가져다 쓸 수 있는 provider들에 대해서 정의되어 있다.\n */\n\n\nRequestManager.providers = {\n  WebsocketProvider: require('../caver-providers-ws'),\n  HttpProvider: require('../caver-providers-http'),\n  IpcProvider: require('../caver-providers-ipc')\n};\n/**\n * Should be used to set provider of request manager\n *\n * @method setProvider\n * @param {Object} p\n */\n\n/**\n * RequestManager의 provider를 셋팅하는 함수로,\n * p라는 parameter와 net이라는 optional parameter를 받는데,\n * p는 'http://127.0.0.1:22000' 혹은 'ws://127.0.0.1:8546' 이런 식으로 받는 스트링을 말한다.\n * p로 들어온 스트링을 정규식 체크를 통해서 각각 HttpProvider로 들어갈 주소인지, WebsocketProvider로 들어갈 주소인지,\n * IpcProvider로 들어갈 주소인지를 판단해서 this.provider를 설정해주고, 이미 provider가 존재한다면,\n * 그에 대한 subscription을 모두 날리고, 새로 .on 을 통해 들어오는 메시지를 listening 한다.\n * 이 때 추가적으로 콜백처리도 수행해준다.\n */\n\nRequestManager.prototype.setProvider = function (p, net) {\n  var _this = this;\n  /**\n   * p로 들어온 스트링 정규식 체크\n   */\n\n\n  if (p && typeof p === 'string' && this.providers) {\n    // HTTP\n    if (/^http(s)?:\\/\\//i.test(p)) {\n      p = new this.providers.HttpProvider(p); // WS\n    } else if (/^ws(s)?:\\/\\//i.test(p)) {\n      p = new this.providers.WebsocketProvider(p); // IPC\n    } else if (p && typeof net === 'object' && typeof net.connect === 'function') {\n      p = new this.providers.IpcProvider(p, net);\n    } else if (p) {\n      throw new Error('Can\\'t autodetect provider for \"' + p + '\"');\n    }\n  }\n  /**\n   * 기존에 provider가 잡혀있었다면 거기에 subscription을 날려줘야하기 때문에\n   * .clearSubscriptions() 함수 실행\n   */\n\n\n  if (this.provider) this.clearSubscriptions();\n  this.provider = p || null;\n  /**\n   * 위의 과정들을 통해 셋팅된 provider가 ipc provider라면 .on 함수를 통해 message listening을 해준다.\n   * ipc provider만 .on을 구현하였다.\n   */\n  // listen to incoming notifications\n\n  if (this.provider && this.provider.on) {\n    this.provider.on('data', function requestManagerNotification(result, deprecatedResult) {\n      /**\n       * result외에 deprecatedResult라는 parameter를 optional하게 받는 것 같은데,\n       * 'error' 를 첫 parameter로 받는 형식을 가진 구버전 프로바이더를 지원하기 위함이라고 한다.\n       */\n      result = result || deprecatedResult; // this is for possible old providers, which may had the error first handler\n\n      /**\n       * 여기서 .on('data')로 받는 result에 들어가는게 jsonrpc response인지 jsonrpc request인지 헷갈린다.\n       * > response 가 맞다. 아래코드는 ipc 에서만 사용하는 코드이다.\n       */\n      // check for result.method, to prevent old providers errors to pass as result\n\n      if (result.method && _this.subscriptions[result.params.subscription] && _this.subscriptions[result.params.subscription].callback) {\n        _this.subscriptions[result.params.subscription].callback(null, result.params.result);\n      }\n    }); // TODO add error, end, timeout, connect??\n    // this.provider.on('error', function requestManagerNotification(result){\n    //     Object.keys(_this.subscriptions).forEach(function(id){\n    //         if(_this.subscriptions[id].callback)\n    //             _this.subscriptions[id].callback(err);\n    //     });\n    // }\n  }\n\n  return this;\n};\n/**\n * Should be used to asynchronously send request\n *\n * @method sendAsync\n * @param {Object} data\n * @param {Function} callback\n */\n\n/**\n * send는 받은 data parameter를 현재 this.provider에 .sendAsync 메서드가 있다면 .sendAsync를 호출하고, 그렇지 않다면 .send를 호출하는 wrapper function 이다.\n * 호출하기 전에 Jsonrpc.toPayload 메서드를 이용하여\n * data parameter를 jsonrpc 규약에 맞는 메시지로 바꿔준다.\n * 그 후 몇 가지 체크를 통해 에러를 걸러내고, 모든 조건을 통과했을 때 parameter에 있는 콜백함수(callback) 실행\n */\n\n\nRequestManager.prototype.send = function (data, callback) {\n  callback = callback || function () {};\n\n  if (!this.provider) {\n    return callback(errors.InvalidProvider());\n  }\n\n  var payload = Jsonrpc.toPayload(data.method, data.params);\n  /**\n   * send, async 구현상황\n   * httpProvider - send\n   * ipcProvider - send\n   * wsProvider - send\n   *\n   * // ? sendAsync를 구현한 프로바이더가 없다. 미래를 위해 만들어 놓은듯?\n   */\n\n  const isMiddlewareExist = middleware.getMiddlewares().length !== 0;\n  if (!isMiddlewareExist) return sendRPC(this.provider)(payload); // Attach outbound middleware\n\n  middleware.applyMiddleware(payload, 'outbound', sendRPC(this.provider));\n\n  function sendRPC(provider) {\n    return function (payload) {\n      provider[provider.sendAsync ? 'sendAsync' : 'send'](payload, function (err, result) {\n        // Attach inbound middleware\n        if (isMiddlewareExist) middleware.applyMiddleware(payload, 'inbound');\n        /**\n         * result = json rpc response object\n         * {\n         *  jsonrpc: '2.0'\n         *  result: ...,\n         *  id: ...,\n         *  error: ...,\n         * }\n         *\n         * Reference: https://www.jsonrpc.org/specification\n         */\n\n        if (result && result.id && payload.id !== result.id) return callback(new Error('Wrong response id \"' + result.id + '\" (expected: \"' + payload.id + '\") in ' + JSON.stringify(payload)));\n        if (err) return callback(err);\n        if (result && result.error) return callback(errors.ErrorResponse(result));\n        if (!Jsonrpc.isValidResponse(result)) return callback(errors.InvalidResponse(result));\n        callback(null, result.result);\n      });\n    };\n  }\n};\n/**\n * Should be called to asynchronously send batch request\n *\n * @method sendBatch\n * @param {Array} batch data\n * @param {Function} callback\n */\n\n\nRequestManager.prototype.sendBatch = function (data, callback) {\n  if (!this.provider) {\n    return callback(errors.InvalidProvider());\n  }\n\n  var payload = Jsonrpc.toBatchPayload(data);\n  this.provider[this.provider.sendAsync ? 'sendAsync' : 'send'](payload, function (err, results) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!_.isArray(results)) {\n      return callback(errors.InvalidResponse(results));\n    }\n\n    callback(null, results);\n  });\n};\n/**\n * Waits for notifications\n *\n * @method addSubscription\n * @param {String} id           the subscription id\n * @param {String} name         the subscription name\n * @param {String} type         the subscription namespace (eth, personal, etc)\n * @param {Function} callback   the callback to call for incoming notifications\n */\n\n/**\n * addSubscription은 subscription을 추가하는 함수로,\n * this.provider에 on이 달려있으면, this(RequestManager instance)에 subscription을 등록한다.\n * id, callback, type, name을 parameter로 받아서 등록하는데,\n * type은 말 그대로 어떤 type인지, 단순 namespace로서의 기능.\n */\n\n\nRequestManager.prototype.addSubscription = function (id, name, type, callback) {\n  if (this.provider.on) {\n    this.subscriptions[id] = {\n      callback: callback,\n      type: type,\n      name: name\n    };\n  } else {\n    throw new Error('The provider doesn\\'t support subscriptions: ' + this.provider.constructor.name);\n  }\n};\n/**\n * Waits for notifications\n *\n * @method removeSubscription\n * @param {String} id           the subscription id\n * @param {Function} callback   fired once the subscription is removed\n */\n\n/**\n * removeSubscription은 말 그대로 subscription을 제거하는 함수로,\n * rpc 콜을 통해 _unsubscribe 메시지를 프로바이더에 보내고,\n * id를 parameter로 해서 subscriptions에 붙어 있는 subscriptions를 메모리에서 삭제해준다.\n */\n\n\nRequestManager.prototype.removeSubscription = function (id, callback) {\n  var _this = this;\n\n  if (this.subscriptions[id]) {\n    this.send({\n      method: this.subscriptions[id].type + '_unsubscribe',\n      params: [id]\n    }, callback); // remove subscription\n\n    delete _this.subscriptions[id];\n  }\n};\n/**\n * Should be called to reset the subscriptions\n *\n * @method reset\n */\n\n/**\n * this.subscriptions에 붙어있는 모든 id값들을 돌면서, 그 subscription의 name이 'syncing'인\n * 경우를 제외하고 모두 메모리에서 날려버린다.(위에서 본 _removeSubscription을 통해)\n * 그 후 provider에 붙어있는 .reset 메서드를 실행하는데, .reset 메서드가 붙어있는 프로바이더는\n * WebsocketProvider와 IpcProvider의 경우에만 붙어있다. (HttpProvider에는 .reset 메서드 존재하지 않음.)\n */\n\n\nRequestManager.prototype.clearSubscriptions = function (keepIsSyncing) {\n  var _this = this; // uninstall all subscriptions\n\n\n  Object.keys(this.subscriptions).forEach(function (id) {\n    if (!keepIsSyncing || _this.subscriptions[id].name !== 'syncing') _this.removeSubscription(id);\n  }); //  reset notification callbacks etc.\n\n  if (this.provider.reset) this.provider.reset();\n};\n\nmodule.exports = {\n  Manager: RequestManager,\n  BatchManager: BatchManager\n};","map":null,"metadata":{},"sourceType":"script"}