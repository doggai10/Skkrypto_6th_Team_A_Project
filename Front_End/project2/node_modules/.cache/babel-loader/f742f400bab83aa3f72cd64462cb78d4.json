{"ast":null,"code":"/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-eth-contract/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file contract.js\n *\n * To initialize a contract use:\n *\n *  let Contract = require('web3-eth-contract');\n *  Contract.setProvider('ws://localhost:8546');\n *  let contract = new Contract(abi, address, ...);\n *\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nconst _ = require('lodash');\n\nconst core = require('../../caver-core');\n\nconst Method = require('../../caver-core-method');\n\nconst utils = require('../../caver-utils');\n\nconst Subscription = require('../../caver-core-subscriptions').subscription;\n\nconst SmartContractDeploy = require('../../caver-transaction/src/transactionTypes/smartContractDeploy/smartContractDeploy');\n\nconst SmartContractExecution = require('../../caver-transaction/src/transactionTypes/smartContractExecution/smartContractExecution');\n\nconst KeyringContainer = require('../../caver-wallet');\n\nconst _require = require('../../caver-core-helpers'),\n      formatters = _require.formatters;\n\nconst _require2 = require('../../caver-core-helpers'),\n      errors = _require2.errors;\n\nconst abi = require('../../caver-abi');\n/**\n * Should be called to create new contract instance\n *\n * @method Contract\n * @constructor\n * @param {Array} jsonInterface\n * @param {String} address\n * @param {Object} options\n */\n\n/**\n * let myContract = new cav.klay.Contract([...], '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe', {\n *   from: '0x1234567890123456789012345678901234567891', // default from address\n *   gasPrice: '20000000000', // default gas price in wei, 20 gwei in this case\n *   data: '',(bytecode, when contract deploy)\n *   gas: 200000, (gas limit)\n * });\n */\n\n\nconst Contract = function Contract(jsonInterface, address, options) {\n  const _this = this;\n\n  const args = Array.prototype.slice.call(arguments);\n\n  if (!(this instanceof Contract)) {\n    throw new Error('Please use the \"new\" keyword to instantiate a caver.contract() or caver.klay.Contract() object!');\n  } // sets _requestmanager\n\n\n  core.packageInit(this, [this.constructor.currentProvider]);\n  this.clearSubscriptions = this._requestManager.clearSubscriptions;\n\n  if (!jsonInterface || !Array.isArray(jsonInterface)) {\n    throw new Error('You must provide the json interface of the contract when instantiating a contract object.');\n  } // create the options object\n\n\n  this.options = {};\n  const lastArg = args[args.length - 1];\n\n  if (_.isObject(lastArg) && !_.isArray(lastArg)) {\n    options = lastArg;\n    this.options = _.extend(this.options, this._getOrSetDefaultOptions(options));\n\n    if (_.isObject(address)) {\n      address = null;\n    }\n  }\n\n  Object.defineProperty(this, 'defaultSendOptions', {\n    get() {\n      return _this.options;\n    }\n\n  }); // set address\n\n  Object.defineProperty(this.options, 'address', {\n    set(value) {\n      if (value) {\n        _this._address = utils.toChecksumAddress(formatters.inputAddressFormatter(value));\n      }\n    },\n\n    get() {\n      return _this._address;\n    },\n\n    enumerable: true\n  }); // add method and event signatures, when the jsonInterface gets set\n\n  Object.defineProperty(this.options, 'jsonInterface', {\n    set(value) {\n      _this.methods = {};\n      _this.events = {};\n      _this._jsonInterface = value.map(function (method) {\n        let func;\n        let funcName;\n\n        if (method.name) {\n          funcName = utils._jsonInterfaceMethodToString(method);\n        } // function\n\n\n        if (method.type === 'function') {\n          method.signature = abi.encodeFunctionSignature(funcName);\n          func = _this._createTxObject.bind({\n            method,\n            parent: _this\n          }); // add method only if not one already exists\n\n          if (!_this.methods[method.name]) {\n            _this.methods[method.name] = func;\n          } else {\n            const cascadeFunc = _this._createTxObject.bind({\n              method,\n              parent: _this,\n              nextMethod: _this.methods[method.name]\n            });\n\n            _this.methods[method.name] = cascadeFunc;\n          } // definitely add the method based on its signature\n\n\n          _this.methods[method.signature] = func; // add method by name\n\n          _this.methods[funcName] = func; // event\n        } else if (method.type === 'event') {\n          method.signature = abi.encodeEventSignature(funcName);\n\n          const event = _this._on.bind(_this, method.signature); // add method only if not already exists\n\n\n          if (!_this.events[method.name] || _this.events[method.name].name === 'bound ') {\n            _this.events[method.name] = event;\n          } // definitely add the method based on its signature\n\n\n          _this.events[method.signature] = event; // add event by name\n\n          _this.events[funcName] = event;\n        }\n\n        return method;\n      }); // add allEvents\n\n      _this.events.allEvents = _this._on.bind(_this, 'allevents');\n      return _this._jsonInterface;\n    },\n\n    get() {\n      return _this._jsonInterface;\n    },\n\n    enumerable: true\n  }); // get default account from the Class\n\n  let defaultAccount = this.constructor.defaultAccount;\n  let defaultBlock = this.constructor.defaultBlock || 'latest';\n  Object.defineProperty(this, 'defaultAccount', {\n    get() {\n      return defaultAccount;\n    },\n\n    set(val) {\n      if (val) {\n        defaultAccount = utils.toChecksumAddress(formatters.inputAddressFormatter(val));\n      }\n\n      return val;\n    },\n\n    enumerable: true\n  });\n  Object.defineProperty(this, 'defaultBlock', {\n    get() {\n      return defaultBlock;\n    },\n\n    set(val) {\n      if (!utils.isValidBlockNumberCandidate(val)) {\n        throw new Error('Invalid default block number.');\n      }\n\n      defaultBlock = val;\n      return val;\n    },\n\n    enumerable: true\n  }); // Check for setting options property.\n\n  Object.defineProperty(this.options, 'from', {\n    set(value) {\n      if (value) {\n        _this._from = utils.toChecksumAddress(formatters.inputAddressFormatter(value));\n      }\n    },\n\n    get() {\n      return _this._from;\n    },\n\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'gasPrice', {\n    set(value) {\n      if (value) {\n        if (!utils.isValidNSHSN(value)) {\n          throw errors.invalidGasPrice();\n        }\n\n        _this._gasPrice = value;\n      }\n    },\n\n    get() {\n      return _this._gasPrice;\n    },\n\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'gas', {\n    set(value) {\n      if (value) {\n        if (!utils.isValidNSHSN(value)) throw errors.invalidGasLimit();\n        _this._gas = value;\n      }\n    },\n\n    get() {\n      return _this._gas;\n    },\n\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'data', {\n    set(value) {\n      if (value) {\n        if (!utils.isHexStrict(value)) throw errors.invalidData();\n        _this._data = value;\n      }\n    },\n\n    get() {\n      return _this._data;\n    },\n\n    enumerable: true\n  }); // properties\n\n  this.methods = {};\n  this.events = {};\n  this._address = null;\n  this._jsonInterface = []; // set getter/setter properties\n\n  this.options.address = address;\n  this.options.jsonInterface = jsonInterface;\n};\n\nContract.setProvider = function (provider, accounts) {\n  core.packageInit(this, [provider]);\n  this._klayAccounts = accounts;\n};\n/**\n * Set _keyrings in contract instance.\n * When _keyrings is exsit, contract will use _keyrings instead of _klayAccounts\n *\n * @param {KeyringContainer} keyrings\n */\n\n\nContract.prototype.setKeyrings = function (keyrings) {\n  if (!(keyrings instanceof KeyringContainer)) throw new Error(\"keyrings should be an instance of 'KeyringContainer'\");\n  this._keyrings = keyrings;\n};\n\nContract.prototype.addAccounts = function (accounts) {\n  this._klayAccounts = accounts;\n};\n/**\n * Get the callback and modiufy the array if necessary\n *\n * @method _getCallback\n * @param {Array} args\n * @return {Function} the callback\n */\n\n\nContract.prototype._getCallback = function getCallback(args) {\n  if (args && _.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Checks that no listener with name \"newListener\" or \"removeListener\" is added.\n *\n * @method _checkListener\n * @param {String} type\n * @param {String} event\n * @return {Object} the contract instance\n */\n\n/**\n * this._checkListener('newListener', subOptions.event.name);\n * this._checkListener('removeListener', subOptions.event.name);\n */\n\n\nContract.prototype._checkListener = function (type, event) {\n  if (event === type) {\n    throw new Error(\"The event \\\"\".concat(type, \"\\\" is a reserved event name, you can't use it.\"));\n  }\n};\n/**\n * Use default values, if options are not available\n *\n * @method _getOrSetDefaultOptions\n * @param {Object} options the options gived by the user\n * @return {Object} the options with gaps filled by defaults\n */\n\n\nContract.prototype._getOrSetDefaultOptions = function getOrSetDefaultOptions(options) {\n  const gasPrice = options.gasPrice ? String(options.gasPrice) : null;\n  const from = options.from ? utils.toChecksumAddress(formatters.inputAddressFormatter(options.from)) : null;\n  options.data = options.data || this.options.data;\n  options.from = from || this.options.from;\n  options.gasPrice = gasPrice || this.options.gasPrice; // If options.gas isn't set manually, use options.gasLimit, this.options.gas instead.\n\n  if (typeof options.gas === 'undefined') {\n    options.gas = options.gasLimit || this.options.gas;\n  } // TODO replace with only gasLimit?\n\n\n  delete options.gasLimit;\n  return options;\n};\n/**\n * Should be used to encode indexed params and options to one final object\n *\n * @method _encodeEventABI\n * @param {Object} event\n * @param {Object} options\n * @return {Object} everything combined together and encoded\n */\n\n/**\n * _encodeEventABI\n * 1. options\n * options = {\n *   filter: {...},\n *   topics: [...],\n * }\n *   cf. topics\n *   - This allows you to manually set the topics for the event filter.\n *   - If given the filter property and event signature, (topic[0]) will not\n *   - be set automatically.\n *\n * 2. event\n * {\n *   anonymous: Bool,\n *   signature:\n *   name: String,\n *   inputs: [...],\n * }\n * cf) signature\n * - The signatureâ€™s hash of the event is one of the topics,\n * - unless you used the anonymous specifier to declare the event.\n * - This would mean filtering for anonymous, specific events by name is not possible.\n * - keccak256(\"burned(address,uint)\") = 0x0970ce1235167a71...\n */\n\n\nContract.prototype._encodeEventABI = function (event, options) {\n  options = options || {};\n  const filter = options.filter || {};\n  const result = {};\n  ['fromBlock', 'toBlock'].filter(function (f) {\n    return options[f] !== undefined;\n  }).forEach(function (f) {\n    result[f] = formatters.inputBlockNumberFormatter(options[f]);\n  }); // use given topics\n\n  if (_.isArray(options.topics)) {\n    result.topics = options.topics; // create topics based on filter\n  } else {\n    result.topics = []; // add event signature\n\n    if (event && !event.anonymous && event.name !== 'ALLEVENTS') {\n      result.topics.push(event.signature);\n    } // add event topics (indexed arguments)\n\n\n    if (event.name !== 'ALLEVENTS') {\n      const indexedTopics = event.inputs.filter(i => i.indexed === true).map(i => {\n        const value = filter[i.name];\n        if (!value) return null; // TODO: https://github.com/ethereum/web3.js/issues/344\n\n        if (_.isArray(value)) {\n          return value.map(v => abi.encodeParameter(i.type, v));\n        }\n\n        return abi.encodeParameter(i.type, value);\n      });\n      result.topics = result.topics.concat(indexedTopics);\n    }\n\n    if (!result.topics.length) delete result.topics;\n  }\n\n  if (this.options.address) {\n    result.address = this.options.address.toLowerCase();\n  }\n\n  return result;\n};\n/**\n * Should be used to decode indexed params and options\n *\n * @method _decodeEventABI\n * @param {Object} data\n * @return {Object} result object with decoded indexed && not indexed params\n */\n\n\nContract.prototype._decodeEventABI = function (data) {\n  let event = this;\n  data.data = data.data || '';\n  data.topics = data.topics || [];\n  const result = formatters.outputLogFormatter(data); // if allEvents get the right event\n\n  if (event.name === 'ALLEVENTS') {\n    event = event.jsonInterface.find(function (intf) {\n      return intf.signature === data.topics[0];\n    }) || {\n      anonymous: true\n    };\n  } // create empty inputs if none are present (e.g. anonymous events on allEvents)\n\n\n  event.inputs = event.inputs || [];\n  const argTopics = event.anonymous ? data.topics : data.topics.slice(1);\n  result.returnValues = abi.decodeLog(event.inputs, data.data, argTopics);\n  delete result.returnValues.__length__; // add name\n\n  result.event = event.name; // add signature\n\n  result.signature = event.anonymous || !data.topics[0] ? null : data.topics[0]; // move the data and topics to \"raw\"\n\n  result.raw = {\n    data: result.data,\n    topics: result.topics\n  };\n  delete result.data;\n  delete result.topics;\n  return result;\n};\n/**\n * Encodes an ABI for a method, including signature or the method.\n * Or when constructor encodes only the constructor parameters.\n *\n * @method _encodeMethodABI\n * @param {Mixed} args the arguments to encode\n * @param {String} the encoded ABI\n */\n\n\nContract.prototype._encodeMethodABI = function _encodeMethodABI() {\n  const methodSignature = this._method.signature;\n  const args = this.arguments || [];\n  let signature = false;\n  const paramsABI = this._parent.options.jsonInterface.filter(function (json) {\n    return methodSignature === 'constructor' && json.type === methodSignature || (json.signature === methodSignature || json.signature === methodSignature.replace('0x', '') || json.name === methodSignature) && json.type === 'function';\n  }).map(function (json) {\n    const inputLength = _.isArray(json.inputs) ? json.inputs.length : 0;\n\n    if (inputLength !== args.length) {\n      throw new Error(\"The number of arguments is not matching the methods required number. You need to pass \".concat(inputLength, \" arguments.\"));\n    }\n\n    if (json.type === 'function') {\n      signature = json.signature;\n    }\n\n    return _.isArray(json.inputs) ? json.inputs : [];\n  }).map(function (inputs) {\n    return abi.encodeParameters(inputs, args).replace('0x', '');\n  })[0] || ''; // return constructor\n\n  if (methodSignature === 'constructor') {\n    if (!this._deployData) {\n      throw new Error('The contract has no contract data option set. This is necessary to append the constructor parameters.');\n    }\n\n    return this._deployData + paramsABI; // return method\n  }\n\n  const returnValue = signature ? signature + paramsABI : paramsABI;\n\n  if (!returnValue) {\n    throw new Error(\"Couldn't find a matching contract method named \\\"\".concat(this._method.name, \"\\\".\"));\n  } else {\n    return returnValue;\n  }\n};\n/**\n * Decode method return values\n *\n * @method _decodeMethodReturn\n * @param {Array} outputs\n * @param {String} returnValues\n * @return {Object} decoded output return values\n */\n\n\nContract.prototype._decodeMethodReturn = function (outputs, returnValues) {\n  if (!returnValues) {\n    return null;\n  }\n\n  returnValues = returnValues.length >= 2 ? returnValues.slice(2) : returnValues;\n  const result = abi.decodeParameters(outputs, returnValues);\n\n  if (result.__length__ === 1) {\n    return result[0];\n  }\n\n  delete result.__length__;\n  return result;\n};\n/**\n * Deploys a contract and fire events based on its state: transactionHash, receipt\n *\n * All event listeners will be removed, once the last possible event is fired (\"error\", or \"receipt\")\n *\n * @method deploy\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\n\n\nContract.prototype.deploy = function (options, callback) {\n  options = options || {};\n  options.arguments = options.arguments || [];\n  options = this._getOrSetDefaultOptions(options); // return error, if no \"data\" is specified\n\n  if (!options.data) {\n    return utils._fireError(new Error('No \"data\" specified in neither the given options, nor the default options.'), null, null, callback);\n  }\n\n  const constructor = _.find(this.options.jsonInterface, function (method) {\n    return method.type === 'constructor';\n  }) || {};\n  constructor.signature = 'constructor';\n  return this._createTxObject.apply({\n    method: constructor,\n    parent: this,\n    deployData: options.data,\n    _klayAccounts: this.constructor._klayAccounts,\n    _keyrings: this._keyrings\n  }, options.arguments);\n};\n/**\n * Gets the event signature and outputformatters\n *\n * @method _generateEventOptions\n * @param {Object} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event options object\n */\n\n\nContract.prototype._generateEventOptions = function () {\n  const args = Array.prototype.slice.call(arguments); // get the callback\n\n  const callback = this._getCallback(args); // get the options\n\n\n  const options = _.isObject(args[args.length - 1]) ? args.pop() : {};\n  let event = _.isString(args[0]) ? args[0] : 'allevents';\n  event = event.toLowerCase() === 'allevents' ? {\n    name: 'ALLEVENTS',\n    jsonInterface: this.options.jsonInterface\n  } : this.options.jsonInterface.find(function (json) {\n    return json.type === 'event' && (json.name === event || json.signature === \"0x\".concat(event.replace('0x', '')));\n  });\n\n  if (!event) {\n    throw new Error(\"Event \\\"\".concat(event.name, \"\\\" doesn't exist in this contract.\"));\n  }\n\n  if (!utils.isAddress(this.options.address)) {\n    throw new Error(\"This contract object doesn't have address set yet, please set an address first.\");\n  }\n\n  return {\n    params: this._encodeEventABI(event, options),\n    event,\n    callback\n  };\n};\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n *\n * @method clone\n * @return {Object} the event subscription\n */\n\n\nContract.prototype.clone = function (contractAddress = this.options.address) {\n  return new this.constructor(this.options.jsonInterface, contractAddress, this.options);\n};\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n * (Subscribes to an event and unsubscribes immediately after the first event or error. Will only fire for a single event.)\n *\n *\n * @method once\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event subscription\n *\n * myContract.once('MyEvent', {\n      filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23\n      fromBlock: 0\n  }, function(error, event){ console.log(event); });\n\n  // event output example\n  > {\n      returnValues: {\n          myIndexedParam: 20,\n          myOtherIndexedParam: '0x123456789...',\n          myNonIndexParam: 'My String'\n      },\n      raw: {\n          data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n          topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\n      },\n      event: 'MyEvent',\n      signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      logIndex: 0,\n      transactionIndex: 0,\n      transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n      blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      blockNumber: 1234,\n      address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\n  }\n */\n\n\nContract.prototype.once = function (event, options, callback) {\n  const args = Array.prototype.slice.call(arguments); // get the callback\n\n  callback = this._getCallback(args);\n\n  if (!callback) {\n    throw new Error('Once requires a callback as the second parameter.');\n  } // don't allow fromBlock\n\n\n  if (options) {\n    delete options.fromBlock;\n  } // don't return as once shouldn't provide \"on\"\n\n\n  this._on(event, options, function (err, res, sub) {\n    sub.unsubscribe();\n\n    if (_.isFunction(callback)) {\n      callback(err, res, sub);\n    }\n  });\n\n  return undefined;\n};\n/**\n * Adds event listeners and creates a subscription.\n *\n * @method _on\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event subscription\n */\n\n\nContract.prototype._on = function () {\n  const subOptions = this._generateEventOptions.apply(this, arguments); // prevent the event \"newListener\" and \"removeListener\" from being overwritten\n\n\n  this._checkListener('newListener', subOptions.event.name);\n\n  this._checkListener('removeListener', subOptions.event.name); // TODO check if listener already exists? and reuse subscription if options are the same.\n\n\n  const subscription = new Subscription({\n    subscription: {\n      params: 1,\n      inputFormatter: [formatters.inputLogFormatter],\n      outputFormatter: this._decodeEventABI.bind(subOptions.event),\n\n      // DUBLICATE, also in caver-klay\n      subscriptionHandler(output) {\n        this.emit('data', output);\n\n        if (_.isFunction(this.callback)) {\n          this.callback(null, output, this);\n        }\n      }\n\n    },\n    type: 'klay',\n    requestManager: this._requestManager\n  });\n  subscription.subscribe('logs', subOptions.params, subOptions.callback || function () {});\n  return subscription;\n};\n/**\n * Get past events from contracts\n *\n * @method getPastEvents\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the promievent\n */\n\n/**\n * myContract.getPastEvents('MyEvent', {\n      filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23\n      fromBlock: 0,\n      toBlock: 'latest'\n  }, function(error, events){ console.log(events); })\n  .then(function(events){\n      console.log(events) // same results as the optional callback above\n  });\n\n  > [{\n      returnValues: {\n          myIndexedParam: 20,\n          myOtherIndexedParam: '0x123456789...',\n          myNonIndexParam: 'My String'\n      },\n      raw: {\n          data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n          topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\n      },\n      event: 'MyEvent',\n      signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      logIndex: 0,\n      transactionIndex: 0,\n      transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n      blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      blockNumber: 1234,\n      address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\n  },{\n      ...\n  }]\n */\n\n\nContract.prototype.getPastEvents = function () {\n  const subOptions = this._generateEventOptions.apply(this, arguments);\n\n  let getPastLogs = new Method({\n    name: 'getPastLogs',\n    call: 'klay_getLogs',\n    params: 1,\n    inputFormatter: [formatters.inputLogFormatter],\n    outputFormatter: this._decodeEventABI.bind(subOptions.event)\n  });\n  getPastLogs.setRequestManager(this._requestManager);\n  const call = getPastLogs.buildCall();\n  getPastLogs = null;\n  return call(subOptions.params, subOptions.callback);\n};\n/**\n * returns the an object with call, send, estimate functions\n *\n * @method _createTxObject\n * @returns {Object} an object with functions to call the methods\n */\n\n\nContract.prototype._createTxObject = function _createTxObject() {\n  const args = Array.prototype.slice.call(arguments);\n  const txObject = {};\n\n  if (this.method.type === 'function') {\n    txObject.call = this.parent._executeMethod.bind(txObject, 'call');\n    txObject.call.request = this.parent._executeMethod.bind(txObject, 'call', true); // to make batch requests\n  }\n\n  txObject.send = this.parent._executeMethod.bind(txObject, 'send');\n  txObject.send.request = this.parent._executeMethod.bind(txObject, 'send', true); // to make batch requests\n\n  txObject.encodeABI = this.parent._encodeMethodABI.bind(txObject);\n  txObject.estimateGas = this.parent._executeMethod.bind(txObject, 'estimate');\n\n  if (args && this.method.inputs && args.length !== this.method.inputs.length) {\n    if (this.nextMethod) {\n      return this.nextMethod.apply(null, args);\n    }\n\n    throw errors.InvalidNumberOfParams(args.length, this.method.inputs.length, this.method.name);\n  }\n\n  txObject.arguments = args || [];\n  txObject._method = this.method;\n  txObject._parent = this.parent;\n  txObject._klayAccounts = this.parent.constructor._klayAccounts || this._klayAccounts;\n  txObject._keyrings = this.parent._keyrings || this._keyrings;\n\n  if (this.deployData) {\n    txObject._deployData = this.deployData;\n  }\n\n  return txObject;\n};\n/**\n * Generates the options for the execute call\n *\n * @method _processExecuteArguments\n * @param {Array} args\n * @param {Promise} defer\n */\n\n\nContract.prototype._processExecuteArguments = function _processExecuteArguments(args, defer) {\n  const processedArgs = {};\n  processedArgs.type = args.shift(); // get the callback\n\n  processedArgs.callback = this._parent._getCallback(args); // get block number to use for call\n\n  if (processedArgs.type === 'call' && args[args.length - 1] !== true && (_.isString(args[args.length - 1]) || isFinite(args[args.length - 1]))) {\n    processedArgs.defaultBlock = args.pop();\n  } // get the options\n\n\n  processedArgs.options = _.isObject(args[args.length - 1]) ? args.pop() : {}; // get the generateRequest argument for batch requests\n\n  processedArgs.generateRequest = args[args.length - 1] === true ? args.pop() : false;\n  processedArgs.options = this._parent._getOrSetDefaultOptions(processedArgs.options);\n  processedArgs.options.data = this.encodeABI(); // add contract address\n\n  if (!this._deployData && !utils.isAddress(this._parent.options.address)) {\n    throw new Error(\"This contract object doesn't have address set yet, please set an address first.\");\n  }\n\n  if (!this._deployData) {\n    processedArgs.options.to = this._parent.options.address;\n  } // return error, if no \"data\" is specified\n\n\n  if (!processedArgs.options.data) {\n    return utils._fireError(new Error(\"Couldn't find a matching contract method, or the number of parameters is wrong.\"), defer.eventEmitter, defer.reject, processedArgs.callback);\n  }\n\n  return processedArgs;\n};\n/**\n * Executes a call, transact or estimateGas on a contract function\n *\n * @method _executeMethod\n * @param {String} type the type this execute function should execute\n * @param {Boolean} makeRequest if true, it simply returns the request parameters, rather than executing it\n */\n\n\nContract.prototype._executeMethod = function _executeMethod() {\n  const _this = this;\n\n  const args = this._parent._processExecuteArguments.call(this, Array.prototype.slice.call(arguments), defer);\n\n  var defer = utils.promiEvent(args.type !== 'send');\n  /* eslint-disable-line no-var */\n\n  const klayAccounts = _this.constructor._klayAccounts || _this._klayAccounts;\n  const keyrings = _this._parent._keyrings || _this._keyrings; // Not allow to specify options.gas to 0.\n\n  if (args.options && args.options.gas === 0) {\n    throw errors.notAllowedZeroGas();\n  } // simple return request for batch requests\n\n\n  if (args.generateRequest) {\n    const payload = {\n      params: [formatters.inputCallFormatter.call(this._parent, args.options)],\n      callback: args.callback\n    };\n\n    if (args.type === 'call') {\n      payload.params.push(formatters.inputDefaultBlockNumberFormatter.call(this._parent, args.defaultBlock));\n      payload.method = 'klay_call';\n      payload.format = this._parent._decodeMethodReturn.bind(null, this._method.outputs);\n    } else {\n      payload.method = 'klay_sendTransaction';\n    }\n\n    return payload;\n  }\n\n  switch (args.type) {\n    case 'estimate':\n      const estimateGas = new Method({\n        name: 'estimateGas',\n        call: 'klay_estimateGas',\n        params: 1,\n        inputFormatter: [formatters.inputCallFormatter],\n        outputFormatter: utils.hexToNumber,\n        requestManager: _this._parent._requestManager,\n        accounts: klayAccounts,\n        // is klay.accounts (necessary for wallet signing)\n        defaultAccount: _this._parent.defaultAccount,\n        defaultBlock: _this._parent.defaultBlock\n      }).createFunction();\n      return estimateGas(args.options, args.callback);\n\n    case 'call':\n      // TODO check errors: missing \"from\" should give error on deploy and send, call ?\n      const call = new Method({\n        name: 'call',\n        call: 'klay_call',\n        params: 2,\n        inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter],\n\n        // add output formatter for decoding\n        outputFormatter(result) {\n          return _this._parent._decodeMethodReturn(_this._method.outputs, result);\n        },\n\n        requestManager: _this._parent._requestManager,\n        accounts: klayAccounts,\n        // is klay.accounts (necessary for wallet signing)\n        defaultAccount: _this._parent.defaultAccount,\n        defaultBlock: _this._parent.defaultBlock\n      }).createFunction();\n      return call(args.options, args.defaultBlock, args.callback);\n\n    case 'send':\n      // return error, if no \"from\" is specified\n      if (!utils.isAddress(args.options.from)) {\n        return utils._fireError(new Error('No \"from\" address specified in neither the given options, nor the default options.'), defer.eventEmitter, defer.reject, args.callback);\n      }\n\n      if (_.isBoolean(this._method.payable) && !this._method.payable && args.options.value && args.options.value > 0) {\n        return utils._fireError(new Error('Can not send value to non-payable contract method or constructor'), defer.eventEmitter, defer.reject, args.callback);\n      } // make sure receipt logs are decoded\n\n\n      const extraFormatters = {\n        receiptFormatter(receipt) {\n          if (_.isArray(receipt.logs)) {\n            // decode logs\n            const events = _.map(receipt.logs, function (log) {\n              return _this._parent._decodeEventABI.call({\n                name: 'ALLEVENTS',\n                jsonInterface: _this._parent.options.jsonInterface\n              }, log);\n            }); // make log names keys\n\n\n            receipt.events = {};\n            let count = 0;\n            events.forEach(function (ev) {\n              if (ev.event) {\n                // if > 1 of the same event, don't overwrite any existing events\n                if (receipt.events[ev.event]) {\n                  if (Array.isArray(receipt.events[ev.event])) {\n                    receipt.events[ev.event].push(ev);\n                  } else {\n                    receipt.events[ev.event] = [receipt.events[ev.event], ev];\n                  }\n                } else {\n                  receipt.events[ev.event] = ev;\n                }\n              } else {\n                receipt.events[count] = ev;\n                count++;\n              }\n            });\n            delete receipt.logs;\n          }\n\n          return receipt;\n        },\n\n        contractDeployFormatter(receipt) {\n          const newContract = _this._parent.clone(receipt.contractAddress);\n\n          return newContract;\n        }\n\n      };\n      const sendTransaction = new Method({\n        name: 'sendTransaction',\n        call: 'klay_sendTransaction',\n        params: 1,\n        inputFormatter: [formatters.inputTransactionFormatter],\n        requestManager: _this._parent._requestManager,\n        accounts: klayAccounts,\n        // is klay.accounts (necessary for wallet signing)\n        defaultAccount: _this._parent.defaultAccount,\n        defaultBlock: _this._parent.defaultBlock,\n        extraFormatters\n      }).createFunction();\n\n      if (keyrings) {\n        const isExisted = keyrings.getKeyring(args.options.from);\n\n        if (!isExisted) {\n          return sendTransaction(args.options, args.callback);\n        }\n\n        const sendRawTransaction = new Method({\n          name: 'sendRawTransaction',\n          call: 'klay_sendRawTransaction',\n          params: 1,\n          requestManager: _this._parent._requestManager,\n          defaultAccount: _this._parent.defaultAccount,\n          defaultBlock: _this._parent.defaultBlock,\n          extraFormatters\n        }).createFunction();\n        let transaction;\n\n        if (this._deployData !== undefined) {\n          transaction = new SmartContractDeploy(args.options);\n        } else {\n          transaction = new SmartContractExecution(args.options);\n        }\n\n        return keyrings.sign(transaction.from, transaction).then(signedTx => {\n          return sendRawTransaction(signedTx.getRLPEncoding());\n        });\n      }\n\n      if (args.options.type === undefined) {\n        if (this._deployData !== undefined) {\n          args.options.type = 'SMART_CONTRACT_DEPLOY';\n        } else {\n          args.options.type = 'SMART_CONTRACT_EXECUTION';\n        }\n      }\n\n      if (args.options.type !== 'SMART_CONTRACT_EXECUTION' && args.options.type !== 'SMART_CONTRACT_DEPLOY') {\n        throw new Error('Unsupported transaction type. Please use SMART_CONTRACT_EXECUTION or SMART_CONTRACT_DEPLOY.');\n      }\n\n      const fromInWallet = sendTransaction.method.accounts.wallet[args.options.from.toLowerCase()];\n\n      if (!fromInWallet || !fromInWallet.privateKey) {\n        args.options.type = 'LEGACY';\n      }\n\n      return sendTransaction(args.options, args.callback);\n  }\n};\n\nmodule.exports = Contract;","map":null,"metadata":{},"sourceType":"script"}