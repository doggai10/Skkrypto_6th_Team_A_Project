{"ast":null,"code":"var _slicedToArray = require(\"/Users/heeje/Desktop/test/react-dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst AccountLib = require('eth-lib/lib/account');\n\nconst Nat = require('eth-lib/lib/nat');\n\nconst elliptic = require('elliptic');\n\nconst secp256k1 = new elliptic.ec('secp256k1');\n\nconst utils = require('../../../caver-utils');\n\nconst SignatureData = require('./signatureData');\n/**\n * Representing a PrivateKey class that includes private key string.\n * @class\n */\n\n\nclass PrivateKey {\n  /**\n   * creates a privateKey.\n   * @param {string} key - The private key string.\n   */\n  constructor(key) {\n    this.privateKey = key;\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get privateKey() {\n    return this._privateKey;\n  }\n\n  set privateKey(p) {\n    if (!utils.isValidPrivateKey(p)) throw new Error(\"Invalid private key: \".concat(p));\n    this._privateKey = utils.addHexPrefix(p);\n  }\n  /**\n   * signs with transactionHash with key and returns signature.\n   *\n   * @param {string} transactionHash The hash of transaction.\n   * @param {string|number} chainId The chainId or the network.\n   * @return {SignatureData}\n   */\n\n\n  sign(transactionHash, chainId) {\n    chainId = utils.toHex(chainId);\n    const signature = AccountLib.makeSigner(Nat.toNumber(chainId) * 2 + 35)(transactionHash, this.privateKey);\n\n    const _AccountLib$decodeSig = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig))),\n          _AccountLib$decodeSig2 = _slicedToArray(_AccountLib$decodeSig, 3),\n          v = _AccountLib$decodeSig2[0],\n          r = _AccountLib$decodeSig2[1],\n          s = _AccountLib$decodeSig2[2];\n\n    return new SignatureData([v, r, s]);\n  }\n  /**\n   * signs with hashed data and returns `signature`\n   *\n   * @param {string} messageHash The hash of data to sign.\n   * @return {SignatureData}\n   */\n\n\n  signMessage(messageHash) {\n    const signature = AccountLib.sign(messageHash, this.privateKey);\n\n    const _AccountLib$decodeSig3 = AccountLib.decodeSignature(signature),\n          _AccountLib$decodeSig4 = _slicedToArray(_AccountLib$decodeSig3, 3),\n          v = _AccountLib$decodeSig4[0],\n          r = _AccountLib$decodeSig4[1],\n          s = _AccountLib$decodeSig4[2];\n\n    return new SignatureData([v, r, s]);\n  }\n  /**\n   * returns public key string\n   *\n   * @return {string}\n   */\n\n\n  getPublicKey(compressed = false) {\n    const strippedPrivateKey = utils.stripHexPrefix(this.privateKey);\n    const ecKey = secp256k1.keyFromPrivate(Buffer.from(strippedPrivateKey, 'hex'));\n    if (!compressed) return \"0x\".concat(ecKey.getPublic(false, 'hex').slice(2));\n    return \"0x\".concat(ecKey.getPublic(true, 'hex'));\n  }\n  /**\n   * returns derived address from private key string\n   *\n   * @return {string}\n   */\n\n\n  getDerivedAddress() {\n    return AccountLib.fromPrivate(this.privateKey).address.toLowerCase();\n  }\n\n}\n\nmodule.exports = PrivateKey;","map":null,"metadata":{},"sourceType":"script"}