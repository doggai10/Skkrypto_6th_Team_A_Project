{"ast":null,"code":"/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-core-helpers/src/formatters.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file formatters.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\nconst _ = require('lodash');\n\nconst utils = require('../../caver-utils');\n\nconst validateParams = require('../../caver-core-helpers/src/validateFunction').validateParams;\n\nconst _require = require('../../caver-transaction/src/transactionHelper/transactionHelper'),\n      getTypeInt = _require.getTypeInt;\n\nconst AccountKeyLegacy = require('../../caver-account/src/accountKey/accountKeyLegacy');\n\nconst AccountKeyPublic = require('../../caver-account/src/accountKey/accountKeyPublic');\n\nconst AccountKeyFail = require('../../caver-account/src/accountKey/accountKeyFail');\n\nconst AccountKeyWeightedMultiSig = require('../../caver-account/src/accountKey/accountKeyWeightedMultiSig');\n\nconst AccountKeyRoleBased = require('../../caver-account/src/accountKey/accountKeyRoleBased');\n/**\n * Should the format output to a big number\n *\n * @method outputBigNumberFormatter\n * @param {String|Number|BigNumber} number\n * @returns {BigNumber} object\n */\n\n\nconst outputBigNumberFormatter = function (number) {\n  return utils.toBN(number).toString(10);\n};\n\nconst inputDefaultBlockNumberFormatter = function (blockNumber) {\n  if (this && (blockNumber === undefined || blockNumber === null)) {\n    return utils.parsePredefinedBlockNumber(this.defaultBlock) || 'latest';\n  }\n\n  return inputBlockNumberFormatter(blockNumber);\n};\n\nconst inputBlockNumberFormatter = function (blockNumber) {\n  if (blockNumber === undefined) {\n    return undefined;\n  }\n\n  if (utils.isPredefinedBlockNumber(blockNumber)) {\n    return utils.parsePredefinedBlockNumber(blockNumber);\n  }\n\n  return utils.isHexStrict(blockNumber) ? _.isString(blockNumber) ? blockNumber.toLowerCase() : blockNumber : utils.numberToHex(blockNumber);\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method _txInputFormatter\n * @param {Object} transaction options\n * @returns object\n */\n\n\nconst _txInputFormatter = function (options) {\n  if (options.from) {\n    options.from = inputAddressFormatter(options.from);\n  }\n\n  if (options.to) {\n    if (options.type && options.type.includes('DEPLOY')) options.humanReadable = options.humanReadable !== undefined ? options.humanReadable : false;\n    if (options.humanReadable) throw new Error('HumanReadableAddress is not supported yet.');\n\n    if (!utils.isContractDeployment(options) || options.to !== '0x') {\n      options.to = inputAddressFormatter(options.to);\n    }\n  }\n\n  if (options.data && options.input && !options.type.includes('TxType')) {\n    throw new Error('You can\\'t have \"data\" and \"input\" as properties of transactions at the same time, please use either \"data\" or \"input\" instead.');\n  }\n\n  if (!options.data && options.input) {\n    options.data = options.input;\n    delete options.input;\n  }\n\n  if (options.data && !utils.isHex(options.data)) {\n    options.data = utils.toHex(options.data);\n  } // allow both\n\n\n  if (options.gas || options.gasLimit) {\n    options.gas = options.gas || options.gasLimit;\n  }\n\n  const fieldToBeHex = ['gasPrice', 'gas', 'value', 'nonce', 'feeRatio'];\n  fieldToBeHex.filter(function (key) {\n    return options[key] !== undefined;\n  }).forEach(function (key) {\n    options[key] = utils.numberToHex(options[key]);\n  });\n  return options;\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputCallFormatter\n * @param {Object} transaction options\n * @returns object\n */\n\n\nconst inputCallFormatter = function (options) {\n  options = _txInputFormatter(options);\n  const from = options.from || (this ? this.defaultAccount : null);\n\n  if (from) {\n    options.from = inputAddressFormatter(from);\n  }\n\n  return options;\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputTransactionFormatter\n * @param {Object} options\n * @returns object\n */\n\n\nconst inputTransactionFormatter = function (options) {\n  options = _txInputFormatter(options); // If senderRawTransaction' exist in transaction, it means object is fee payer transaction format like below\n  // { senderRawTransaction: '', feePayer: '' }\n\n  if (options.senderRawTransaction) {\n    if (options.feePayer === undefined) {\n      throw new Error('The \"feePayer\" field must be defined for signing with feePayer!');\n    }\n\n    options.feePayer = inputAddressFormatter(options.feePayer);\n    return options;\n  } // check from, only if not number, or object\n\n\n  if (!_.isNumber(options.from) && !_.isObject(options.from)) {\n    options.from = options.from || (this ? this.defaultAccount : null);\n\n    if (!options.from && !_.isNumber(options.from)) {\n      throw new Error('The send transactions \"from\" field must be defined!');\n    }\n\n    options.from = inputAddressFormatter(options.from);\n  }\n\n  if (options.data) {\n    options.data = utils.addHexPrefix(options.data);\n  }\n\n  const err = validateParams(options);\n\n  if (err) {\n    throw err;\n  } // Set typeInt value in object\n\n\n  const typeInt = getTypeInt(options.type);\n  if (typeInt !== '') options.typeInt = typeInt;\n  return options;\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputPersonalTransactionFormatter\n * @param {Object} options\n * @returns object\n */\n\n\nconst inputPersonalTransactionFormatter = function (options) {\n  options = _txInputFormatter(options); // check from, only if not number, or object\n\n  if (!_.isNumber(options.from) && !_.isObject(options.from)) {\n    options.from = options.from || (this ? this.defaultAccount : null);\n\n    if (!options.from && !_.isNumber(options.from)) {\n      throw new Error('The send transactions \"from\" field must be defined!');\n    }\n\n    options.from = inputAddressFormatter(options.from);\n  }\n\n  if (options.data) {\n    options.data = utils.addHexPrefix(options.data);\n  }\n\n  return options;\n};\n/**\n * Hex encodes the data passed to klay_sign and personal_sign\n *\n * @method inputSignFormatter\n * @param {String} data\n * @returns {String}\n */\n\n\nconst inputSignFormatter = function (data) {\n  return utils.isHexStrict(data) ? data : utils.utf8ToHex(data);\n};\n/**\n * Formats the accountKey to object which defines `keyType` and `key`\n *\n * @method inputAccountKeyFormatter\n * @param {AccountKeyLegacy|AccountKeyPublic|AccountKeyFail|AccountKeyWeightedMultiSig|AccountKeyRoleBased|object} accountKey\n * @returns {object}\n */\n\n\nconst inputAccountKeyFormatter = function (accountKey) {\n  if (accountKey instanceof AccountKeyLegacy) return {\n    keyType: 1,\n    key: {}\n  };\n  if (accountKey instanceof AccountKeyPublic) return {\n    keyType: 2,\n    key: {\n      x: accountKey.getXYPoint()[0],\n      y: accountKey.getXYPoint()[1]\n    }\n  };\n  if (accountKey instanceof AccountKeyFail) return {\n    keyType: 3,\n    key: {}\n  };\n\n  if (accountKey instanceof AccountKeyWeightedMultiSig) {\n    const weightedMultiSig = {\n      threshold: accountKey.threshold,\n      keys: []\n    };\n\n    for (const wp of accountKey.weightedPublicKeys) {\n      weightedMultiSig.keys.push({\n        weight: wp.weight,\n        key: {\n          x: utils.xyPointFromPublicKey(wp.publicKey)[0],\n          y: utils.xyPointFromPublicKey(wp.publicKey)[1]\n        }\n      });\n    }\n\n    return {\n      keyType: 4,\n      key: weightedMultiSig\n    };\n  }\n\n  if (accountKey instanceof AccountKeyRoleBased) {\n    const key = [];\n\n    for (const k of accountKey.accountKeys) {\n      key.push(inputAccountKeyFormatter(k));\n    }\n\n    return {\n      keyType: 5,\n      key\n    };\n  }\n\n  if (accountKey.keyType === undefined || accountKey.key === undefined) {\n    throw new Error(\"AccountKey obejct should define 'keyType' and 'key'\");\n  }\n\n  return accountKey;\n};\n/**\n * Formats the output of a transaction to its proper values\n *\n * @method outputTransactionFormatter\n * @param {Object} tx\n * @returns {Object}\n */\n\n\nconst outputTransactionFormatter = function (tx) {\n  if (!tx) return null;\n\n  if (tx.blockNumber !== undefined) {\n    tx.blockNumber = utils.hexToNumber(tx.blockNumber);\n  }\n\n  if (tx.transactionIndex !== undefined) {\n    tx.transactionIndex = utils.hexToNumber(tx.transactionIndex);\n  }\n\n  tx.nonce = utils.hexToNumber(tx.nonce);\n  tx.gas = utils.hexToNumber(tx.gas);\n  tx.gasPrice = outputBigNumberFormatter(tx.gasPrice);\n\n  if (tx.value) {\n    tx.value = outputBigNumberFormatter(tx.value);\n  }\n\n  if (tx.to && utils.isAddress(tx.to)) {\n    // tx.to could be `0x0` or `null` while contract creation\n    tx.to = utils.toChecksumAddress(tx.to);\n  } else {\n    tx.to = null; // set to `null` if invalid address\n  }\n\n  if (tx.from) {\n    tx.from = utils.toChecksumAddress(tx.from);\n  }\n\n  return tx;\n};\n/**\n * Formats the output of a transaction receipt to its proper values\n *\n * @method outputTransactionReceiptFormatter\n * @param {Object} receipt\n * @returns {Object}\n */\n\n\nconst outputTransactionReceiptFormatter = function (receipt) {\n  if (!receipt) return null;\n\n  if (typeof receipt !== 'object') {\n    throw new Error(\"Received receipt is invalid: \".concat(receipt));\n  }\n\n  if (receipt.blockNumber !== undefined) {\n    receipt.blockNumber = utils.hexToNumber(receipt.blockNumber);\n  }\n\n  if (receipt.transactionIndex !== undefined) {\n    receipt.transactionIndex = utils.hexToNumber(receipt.transactionIndex);\n  }\n\n  receipt.gasUsed = utils.hexToNumber(receipt.gasUsed);\n\n  if (_.isArray(receipt.logs)) {\n    receipt.logs = receipt.logs.map(outputLogFormatter);\n  }\n\n  if (receipt.contractAddress) {\n    receipt.contractAddress = utils.toChecksumAddress(receipt.contractAddress);\n  }\n\n  if (typeof receipt.status !== 'undefined') {\n    receipt.status = parseInt(receipt.status) === 1;\n  }\n\n  return receipt;\n};\n/**\n * Formats the output of a block to its proper values\n *\n * @method outputBlockFormatter\n * @param {Object} block\n * @returns {Object}\n */\n\n\nconst outputBlockFormatter = function (block) {\n  // transform to number\n  block.gasLimit = utils.hexToNumber(block.gasLimit);\n  block.gasUsed = utils.hexToNumber(block.gasUsed);\n  block.size = utils.hexToNumber(block.size);\n  block.timestamp = utils.hexToNumber(block.timestamp);\n\n  if (block.number !== undefined) {\n    block.number = utils.hexToNumber(block.number);\n  }\n\n  if (block.difficulty) {\n    block.difficulty = outputBigNumberFormatter(block.difficulty);\n  }\n\n  if (block.totalDifficulty) {\n    block.totalDifficulty = outputBigNumberFormatter(block.totalDifficulty);\n  }\n\n  if (_.isArray(block.transactions)) {\n    block.transactions.forEach(function (item) {\n      if (!_.isString(item)) {\n        return outputTransactionFormatter(item);\n      }\n    });\n  }\n\n  if (block.miner) {\n    block.miner = utils.toChecksumAddress(block.miner);\n  }\n\n  return block;\n};\n/**\n * inputLogFormatter's inner function\n * format topic values\n */\n\n\nconst toTopic = function (value) {\n  if (value === null || typeof value === 'undefined') {\n    return null;\n  }\n\n  value = String(value); // If value is not hex string, return it\n\n  if (value.indexOf('0x') === 0) {\n    return value;\n  }\n\n  return utils.fromUtf8(value);\n};\n/**\n * Formats the input of a log\n *\n * @method inputLogFormatter\n * @param {Object} log object\n * @returns {Object} log\n */\n\n\nconst inputLogFormatter = function (options) {\n  // make sure topics, get converted to hex\n  options.topics = (options.topics || []).map(topic => _.isArray(topic) ? topic.map(toTopic) : toTopic(topic));\n\n  if (options.address) {\n    options.address = _.isArray(options.address) ? options.address.map(addr => inputAddressFormatter(addr)) : inputAddressFormatter(options.address);\n  } // if `fromBlock`, `toBlock` type is number, convert it to hex string.\n\n\n  options.fromBlock = typeof options.fromBlock === 'number' ? utils.numberToHex(options.fromBlock) : options.fromBlock;\n  options.toBlock = typeof options.toBlock === 'number' ? utils.numberToHex(options.toBlock) : options.toBlock;\n  return options;\n};\n/**\n * Formats the output of a log\n *\n * @method outputLogFormatter\n * @param {Object} log object\n * @returns {Object} log\n */\n\n\nconst outputLogFormatter = function (log) {\n  // `removed` field is unnecessary,\n  // since it isn't possible for block to be removed in Klaytn consensus scenario.\n  delete log.removed; // generate a custom log id\n\n  if (typeof log.blockHash === 'string' && typeof log.transactionHash === 'string' && typeof log.logIndex === 'string') {\n    const shaId = utils.sha3(log.blockHash.replace('0x', '') + log.transactionHash.replace('0x', '') + log.logIndex.replace('0x', ''));\n    log.id = \"log_\".concat(shaId.replace('0x', '').substr(0, 8));\n  } else if (!log.id) {\n    log.id = null;\n  }\n\n  if (log.blockNumber !== undefined) {\n    log.blockNumber = utils.hexToNumber(log.blockNumber);\n  }\n\n  if (log.transactionIndex !== undefined) {\n    log.transactionIndex = utils.hexToNumber(log.transactionIndex);\n  }\n\n  if (log.logIndex !== undefined) {\n    log.logIndex = utils.hexToNumber(log.logIndex);\n  }\n\n  if (log.address) {\n    log.address = utils.toChecksumAddress(log.address);\n  }\n\n  return log;\n};\n/**\n * Formats the input of a whisper post and converts all values to HEX\n *\n * @method inputPostFormatter\n * @param {Object} transaction object\n * @returns {Object}\n */\n\n\nconst inputPostFormatter = function (post) {\n  // post.payload = utils.toHex(post.payload);\n  if (post.ttl) {\n    post.ttl = utils.numberToHex(post.ttl);\n  }\n\n  if (post.workToProve) {\n    post.workToProve = utils.numberToHex(post.workToProve);\n  }\n\n  if (post.priority) {\n    post.priority = utils.numberToHex(post.priority);\n  } // fallback\n\n\n  if (!_.isArray(post.topics)) {\n    post.topics = post.topics ? [post.topics] : [];\n  } // format the following options\n\n\n  post.topics = post.topics.map(function (topic) {\n    // convert only if not hex\n    return topic.indexOf('0x') === 0 ? topic : utils.fromUtf8(topic);\n  });\n  return post;\n};\n/**\n * Formats the output of a received post message\n *\n * @method outputPostFormatter\n * @param {Object}\n * @returns {Object}\n */\n\n\nconst outputPostFormatter = function (post) {\n  post.expiry = utils.hexToNumber(post.expiry);\n  post.sent = utils.hexToNumber(post.sent);\n  post.ttl = utils.hexToNumber(post.ttl);\n  post.workProved = utils.hexToNumber(post.workProved); // post.payloadRaw = post.payload;\n  // post.payload = utils.hexToAscii(post.payload);\n  // if (utils.isJson(post.payload)) {\n  //     post.payload = JSON.parse(post.payload);\n  // }\n  // format the following options\n\n  if (!post.topics) {\n    post.topics = [];\n  }\n\n  post.topics = post.topics.map(function (topic) {\n    return utils.toUtf8(topic);\n  });\n  return post;\n};\n\nconst inputAddressFormatter = function (address) {\n  const iban = new utils.Iban(address);\n\n  if (iban.isValid() && iban.isDirect()) {\n    return iban.toAddress().toLowerCase();\n  }\n\n  if (utils.isAddress(address)) {\n    return \"0x\".concat(address.toLowerCase().replace('0x', ''));\n  }\n\n  throw new Error(\"Provided address \\\"\".concat(address, \"\\\" is invalid, the capitalization checksum test failed.\"));\n};\n\nconst outputSyncingFormatter = function (result) {\n  result.startingBlock = utils.hexToNumber(result.startingBlock);\n  result.currentBlock = utils.hexToNumber(result.currentBlock);\n  result.highestBlock = utils.hexToNumber(result.highestBlock);\n\n  if (result.knownStates) {\n    result.knownStates = utils.hexToNumber(result.knownStates);\n    result.pulledStates = utils.hexToNumber(result.pulledStates);\n  }\n\n  return result;\n};\n\nconst inputRawKeyFormatter = function (rawKey) {\n  if (rawKey.slice(0, 2) === '0x') rawKey = rawKey.slice(2);\n  return rawKey;\n};\n\nconst toBoolean = v => !!v;\n\nmodule.exports = {\n  inputDefaultBlockNumberFormatter: inputDefaultBlockNumberFormatter,\n  inputBlockNumberFormatter: inputBlockNumberFormatter,\n  inputCallFormatter: inputCallFormatter,\n  inputTransactionFormatter: inputTransactionFormatter,\n  inputPersonalTransactionFormatter: inputPersonalTransactionFormatter,\n  inputAddressFormatter: inputAddressFormatter,\n  inputPostFormatter: inputPostFormatter,\n  inputLogFormatter: inputLogFormatter,\n  inputSignFormatter: inputSignFormatter,\n  inputRawKeyFormatter: inputRawKeyFormatter,\n  inputAccountKeyFormatter: inputAccountKeyFormatter,\n  outputBigNumberFormatter: outputBigNumberFormatter,\n  outputTransactionFormatter: outputTransactionFormatter,\n  outputTransactionReceiptFormatter: outputTransactionReceiptFormatter,\n  outputBlockFormatter: outputBlockFormatter,\n  outputLogFormatter: outputLogFormatter,\n  outputPostFormatter: outputPostFormatter,\n  outputSyncingFormatter: outputSyncingFormatter,\n  // moved from util\n  toChecksumAddress: utils.toChecksumAddress,\n  hexToNumber: utils.hexToNumber,\n  numberToHex: utils.numberToHex,\n  toBoolean: toBoolean\n};","map":null,"metadata":{},"sourceType":"script"}