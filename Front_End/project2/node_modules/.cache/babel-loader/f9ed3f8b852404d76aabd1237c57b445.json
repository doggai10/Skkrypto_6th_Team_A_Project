{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * jsonrpc 초기화, messageId 는 항상 0 부터 시작한다.\n */\n// Initialize Jsonrpc as a simple object with utility functions.\nvar Jsonrpc = {\n  messageId: 0\n};\n/**\n * Should be called to valid json create payload object\n *\n * @method toPayload\n * @param {Function} method of jsonrpc call, required\n * @param {Array} params, an array of method params, optional\n * @returns {Object} valid jsonrpc payload object\n */\n\n/**\n * jsonrpc 를 위한 유틸리티 함수\n * method와 params를 받아서 messageId를 하나씩 카운팅 올려주면서\n * jsonrpc에 맞는 메시지 규약으로 싸준다.\n * jsonrpc의 request object에 'method' property는 필수적으로 있어야 하기 때문에,\n * method가 존재하지 않는다면 에러를 뱉어준다.\n * 실행시마다 messageId 가 순차적으로 증가 됨\n * jsonrpc 버전은 2.0으로 고정 됨\n */\n\nJsonrpc.toPayload = function (method, params) {\n  /**\n   * parameter로 'method'가 안날아왔다면 에러 뱉기\n   */\n  if (!method) {\n    throw new Error('JSONRPC method should be specified for params: \"' + JSON.stringify(params) + '\"!');\n  }\n  /**\n   * message를 jsonrpc 규약에 맞게 감쌀때마다 messageId 하나씩 올려주기.\n   */\n\n\n  Jsonrpc.messageId++;\n  /**\n   * jsonrpc 규약에 맞는 reqeust object로 변형.\n   */\n\n  return {\n    jsonrpc: '2.0',\n    id: Jsonrpc.messageId,\n    method: method,\n    params: params || []\n  };\n};\n/**\n * jsonrpc 규약에 맞는 response object인지 확인해주는 함수.\n */\n\n\nJsonrpc.isValidResponse = function (response) {\n  /**\n   * response가 array로 들어올 경우에도 valid함을 판단하는데,\n   * array의 native 메서드인 'every'를 통해서 배열 아이템 중 하나라도 valid하지 않다면 false를 뱉는다.\n   * array가 아니라면, 하나의 response에 대해서만 validation을 거친다.\n   */\n  return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);\n  /**\n   * valid한 jsonrpc response란,\n   * i) 당연히 message가 truthy한 값이며\n   * ii) message.error가 없을 것이며,\n   * iii) message.jsonrpc가 '2.0' 버전으로 선언되어 있어야 하며,\n   * iv) message.id가 'number'나 'string' 타입중 하나여야 하며,\n   * v) message.result가 정의되어 있어야 한다. (undefined가 아니어야 한다.)\n   */\n\n  function validateSingleMessage(message) {\n    /**\n     * !! 은 null 을 배제하고 true or false 로 하기 위한 것\n     * https://stackoverflow.com/questions/784929/what-is-the-not-not-operator-in-javascript\n     */\n    return !!message && !message.error && message.jsonrpc === '2.0' && (typeof message.id === 'number' || typeof message.id === 'string') && message.result !== undefined; // only undefined is not valid json object\n  }\n};\n/**\n * Batch Call 을 위한 payload 생성 유틸리티 함수\n * toBatchPayload 함수는 단순히, message가 배열로 날아왔을때, 이 각각 아이템들을 돌면서\n * 위에서 보았던 toPayload를 각각 적용해준 값을 다시금 배열로서 뱉는 함수이다.\n * ex) [{ method: 'A', params: 1 }, { method: 'B', params: 4 }, { method: 'C', params: 2 }]\n * 로 messages 배열이 구성되어 있었다면, toBatchPayload를 돌리고 난 후 리턴된 값은,\n * [\n *  { jsonrpc: '2.0', id: 0, method: 'A', params: 1 },\n *  { jsonrpc: '2.0', id: 1, method: 'B', params: 4 },\n *  { jsonrpc: '2.0', id: 2, method: 'C', params: 2 },\n * ]\n * 가 되는 것이다.\n */\n\n\nJsonrpc.toBatchPayload = function (messages) {\n  return messages.map(function (message) {\n    return Jsonrpc.toPayload(message.method, message.params);\n  });\n};\n\nmodule.exports = Jsonrpc;","map":null,"metadata":{},"sourceType":"script"}