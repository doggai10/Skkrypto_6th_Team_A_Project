{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst _ = require('lodash');\n\nconst Bytes = require('eth-lib/lib/bytes');\n\nconst RLP = require('eth-lib/lib/rlp');\n\nconst Hash = require('eth-lib/lib/hash');\n\nconst TransactionHasher = require('../transactionHasher/transactionHasher');\n\nconst utils = require('../../../caver-utils');\n\nconst Keyring = require('../../../caver-wallet/src/keyring/keyringFactory');\n\nconst AbstractKeyring = require('../../../caver-wallet/src/keyring/abstractKeyring');\n\nconst {\n  TX_TYPE_STRING,\n  refineSignatures,\n  typeDetectionFromRLPEncoding\n} = require('../transactionHelper/transactionHelper');\n\nconst {\n  KEY_ROLE\n} = require('../../../caver-wallet/src/keyring/keyringHelper');\n\nconst {\n  validateParams\n} = require('../../../caver-core-helpers/src/validateFunction');\n\nconst SignatureData = require('../../../caver-wallet/src/keyring/signatureData');\n/**\n * Abstract class that implements common logic for each transaction type.\n * @class\n */\n\n\nclass AbstractTransaction {\n  /**\n   * Abstract class that implements common logic for each transaction type.\n   * In this constructor, type, tag, nonce, gasPrice, chainId, gas and signatures are set as transaction member variables.\n   *\n   * @constructor\n   * @param {string} typeString - The type string of transaction.\n   * @param {object} createTxObj - The parameters to create a transaction instance.\n   */\n  constructor(typeString, createTxObj) {\n    this._type = typeString;\n    createTxObj.type = typeString;\n    const err = validateParams(createTxObj);\n    if (err) throw err;\n    this.from = createTxObj.from;\n    this.gas = createTxObj.gas; // The variables below are values that the user does not need to pass to the parameter.\n\n    if (createTxObj.nonce !== undefined) this.nonce = createTxObj.nonce;\n    if (createTxObj.gasPrice !== undefined) this.gasPrice = createTxObj.gasPrice;\n    if (createTxObj.chainId !== undefined) this.chainId = createTxObj.chainId;\n    this.signatures = createTxObj.signatures || [];\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get type() {\n    return this._type;\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get from() {\n    return this._from;\n  }\n\n  set from(address) {\n    if (this.type === TX_TYPE_STRING.TxTypeLegacyTransaction && address === '0x') {\n      this._from = address.toLowerCase();\n    } else {\n      if (!utils.isAddress(address)) throw new Error(`Invalid address ${address}`);\n      this._from = address.toLowerCase();\n    }\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get nonce() {\n    return this._nonce;\n  }\n\n  set nonce(n) {\n    this._nonce = utils.numberToHex(n);\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get gas() {\n    return this._gas;\n  }\n\n  set gas(g) {\n    this._gas = utils.numberToHex(g);\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get gasPrice() {\n    return this._gasPrice;\n  }\n\n  set gasPrice(g) {\n    this._gasPrice = utils.numberToHex(g);\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get chainId() {\n    return this._chainId;\n  }\n\n  set chainId(ch) {\n    this._chainId = utils.toHex(ch);\n  }\n  /**\n   * @type {Array<string>|Array.<Array<string>>}\n   */\n\n\n  get signatures() {\n    return this._signatures;\n  }\n\n  set signatures(sigs) {\n    this._signatures = refineSignatures(sigs, this.type === TX_TYPE_STRING.TxTypeLegacyTransaction);\n  }\n  /**\n   * Returns the RLP-encoded string of this transaction (i.e., rawTransaction).\n   * This method has to be overrided in classes which extends AbstractTransaction.\n   *\n   * @return {string}\n   */\n\n\n  getRLPEncoding() {\n    throw new Error(`Not implemented.`);\n  }\n  /**\n   * Returns the RLP-encoded string to make the signature of this transaction.\n   * This method has to be overrided in classes which extends AbstractTransaction.\n   * getCommonRLPEncodingForSignature is used in getRLPEncodingForSignature.\n   *\n   * @return {string}\n   */\n\n\n  getCommonRLPEncodingForSignature() {\n    throw new Error(`Not implemented.`);\n  }\n  /**\n   * Signs to the transaction with private key(s) in the `key`.\n   * @async\n   * @param {Keyring|string} key - The instance of Keyring, private key string or KlaytnWalletKey string.\n   * @param {number} [index] - The index of private key to use. If index is undefined, all private keys in keyring will be used.\n   * @param {function} [hasher] - The function to get hash of transaction. In order to use a custom hasher, the index must be defined.\n   * @return {Transaction}\n   */\n\n\n  async sign(key, index, hasher = TransactionHasher.getHashForSignature) {\n    // User parameter input cases\n    // (key) / (key index) / (key hasher) / (key index hasher)\n    if (_.isFunction(index)) {\n      hasher = index;\n      index = undefined;\n    }\n\n    let keyring = key;\n\n    if (_.isString(key)) {\n      keyring = Keyring.createFromPrivateKey(key);\n    }\n\n    if (!(keyring instanceof AbstractKeyring)) throw new Error(`Unsupported key type. The key must be a single private key string, KlaytnWalletKey string, or Keyring instance.`); // When user attempt to sign with a updated keyring into a TxTypeLegacyTransaction error should be thrown.\n\n    if (this.type === TX_TYPE_STRING.TxTypeLegacyTransaction && keyring.isDecoupled()) throw new Error(`A legacy transaction cannot be signed with a decoupled keyring.`);\n    if (!this.from || this.from === '0x') this.from = keyring.address;\n    if (this.from.toLowerCase() !== keyring.address.toLowerCase()) throw new Error(`The from address of the transaction is different with the address of the keyring to use.`);\n    await this.fillTransaction();\n    const hash = hasher(this);\n    const role = this.type.includes('AccountUpdate') ? KEY_ROLE.roleAccountUpdateKey : KEY_ROLE.roleTransactionKey;\n    const sig = keyring.sign(hash, this.chainId, role, index);\n    this.appendSignatures(sig);\n    return this;\n  }\n  /**\n   * Appends signatures to the transaction.\n   *\n   * @param {SignatureData|Array.<SignatureData>|Array.<string>|Array.<Array.<string>>} signatures - An array of signatures to append to the transaction.\n   *                                                      One signature can be defined in the form of a one-dimensional array or two-dimensional array,\n   *                                                      and more than one signatures should be defined in the form of a two-dimensional array.\n   */\n\n\n  appendSignatures(signatures) {\n    let sig = signatures;\n    if (_.isString(sig)) sig = utils.resolveSignature(sig);\n    if (sig instanceof SignatureData) sig = [sig];\n    if (!_.isArray(sig)) throw new Error(`Failed to append signatures: invalid signatures format ${sig}`);\n    if (_.isString(sig[0])) sig = [sig];\n    this.signatures = this.signatures.concat(sig);\n  }\n  /**\n   * Combines RLP-encoded transactions (rawTransaction) to the transaction from RLP-encoded transaction strings and returns a single transaction with all signatures combined.\n   * When combining the signatures into a transaction instance,\n   * an error is thrown if the decoded transaction contains different value except signatures.\n   *\n   * @param {Array.<string>} rlpEncodedTxs - An array of RLP-encoded transaction strings.\n   * @return {string}\n   */\n\n\n  combineSignedRawTransactions(rlpEncodedTxs) {\n    if (!_.isArray(rlpEncodedTxs)) throw new Error(`The parameter must be an array of RLP-encoded transaction strings.`); // If the signatures are empty, there may be an undefined member variable.\n    // In this case, the empty information is filled with the decoded result.\n\n    let fillVariables = false;\n    if (utils.isEmptySig(this.signatures)) fillVariables = true;\n\n    for (const encoded of rlpEncodedTxs) {\n      const type = typeDetectionFromRLPEncoding(encoded);\n      if (this.type !== type) throw new Error(`Transaction type mismatch: Signatures from different transactions cannot be combined.`);\n      const decoded = this.constructor.decode(encoded); // Signatures can only be combined for the same transaction.\n      // Therefore, compare whether the decoded transaction is the same as this.\n\n      for (const k in decoded) {\n        if (k === '_signatures' || k === '_feePayerSignatures') continue;\n        if (this[k] === undefined && fillVariables) this[k] = decoded[k];\n        const differentTxError = `Transactions containing different information cannot be combined.`; // Compare with the RLP-encoded accountKey string, because 'account' is an object.\n\n        if (k === '_account') {\n          if (this[k].getRLPEncodingAccountKey() !== decoded[k].getRLPEncodingAccountKey()) throw new Error(differentTxError);\n          continue;\n        }\n\n        if (this[k] !== decoded[k]) throw new Error(differentTxError);\n      }\n\n      this.appendSignatures(decoded.signatures);\n    }\n\n    return this.getRLPEncoding();\n  }\n  /**\n   * Returns RawTransaction(RLP-encoded transaction string)\n   *\n   * @return {string}\n   */\n\n\n  getRawTransaction() {\n    return this.getRLPEncoding();\n  }\n  /**\n   * Returns a hash string of transaction\n   *\n   * @return {string}\n   */\n\n\n  getTransactionHash() {\n    return Hash.keccak256(this.getRLPEncoding());\n  }\n  /**\n   * Returns a senderTxHash of transaction\n   *\n   * @return {string}\n   */\n\n\n  getSenderTxHash() {\n    return this.getTransactionHash();\n  }\n  /**\n   * Returns an RLP-encoded transaction string for making signature\n   *\n   * @return {string}\n   */\n\n\n  getRLPEncodingForSignature() {\n    this.validateOptionalValues();\n    if (this.chainId === undefined) throw new Error(`chainId is undefined. Define chainId in transaction or use 'transaction.fillTransaction' to fill values.`);\n    return RLP.encode([this.getCommonRLPEncodingForSignature(), Bytes.fromNat(this.chainId), '0x', '0x']);\n  }\n  /**\n   * Fills empty optional transaction properties(gasPrice, nonce, chainId).\n   */\n\n\n  async fillTransaction() {\n    const [chainId, gasPrice, nonce] = await Promise.all([isNot(this.chainId) ? AbstractTransaction._klaytnCall.getChainId() : this.chainId, isNot(this.gasPrice) ? AbstractTransaction._klaytnCall.getGasPrice() : this.gasPrice, isNot(this.nonce) ? AbstractTransaction._klaytnCall.getTransactionCount(this.from, 'pending') : this.nonce]);\n    this.chainId = chainId;\n    this.gasPrice = gasPrice;\n    this.nonce = nonce;\n  }\n  /**\n   * Checks that member variables that can be defined by the user are defined.\n   * If there is an undefined variable, an error occurs.\n   */\n\n\n  validateOptionalValues() {\n    if (this.gasPrice === undefined) throw new Error(`gasPrice is undefined. Define gasPrice in transaction or use 'transaction.fillTransaction' to fill values.`);\n    if (this.nonce === undefined) throw new Error(`nonce is undefined. Define nonce in transaction or use 'transaction.fillTransaction' to fill values.`);\n  }\n\n}\n\nconst isNot = function (value) {\n  return _.isUndefined(value) || _.isNull(value);\n};\n\nmodule.exports = AbstractTransaction;","map":null,"metadata":{},"sourceType":"script"}