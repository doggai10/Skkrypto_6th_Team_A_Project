{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst AbstractKeyring = require('./abstractKeyring');\n\nconst utils = require('../../../caver-utils');\n\nconst PrivateKey = require('./privateKey');\n\nconst {\n  KEY_ROLE\n} = require('./keyringHelper');\n\nconst Account = require('../../../caver-account');\n\nconst {\n  validateForSigning,\n  validateIndexWithKeys,\n  encryptKey,\n  formatEncrypted\n} = require('./keyringHelper');\n/**\n * representing a Keyring which includes `address` and a `private key`.\n * @class\n */\n\n\nclass SingleKeyring extends AbstractKeyring {\n  /**\n   * creates a SingleKeyring.\n   * @param {string} address - The address of keyring.\n   * @param {string|PrivateKey} key - The key to use in SingleKeyring.\n   */\n  constructor(address, key) {\n    super(address);\n    this.key = key;\n  }\n  /**\n   * @type {PrivateKey}\n   */\n\n\n  get key() {\n    return this._key;\n  }\n\n  set key(keyInput) {\n    if (keyInput === null) {\n      this._key = null;\n      return;\n    }\n\n    this._key = keyInput instanceof PrivateKey ? keyInput : new PrivateKey(keyInput);\n  }\n  /**\n   * returns public key string.\n   *\n   * @return {string}\n   */\n\n\n  getPublicKey() {\n    return this.key.getPublicKey();\n  }\n  /**\n   * returns a copied singleKeyring instance\n   *\n   * @return {SingleKeyring}\n   */\n\n\n  copy() {\n    return new SingleKeyring(this.address, this.key);\n  }\n  /**\n   * signs with transactionHash with a key and returns signature(s).\n   *\n   * @param {string} transactionHash The hash of transaction.\n   * @param {string|number} chainId The chainId specific to the network.\n   * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n   * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n   * @return {Array.<string>|Array.<Array.<string>>}\n   */\n\n\n  sign(transactionHash, chainId, role, index) {\n    validateForSigning(transactionHash, chainId);\n    const key = this.getKeyByRole(role);\n\n    if (index !== undefined) {\n      validateIndexWithKeys(index, 1);\n      return key.sign(transactionHash, chainId);\n    }\n\n    return [key.sign(transactionHash, chainId)];\n  }\n  /**\n   * signs with hashed message and returns result object that includes `signatures`, `message` and `messageHash`\n   *\n   * @param {string} message The message string to sign.\n   * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n   * @param {number} [index] The index of the key to be used.\n   * @return {object}\n   */\n\n\n  signMessage(message, role, index) {\n    if (role === undefined) throw new Error(`role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.`);\n    const messageHash = utils.hashMessage(message);\n    const key = this.getKeyByRole(role);\n    const signatures = [];\n\n    if (index !== undefined) {\n      validateIndexWithKeys(index, 1);\n    }\n\n    signatures.push(key.signMessage(messageHash));\n    return {\n      messageHash,\n      signatures,\n      message\n    };\n  }\n  /**\n   * returns keys by role. If the key of the role passed as parameter is empty, the default key is returned.\n   *\n   * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n   * @return {Array.<PrivateKey>}\n   */\n\n\n  getKeyByRole(role) {\n    if (role === undefined) throw new Error(`role should be defined.`);\n    if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(`Invalid role number: ${role}`);\n    return this.key;\n  }\n  /**\n   * returns KlaytnWalletKey format. If keyring uses more than one private key, this function will throw error.\n   *\n   * @return {string}\n   */\n\n\n  getKlaytnWalletKey() {\n    return `${this.key.privateKey}0x00${this.address}`;\n  }\n  /**\n   * returns an instance of Account.\n   *\n   * @return {Account}\n   */\n\n\n  toAccount() {\n    if (!this.key) throw new Error(`Failed to create Account instance: Empty key in keyring.`);\n    const publicKey = this.getPublicKey();\n    return Account.createWithAccountKeyPublic(this.address, publicKey);\n  }\n  /**\n   * encrypts a keyring and returns a keystore v4 object.\n   *\n   * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n   * @param {object} options The options to use when encrypt a keyring. Also address can be defined specifically in options object.\n   * @return {object}\n   */\n\n  /**\n   * options can include below\n   * {\n   *   salt: ...,\n   *   iv: ...,\n   *   kdf: ...,\n   *   dklen: ...,\n   *   c: ...,\n   *   n: ...,\n   *   r: ...,\n   *   p: ...,\n   *   cipher: ...,\n   *   uuid: ...,\n   *   cipher: ...,\n   * }\n   */\n\n\n  encrypt(password, options = {}) {\n    let keyring = [];\n    keyring = encryptKey(this.key, password, options);\n    return formatEncrypted(4, this.address, keyring, options);\n  }\n  /**\n   * encrypts a keyring and returns a keystore v3 object.\n   *\n   * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\n   * @param {object} options The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n   * @return {object}\n   */\n\n\n  encryptV3(password, options) {\n    options = options || {};\n    const crypto = encryptKey(this.key, password, options)[0];\n    return formatEncrypted(3, this.address, crypto, options);\n  }\n  /**\n   * returns true if keyring has decoupled key.\n   *\n   * @return {boolean}\n   */\n\n\n  isDecoupled() {\n    return this.address.toLowerCase() !== this.key.getDerivedAddress().toLowerCase();\n  }\n\n}\n\nmodule.exports = SingleKeyring;","map":null,"metadata":{},"sourceType":"script"}