{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst _ = require('lodash');\n\nconst scrypt = require('scrypt-js');\n\nconst uuid = require('uuid');\n\nconst cryp = typeof global === 'undefined' ? require('crypto-browserify') : require('crypto');\n\nconst utils = require('../../../caver-utils');\n\nconst PrivateKey = require('./privateKey');\n\nconst KEY_ROLE = {\n  roleTransactionKey: 0,\n  0: 'roleTransactionKey',\n  roleAccountUpdateKey: 1,\n  1: 'roleAccountUpdateKey',\n  roleFeePayerKey: 2,\n  2: 'roleFeePayerKey',\n  roleLast: 3\n};\nconst MAXIMUM_KEY_NUM = 10;\n\nconst isMultipleKeysFormat = keys => {\n  if (!_.isArray(keys)) return false;\n  return keys.every(key => {\n    return _.isString(key);\n  });\n};\n\nconst isRoleBasedKeysFormat = roledBasedKeyArray => {\n  if (!_.isArray(roledBasedKeyArray)) return false;\n  if (roledBasedKeyArray.length > KEY_ROLE.roleLast) return false;\n  return roledBasedKeyArray.every(arr => {\n    return _.isArray(arr);\n  });\n};\n\nconst validateForSigning = (hash, chainId) => {\n  if (!utils.isValidHashStrict(hash)) throw new Error(\"Invalid transaction hash: \".concat(hash));\n\n  if (chainId === undefined) {\n    throw new Error(\"chainId should be defined to sign.\");\n  }\n};\n\nconst validateIndexWithKeys = (index, keyLength) => {\n  if (!_.isNumber(index)) throw new Error(\"Invalid type of index(\".concat(index, \"): index should be number type.\"));\n  if (index < 0) throw new Error(\"Invalid index(\".concat(index, \"): index cannot be negative.\"));\n  if (index >= keyLength) throw new Error(\"Invalid index(\".concat(index, \"): index must be less than the length of keys(\").concat(keyLength, \").\"));\n};\n\nconst decryptKey = (encryptedArray, password) => {\n  if (!encryptedArray || encryptedArray.length === 0) return undefined;\n  const decryptedArray = [];\n\n  for (const encrypted of encryptedArray) {\n    let derivedKey;\n    let kdfparams;\n    /**\n     * Supported kdf modules are the following:\n     * 1) pbkdf2\n     * 2) scrypt\n     */\n\n    if (encrypted.kdf === 'scrypt') {\n      kdfparams = encrypted.kdfparams; // FIXME: support progress reporting callback\n\n      derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n    } else if (encrypted.kdf === 'pbkdf2') {\n      kdfparams = encrypted.kdfparams;\n\n      if (kdfparams.prf !== 'hmac-sha256') {\n        throw new Error('Unsupported parameters to PBKDF2');\n      }\n\n      derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n    } else {\n      throw new Error('Unsupported key derivation scheme');\n    }\n\n    const ciphertext = Buffer.from(encrypted.ciphertext, 'hex');\n    const mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '');\n\n    if (mac !== encrypted.mac) {\n      throw new Error('Key derivation failed - possibly wrong password');\n    }\n\n    const decipher = cryp.createDecipheriv(encrypted.cipher, derivedKey.slice(0, 16), Buffer.from(encrypted.cipherparams.iv, 'hex'));\n    decryptedArray.push(\"0x\".concat(Buffer.from([...decipher.update(ciphertext), ...decipher.final()]).toString('hex')));\n  }\n\n  return decryptedArray;\n};\n\nconst encryptKey = (privateKey, password, options) => {\n  const encryptedArray = [];\n  if (!privateKey) return encryptedArray;\n  const privateKeyArray = _.isArray(privateKey) ? privateKey : [privateKey];\n\n  for (let i = 0; i < privateKeyArray.length; i++) {\n    const salt = options.salt || cryp.randomBytes(32);\n    const iv = options.iv || cryp.randomBytes(16);\n    let derivedKey;\n    const kdf = options.kdf || 'scrypt';\n    const kdfparams = {\n      dklen: options.dklen || 32,\n      salt: salt.toString('hex')\n    };\n    /**\n     * Supported kdf modules are the following:\n     * 1) pbkdf2\n     * 2) scrypt - default\n     */\n\n    if (kdf === 'pbkdf2') {\n      kdfparams.c = options.c || 262144;\n      kdfparams.prf = 'hmac-sha256';\n      derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n    } else if (kdf === 'scrypt') {\n      // FIXME: support progress reporting callback\n      kdfparams.n = options.n || 4096; // 2048 4096 8192 16384\n\n      kdfparams.r = options.r || 8;\n      kdfparams.p = options.p || 1;\n      derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n    } else {\n      throw new Error('Unsupported kdf');\n    }\n\n    const cipher = cryp.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);\n\n    if (!cipher) {\n      throw new Error('Unsupported cipher');\n    }\n\n    let prv = privateKeyArray[i];\n    if (privateKeyArray[i] instanceof PrivateKey) prv = privateKeyArray[i].privateKey;\n    const ciphertext = Buffer.from([...cipher.update(Buffer.from(prv.replace('0x', ''), 'hex')), ...cipher.final()]);\n    const mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '');\n    encryptedArray.push({\n      ciphertext: ciphertext.toString('hex'),\n      cipherparams: {\n        iv: iv.toString('hex')\n      },\n      cipher: options.cipher || 'aes-128-ctr',\n      kdf,\n      kdfparams,\n      mac: mac.toString('hex')\n    });\n  }\n\n  return encryptedArray;\n};\n\nconst formatEncrypted = (version, address, keyringOrCrypto, options) => {\n  const keystore = {\n    version,\n    id: uuid.v4({\n      random: options.uuid || cryp.randomBytes(16)\n    }),\n    address: address.toLowerCase()\n  };\n\n  if (version === 3) {\n    keystore.crypto = keyringOrCrypto;\n  } else if (version === 4) {\n    keystore.keyring = keyringOrCrypto;\n  } else {\n    throw new Error(\"Unsupported version of keystore\");\n  }\n\n  return keystore;\n};\n\nmodule.exports = {\n  KEY_ROLE,\n  MAXIMUM_KEY_NUM,\n  isMultipleKeysFormat,\n  isRoleBasedKeysFormat,\n  validateForSigning,\n  validateIndexWithKeys,\n  decryptKey,\n  encryptKey,\n  formatEncrypted\n};","map":null,"metadata":{},"sourceType":"script"}