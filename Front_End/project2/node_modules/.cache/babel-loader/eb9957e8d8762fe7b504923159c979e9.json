{"ast":null,"code":"var _slicedToArray = require(\"/Users/heeje/Desktop/Projcet_A/Front_End/project 2/node_modules/@babel/runtime/helpers/slicedToArray\");\n\n/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-core-method/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\nconst _ = require('lodash');\n\nconst errors = require('../../caver-core-helpers').errors;\n\nconst formatters = require('../../caver-core-helpers').formatters;\n\nconst utils = require('../../caver-utils');\n\nconst Subscriptions = require('../../caver-core-subscriptions').subscriptions;\n\nconst validateParams = require('../../caver-core-helpers').validateFunction.validateParams;\n\nconst TIMEOUTBLOCK = 50;\nconst AVERAGE_BLOCK_TIME = 1; // 1s\n\nconst POLLINGTIMEOUT = AVERAGE_BLOCK_TIME * TIMEOUTBLOCK; // ~average block time (seconds) * TIMEOUTBLOCK\n\nconst TransactionDecoder = require('../../caver-transaction/src/transactionDecoder/transactionDecoder');\n\nfunction Method(options) {\n  // call, name should be existed to create a method.\n  if (!options.call || !options.name) throw errors.needNameCallPropertyToCreateMethod;\n  this.name = options.name;\n  this.call = options.call;\n  this.hexCall = options.hexCall;\n  this.params = options.params || 0;\n  this.inputFormatter = options.inputFormatter || [];\n  this.outputFormatter = options.outputFormatter;\n  this.transformPayload = options.transformPayload;\n  this.extraFormatters = options.extraFormatters;\n  this.requestManager = options.requestManager; // reference to klay.accounts\n\n  this.accounts = options.accounts;\n  this.defaultBlock = options.defaultBlock || 'latest';\n  this.defaultAccount = options.defaultAccount || null;\n  this.outputFormatterDisable = options.outputFormatterDisable;\n}\n\nMethod.prototype.setRequestManager = setRequestManager;\nMethod.prototype.createFunction = createFunction;\nMethod.prototype.attachToObject = attachToObject;\nMethod.prototype.getCall = getCall;\nMethod.prototype.extractCallback = extractCallback;\nMethod.prototype.validateArgs = validateArgs;\nMethod.prototype.formatInput = formatInput;\nMethod.prototype.formatOutput = formatOutput;\nMethod.prototype.toPayload = toPayload;\nMethod.prototype.buildCall = buildCall;\nMethod.prototype._confirmTransaction = _confirmTransaction;\nMethod.prototype.request = request;\n/**\n * Set requestManager for rpc calling.\n * If it has accounts parameter also, set it.\n * @method setRequestManager\n * @param  {Object} requestManager\n * @param  {Object} accounts\n */\n\nfunction setRequestManager(requestManager, accounts) {\n  this.requestManager = requestManager; // reference to klay.accounts\n\n  if (accounts) this.accounts = accounts;\n}\n/**\n * createFunction through 'this' context (= instance by created through new Method(...))\n * @method createFunction\n * @param  {Object} requestManager\n * @param  {Object} accounts\n * @return {Function} it will be used for sending RPC call.\n */\n\n\nfunction createFunction(requestManager, accounts) {\n  // set requestManager for method individulally.\n  this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts); // this.buildCall() returns function `send = function() { ... }`\n\n  const func = this.buildCall(); // call is directly used for rpc calling,\n  // ex) 'klay_sendTransaction'\n\n  func.call = this.call;\n  return func;\n}\n/**\n * attach buildCalled method to 'obj' object,\n * by adding a property name through this.name\n * @method attachToObject\n * @param  {Object} obj\n */\n\n\nfunction attachToObject(obj) {\n  const func = this.buildCall();\n  func.call = this.call;\n\n  const _this$name$split = this.name.split('.'),\n        _this$name$split2 = _slicedToArray(_this$name$split, 2),\n        callName = _this$name$split2[0],\n        optionalName = _this$name$split2[1];\n\n  if (optionalName) {\n    obj[callName] = obj[callName] || {};\n    obj[callName][optionalName] = func;\n  } else {\n    obj[callName] = func;\n  }\n}\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\n\n\nfunction getCall(args) {\n  // If hexCall is defined, args[0] type is truly hexParameter, return this.hexCall\n  // If not, return this.call\n  // 'this.call', 'this.hexCall' are defined in rpc.json\n  return this.hexCall && utils.isHexParameter(args[0]) ? this.hexCall : this.call;\n}\n/**\n * Should be used to extract callback from array of arguments.\n * (caution) It modifies input param.\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\n\nfunction extractCallback(args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // 'pop' method modifies the original args array!\n  }\n}\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\n\nfunction validateArgs(args) {\n  if (args.length !== this.params) {\n    throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n  }\n}\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\n\nfunction formatInput(args) {\n  const _this = this; // If inputFormatter is not defined, or empty just return original args.\n\n\n  if (!this.inputFormatter || _.isEmpty(this.inputFormatter)) {\n    return args;\n  } // If inputFormatter is defined, map original args by calling formatter.\n\n\n  return this.inputFormatter.map((formatter, index) => {\n    // bind this for defaultBlock, and defaultAccount\n    return formatter && formatter.call(_this, args[index]) || args[index];\n  });\n}\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\n\n\nfunction formatOutput(result) {\n  const _this = this; // If outputFormatter is defined, calling outputFormatter,\n  // If not, just return original res.\n\n\n  const _formatOutput = res => typeof _this.outputFormatter === 'function' ? _this.outputFormatter(res) : res; // If result is array, map it through calling _formatOuput\n  // If result is single, just calling _formatOutput.\n\n\n  return _.isArray(result) ? result.map(_formatOutput) : _formatOutput(result);\n}\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\n\n\nfunction toPayload(args) {\n  const call = this.getCall(args);\n  const callback = this.extractCallback(args);\n  const inputParams = this.formatInput(args);\n  this.validateArgs(inputParams);\n  const payload = {\n    method: call,\n    params: inputParams,\n    callback\n  }; // If payload transform option is existing, apply it.\n  // If not, just return payload.\n\n  return this.transformPayload && this.transformPayload(payload) || payload;\n}\n\nconst buildSendTxCallbackFunc = (defer, method, payload, isSendTx) => (err, result) => {\n  try {\n    result = method.formatOutput(result);\n  } catch (e) {\n    if (!err) err = e;\n  }\n\n  err = result instanceof Error && result || err; // If err exists, fireError\n\n  if (err) {\n    return utils._fireError(err.error || err, // sometimes, err.error property exists, in case, fire it instead 'err'\n    defer.eventEmitter, defer.reject, payload.callback);\n  } // fire callback\n\n\n  if (payload.callback) payload.callback(null, result); // return PROMISE\n\n  if (!isSendTx) {\n    defer.resolve(result);\n  } else {\n    defer.eventEmitter.emit('transactionHash', result);\n\n    method._confirmTransaction(defer, result, payload);\n  }\n};\n\nconst buildSendSignedTxFunc = (method, payload, sendTxCallback) => signed => {\n  const rawTransaction = signed.rawTransaction ? signed.rawTransaction : signed;\n\n  const signedPayload = _.extend({}, payload, {\n    method: 'klay_sendRawTransaction',\n    params: [rawTransaction]\n  });\n\n  method.requestManager.send(signedPayload, sendTxCallback);\n};\n\nconst buildSendRequestFunc = (defer, sendSignedTx, sendTxCallback) => (payload, method) => {\n  const methodName = payload.method; // Logic for handling multiple cases of parameters in sendSignedTransaction.\n  // 1. Object containing rawTransaction\n  //    : call 'klay_sendRawTransaction' with RLP encoded transaction(rawTransaction) in object\n  // 2. A transaction object containing signatures or feePayerSignatures\n  //    : call 'getRawTransactionWithSignatures', then call 'klay_sendRawTransaction' with result of getRawTransactionWithSignatures\n\n  if (method && methodName === 'klay_sendRawTransaction') {\n    // The existence of accounts in the method means the implementation before the common architecture.\n    if (method.accounts) {\n      const transaction = payload.params[0];\n\n      if (typeof transaction !== 'string' && _.isObject(transaction)) {\n        if (transaction.rawTransaction) {\n          return sendSignedTx(transaction);\n        }\n\n        return method.accounts.getRawTransactionWithSignatures(transaction).then(sendSignedTx).catch(e => {\n          sendTxCallback(e);\n        });\n      }\n    } else {\n      const transaction = payload.params[0];\n\n      if (!_.isString(transaction) && _.isObject(transaction) && _.isFunction(transaction.getRLPEncoding)) {\n        return sendSignedTx(transaction.getRLPEncoding());\n      }\n    }\n  } // In the previous implementation of common architecture,\n  // if there was an account in the in-memory wallet before requesting to send or sign a transaction to the node,\n  // it was handled by using it.\n\n\n  if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n    switch (methodName) {\n      case 'klay_sendTransaction':\n        {\n          const tx = payload.params[0];\n          let error;\n\n          if (!_.isObject(tx)) {\n            sendTxCallback(new Error('The transaction must be defined as an object.'));\n            return;\n          }\n\n          let addressToUse = tx.from;\n\n          if (tx.senderRawTransaction && tx.feePayer) {\n            addressToUse = tx.feePayer;\n\n            if (tx.from) {\n              console.log('\"from\" is ignored for a fee-delegated transaction.');\n              delete tx.from;\n            }\n          }\n\n          let wallet;\n\n          try {\n            wallet = method.accounts.wallet.getAccount(addressToUse);\n          } catch (e) {\n            sendTxCallback(e);\n            return;\n          }\n\n          if (wallet && wallet.privateKey) {\n            const privateKey = method.accounts._getRoleKey(tx, wallet); // If wallet was found, sign tx, and send using sendRawTransaction\n\n\n            return method.accounts.signTransaction(tx, privateKey).then(sendSignedTx).catch(e => {\n              sendTxCallback(e);\n            });\n          }\n\n          if (tx.signatures) {\n            // If signatures is defined inside of the transaction object,\n            // get rawTransaction string from signed transaction object and send to network\n            return method.accounts.getRawTransactionWithSignatures(tx).then(sendSignedTx).catch(e => {\n              sendTxCallback(e);\n            });\n          } // If wallet was not found in caver-js wallet, then it has to use wallet in Node.\n          // Signing to transaction using wallet in Node supports only LEGACY transaction, so if transaction is not LEGACY, return error.\n\n\n          if (tx.feePayer !== undefined || tx.type !== undefined && tx.type !== 'LEGACY') {\n            error = new Error(\"No private key found in the caver-js wallet. Trying to use the Klaytn node's wallet, but it only supports legacy transactions. Please add private key of \".concat(addressToUse, \" to the caver-js wallet.\"));\n            sendTxCallback(error);\n            return;\n          }\n\n          error = validateParams(tx);\n\n          if (error) {\n            sendTxCallback(error);\n            return;\n          }\n\n          break;\n        }\n\n      case 'klay_sign':\n        {\n          const data = payload.params[1];\n          const wallet = method.accounts.wallet.getAccount(payload.params[0]);\n\n          if (wallet && wallet.privateKey) {\n            // If wallet was found, sign tx, and send using sendRawTransaction\n            const sign = method.accounts.sign(data, wallet.privateKey);\n            if (payload.callback) payload.callback(null, sign.signature);\n            defer.resolve(sign.signature);\n            return;\n          }\n\n          break;\n        }\n    }\n  } // When sending a request to send or sign a transaction using a key stored in a Klaytn node,\n  // the variable names inside the transaction must be properly formatted.\n  // { _from: '0x..', _signatures: ['0x..', '0x..', '0x..'] } -> { from: '0x..', signatures: { V: '0x..', R: '0x..', S: '0x..'} }\n\n\n  if (methodName === 'klay_sendTransaction' || methodName === 'klay_sendTransactionAsFeePayer' || methodName === 'klay_signTransaction' || methodName === 'klay_signTransactionAsFeePayer') {\n    const tx = {};\n    Object.keys(payload.params[0]).map(k => {\n      let key = k;\n      if (key.startsWith('_')) key = key.slice(1);\n\n      if (key === 'signatures' || key === 'feePayerSignatures') {\n        if (!utils.isEmptySig(payload.params[0][key])) {\n          tx[key] = utils.transformSignaturesToObject(payload.params[0][key]);\n\n          if (key === 'signatures' && (methodName === 'klay_signTransaction' || methodName === 'klay_sendTransaction')) {\n            console.warn(\"When sign/send a transaction using the Node API, existing 'signatures' can be initialized.\");\n          }\n\n          if (key === 'feePayerSignatures' && (methodName === 'klay_signTransactionAsFeePayer' || methodName === 'klay_sendTransactionAsFeePayer')) {\n            console.warn(\"When sign/send a transaction using the Node API, existing 'feePayerSignatures' can be initialized.\");\n          }\n        }\n      } else if (key === 'codeFormat') {\n        tx[key] = utils.hexToNumber(payload.params[0][key]);\n      } else if (key === 'account') {\n        tx.key = payload.params[0][key].getRLPEncodingAccountKey();\n      } else if (payload.params[0][key] !== '0x') {\n        tx[key] = payload.params[0][key];\n      }\n    });\n    payload.params[0] = tx;\n  }\n\n  return method.requestManager.send(payload, sendTxCallback);\n};\n\nconst buildSendFunc = (method, isSendTx) => (...args) => {\n  const defer = utils.promiEvent(!isSendTx);\n  const payload = method.toPayload(args);\n  const sendTxCallback = buildSendTxCallbackFunc(defer, method, payload, isSendTx);\n  const sendSignedTx = buildSendSignedTxFunc(method, payload, sendTxCallback);\n  const sendRequest = buildSendRequestFunc(defer, sendSignedTx, sendTxCallback);\n  const isGasPriceInputMissing = isSendTx && _.isObject(payload.params[0]) && payload.params[0].gasPrice === undefined; // If gasPrice input is missing, call getGasPrice rpc\n\n  if (!isGasPriceInputMissing) {\n    sendRequest(payload, method);\n    return defer.eventEmitter;\n  }\n\n  const getGasPrice = new Method({\n    name: 'getGasPrice',\n    call: 'klay_gasPrice',\n    params: 0\n  }).createFunction(method.requestManager);\n  getGasPrice((err, gasPrice) => {\n    payload.params[0].gasPrice = gasPrice || payload.params[0].gasPrice;\n    sendRequest(payload, method);\n  });\n  /**\n   * attaching `.on('receipt')` is possible by returning defer.eventEmitter\n   */\n\n  return defer.eventEmitter;\n};\n\nfunction buildCall() {\n  const method = this;\n  const isSendTx = method.call === 'klay_sendTransaction' || method.call === 'klay_sendTransactionAsFeePayer' || method.call === 'klay_sendRawTransaction' || method.call === 'personal_sendTransaction' || method.call === 'personal_sendValueTransfer' || method.call === 'personal_sendAccountUpdate';\n  const send = buildSendFunc(method, isSendTx); // necessary to attach things to the method\n\n  send.method = method; // necessary for batch requests\n\n  send.request = this.request.bind(this);\n  return send;\n}\n\nfunction _confirmTransaction(defer, result, payload) {\n  let payloadTxObject = payload.params && _.isObject(payload.params[0]) && payload.params[0] || {}; // If payload.params[0] is RLP-encoded string, decode RLP-encoded string to Transaction instance.\n\n  if (_.isString(payload.params[0])) payloadTxObject = TransactionDecoder.decode(payload.params[0]); // mutableConfirmationPack will be used in\n  // 1) checkConfirmation,\n  // 2) startWatching functions\n  // It is * mutable *, both functions can affect properties mutably.\n\n  const mutableConfirmationPack = {\n    method: this,\n    promiseResolved: false,\n    canUnsubscribe: true,\n    timeoutCount: 0,\n    intervalId: null,\n    gasProvided: payloadTxObject.gas || null,\n    isContractDeployment: utils.isContractDeployment(payloadTxObject),\n    defer,\n    result,\n    _klaytnCall: {}\n  };\n  addCustomSendMethod(mutableConfirmationPack);\n  kickoffConfirmation(mutableConfirmationPack);\n}\n\nconst addCustomSendMethod = mutableConfirmationPack => {\n  const customSendMethods = [new Method({\n    name: 'getTransactionReceipt',\n    call: 'klay_getTransactionReceipt',\n    params: 1,\n    outputFormatter: !mutableConfirmationPack.method.outputFormatterDisable ? formatters.outputTransactionReceiptFormatter : undefined\n  }), new Method({\n    name: 'getCode',\n    call: 'klay_getCode',\n    params: 2,\n    inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n  }), new Subscriptions({\n    name: 'subscribe',\n    type: 'klay',\n    subscriptions: {\n      newBlockHeaders: {\n        subscriptionName: 'newHeads',\n        // replace subscription with this name\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      }\n    }\n  })]; // add custom send Methods\n\n  _.each(customSendMethods, mthd => {\n    // attach methods to _klaytnCall\n    mthd.attachToObject(mutableConfirmationPack._klaytnCall); // assign rather than call setRequestManager()\n\n    mthd.requestManager = mutableConfirmationPack.method.requestManager;\n  });\n};\n\nconst kickoffConfirmation = mutableConfirmationPack => {\n  // eslint-disable-next-line no-unused-vars\n  const defer = mutableConfirmationPack.defer,\n        promiseResolved = mutableConfirmationPack.promiseResolved,\n        result = mutableConfirmationPack.result,\n        _klaytnCall = mutableConfirmationPack._klaytnCall; // first check if we already have a confirmed transaction\n\n  _klaytnCall.getTransactionReceipt(result).then(receipt => {\n    if (receipt && receipt.blockHash) {\n      // `isPolling` is false in default.\n      checkConfirmation(mutableConfirmationPack, receipt, false);\n    } else if (!promiseResolved) startWatching(mutableConfirmationPack, receipt);\n  }).catch(() => {\n    if (!promiseResolved) startWatching(mutableConfirmationPack);\n  });\n}; // start watching for confirmation depending on the support features of the provider\n\n\nconst startWatching = function (mutableConfirmationPack, existingReceipt) {\n  // eslint-disable-next-line no-unused-vars\n  const _klaytnCall = mutableConfirmationPack._klaytnCall,\n        intervalId = mutableConfirmationPack.intervalId,\n        method = mutableConfirmationPack.method; // if provider allows PUB/SUB\n\n  if (method.requestManager.provider.supportsSubscriptions()) {\n    _klaytnCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, mutableConfirmationPack, existingReceipt, false));\n  } else {\n    mutableConfirmationPack.intervalId = setInterval(checkConfirmation.bind(null, mutableConfirmationPack, existingReceipt, true), 1000);\n  }\n}; // fire \"receipt\" and confirmation events and resolve after\n\n\nconst checkConfirmation = function (mutableConfirmationPack, existingReceipt, isPolling, err, blockHeader, sub) {\n  const intervalId = mutableConfirmationPack.intervalId,\n        defer = mutableConfirmationPack.defer,\n        method = mutableConfirmationPack.method,\n        canUnsubscribe = mutableConfirmationPack.canUnsubscribe,\n        _klaytnCall = mutableConfirmationPack._klaytnCall,\n        isContractDeployment = mutableConfirmationPack.isContractDeployment,\n        promiseResolved = mutableConfirmationPack.promiseResolved,\n        timeoutCount = mutableConfirmationPack.timeoutCount,\n        result = mutableConfirmationPack.result;\n\n  if (err) {\n    sub.unsubscribe();\n    mutableConfirmationPack.promiseResolved = true;\n\n    utils._fireError({\n      message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n      data: err\n    }, defer.eventEmitter, defer.reject);\n\n    return;\n  } // create fake unsubscribe\n\n\n  sub = sub || {\n    unsubscribe: () => clearInterval(mutableConfirmationPack.intervalId)\n  }; // if we have a valid receipt we don't need to send a request\n\n  return (existingReceipt && utils.promiEvent.resolve(existingReceipt) || _klaytnCall.getTransactionReceipt(result)). // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n  then(receipt => {\n    checkIsReceiptInBlock(receipt);\n    const formattedReceipt = formatReceipt(receipt, method);\n    if (mutableConfirmationPack.promiseResolved) return;\n    return isContractDeployment ? checkForContractDeployment(mutableConfirmationPack, formattedReceipt, sub) : checkForNormalTx(mutableConfirmationPack, formattedReceipt, sub);\n  }).catch(countTimeout);\n};\n\nconst checkIsReceiptInBlock = receipt => {\n  if (receipt && !receipt.blockHash) throw errors.blockHashNull;\n};\n\nconst formatReceipt = (receipt, method) => {\n  if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n    receipt = method.extraFormatters.receiptFormatter(receipt);\n  }\n\n  return receipt;\n};\n\nconst countTimeout = (mutableConfirmationPack, isPolling, sub) => {\n  // eslint-disable-next-line no-unused-vars\n  const defer = mutableConfirmationPack.defer,\n        timeoutCount = mutableConfirmationPack.timeoutCount,\n        promiseResolved = mutableConfirmationPack.promiseResolved; // time out the transaction if not mined after 50 blocks\n\n  mutableConfirmationPack.timeoutCount++; // check to see if we are http polling\n\n  if (isPolling) {\n    // polling timeout is different than TIMEOUTBLOCK blocks since we are triggering every second\n    if (mutableConfirmationPack.timeoutCount - 1 >= POLLINGTIMEOUT) {\n      sub.unsubscribe();\n      mutableConfirmationPack.promiseResolved = true;\n\n      utils._fireError(new Error(\"Transaction was not mined within\".concat(POLLINGTIMEOUT, \" seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!\")), defer.eventEmitter, defer.reject);\n    }\n  } else if (mutableConfirmationPack.timeoutCount - 1 >= TIMEOUTBLOCK) {\n    sub.unsubscribe();\n    mutableConfirmationPack.promiseResolved = true;\n\n    utils._fireError(new Error('Transaction was not mined within 50 blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n  }\n};\n\nconst checkForContractDeployment = (mutableConfirmationPack, receipt, sub) => {\n  // eslint-disable-next-line no-unused-vars\n  const defer = mutableConfirmationPack.defer,\n        method = mutableConfirmationPack.method,\n        canUnsubscribe = mutableConfirmationPack.canUnsubscribe,\n        _klaytnCall = mutableConfirmationPack._klaytnCall,\n        promiseResolved = mutableConfirmationPack.promiseResolved; // If contract address doesn't exist, fire error.\n\n  if (!receipt.contractAddress) {\n    if (canUnsubscribe) {\n      sub.unsubscribe();\n      mutableConfirmationPack.promiseResolved = true;\n    }\n\n    utils._fireError(errors.receiptDidntContainContractAddress, defer.eventEmitter, defer.reject);\n\n    return;\n  }\n\n  if (!receipt.status && receipt.txError) {\n    const receiptJSON = JSON.stringify(receipt, null, 2);\n\n    utils._fireError(new Error(\"\".concat(errors.txErrorTable[receipt.txError], \"\\n \").concat(receiptJSON)), defer.eventEmitter, defer.reject);\n  }\n\n  _klaytnCall.getCode(receipt.contractAddress, (e, code) => {\n    if (!code) return;\n    defer.eventEmitter.emit('receipt', receipt); // if contract, return instance instead of receipt\n\n    defer.resolve(method.extraFormatters && method.extraFormatters.contractDeployFormatter && method.extraFormatters.contractDeployFormatter(receipt) || receipt); // need to remove listeners, as they aren't removed automatically when succesfull\n\n    if (canUnsubscribe) defer.eventEmitter.removeAllListeners();\n    if (canUnsubscribe) sub.unsubscribe();\n    mutableConfirmationPack.promiseResolved = true;\n  });\n\n  return receipt;\n};\n\nconst checkForNormalTx = (mutableConfirmationPack, receipt, sub) => {\n  // eslint-disable-next-line no-unused-vars\n  const defer = mutableConfirmationPack.defer,\n        canUnsubscribe = mutableConfirmationPack.canUnsubscribe,\n        promiseResolved = mutableConfirmationPack.promiseResolved,\n        gasProvided = mutableConfirmationPack.gasProvided;\n\n  if (receipt && !receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n    // Happy case: transaction is processed well. A.K.A 'well-done receipt'.\n    try {\n      mutableConfirmationPack.defer.eventEmitter.emit('receipt', receipt);\n      mutableConfirmationPack.defer.resolve(receipt);\n    } catch (e) {\n      console.log('receipt error', e);\n    } // need to remove listeners, as they aren't removed automatically when succesfull\n\n\n    if (canUnsubscribe) {\n      mutableConfirmationPack.defer.eventEmitter.removeAllListeners();\n    }\n  } else {\n    // Unhappy case: trasaction has error. A.K.A 'bad receipt'.\n    if (!receipt) return;\n    const receiptJSON = JSON.stringify(receipt, null, 2);\n    const txError = receipt.txError;\n\n    if (txError && errors.txErrorTable[txError]) {\n      utils._fireError(new Error(\"\".concat(errors.txErrorTable[txError], \"\\n \").concat(receiptJSON)), mutableConfirmationPack.defer.eventEmitter, mutableConfirmationPack.defer.reject);\n    } else if (receipt.status === false || receipt.status === '0x0') {\n      utils._fireError(errors.transactionReverted(receiptJSON), mutableConfirmationPack.defer.eventEmitter, mutableConfirmationPack.defer.reject);\n    } else if (receipt.gasUsed >= gasProvided) {\n      utils._fireError(errors.transactionRanOutOfGas(receiptJSON), mutableConfirmationPack.defer.eventEmitter, mutableConfirmationPack.defer.reject);\n    } else {\n      utils._fireError(errors.transactionRanOutOfGas(receiptJSON), mutableConfirmationPack.defer.eventEmitter, mutableConfirmationPack.defer.reject);\n    }\n  }\n\n  if (canUnsubscribe) sub.unsubscribe();\n  mutableConfirmationPack.promiseResolved = true;\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\n\n\nfunction request(...args) {\n  const payload = this.toPayload(args);\n  payload.format = this.formatOutput.bind(this);\n  return payload;\n}\n\nmodule.exports = Method;","map":null,"metadata":{},"sourceType":"script"}